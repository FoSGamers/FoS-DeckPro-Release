================================================================================
File: requirements.txt
================================================================================

# --- File: requirements.txt --- START ---
fastapi>=0.110.0
uvicorn[standard]>=0.29.0
python-dotenv>=1.0.0
twitchio>=2.10.0
google-api-python-client>=2.80.0
google-auth-oauthlib>=1.0.0
google-auth-httplib2>=0.1.0
tweepy>=4.13.0
websockets>=11.0.0
httpx>=0.27.0
requests-oauthlib>=1.3.0
aiohttp>=3.8.0
nest-asyncio>=1.5.0
aiofiles>=23.1.0
pydantic>=2.0.0
typing-extensions>=4.8.0
click>=7.0
h11>=0.8
httptools>=0.5.0
pyyaml>=5.1
uvloop>=0.17.0
watchfiles>=0.13
certifi
googleapis-common-protos>=1.56.2,<2.0.0
protobuf>=3.19.5,<7.0.0
proto-plus>=1.22.3,<2.0.0
cachetools>=2.0.0,<6.0
pyasn1-modules>=0.2.1
rsa>=3.1.4,<5
pyparsing!=3.0.0,!=3.0.1,!=3.0.2,!=3.0.3,<4,>=2.4.2
charset-normalizer<4,>=2
urllib3<3,>=1.21.1
sniffio>=1.1
pyasn1>=0.6.1,<0.7.0
attrs>=17.3.0
frozenlist>=1.1.1
multidict<7.0,>=4.5
yarl<2.0,>=1.0
annotated-types>=0.4.0
typing-inspection>=0.4.0
idna
aiosignal>=1.1.2
oauthlib<4,>=3.2.0
requests<3,>=2.27.0
httpcore>=1.0.0,<2.0.0
aiohappyeyeballs>=2.3.0
propcache>=0.2.0
# --- File: requirements.txt --- END ---


================================================================================
File: README.md
================================================================================

# FoSBot: Your Epic Stream Chat Adventure

Welcome, brave streamer, to **FoSBot**—the ultimate companion for your Magic: The Gathering and Dungeons & Dragons live streams! This bot unites Whatnot, YouTube, Twitch, and X chats into one magical dashboard, letting you engage your party with commands like `!checkin`, `!ping`, and `!roll`. Roll for initiative and let's get started!

## Your Quest: Setup (Level 1 - Easy)

### Prerequisites
- **Python 3.13**: Your trusty spellbook. Install it from [python.org](https://www.python.org/downloads/) or via Homebrew (`brew install python@3.13`).
- **Chrome Browser**: Your enchanted portal to the dashboard.

### Step 1: Unpack the Treasure
1. **Grab the Loot**:
   - Download `fosbot.zip` from our Patreon ([insert your Patreon link]).
   - Unzip it to a folder, like `~/FoSBot`:
     ```bash
     unzip fosbot.zip -d ~/FoSBot
     ```

### Step 2: Cast the Setup Spell
1. **Enter the Dungeon**:
   - Open Terminal (Mac: Spotlight > "Terminal").
   - Navigate to your folder:
     ```bash
     cd ~/FoSBot
     ```
2. **Prepare Your Magic**:
   - Create a virtual environment and install dependencies:
     ```bash
     /opt/homebrew/bin/python3.13 -m venv venv
     source venv/bin/activate
     pip install -r requirements.txt
     ```
3. **Launch the Portal**:
   - Run the app:
     ```bash
     uvicorn app.main:app --host localhost --port 8000
     ```
   - If you see “Application startup complete,” you’re ready!

### Step 3: Enter the Dashboard
1. **Open the Gate**:
   - In Chrome, go to http://localhost:8000.
2. **Join the Party**:
   - Go to the **Settings** tab.
   - Click “Login with YouTube,” “Login with Twitch,” and “Login with X.” Sign in to each—no developer portals needed, just your account!
3. **Whatnot Enchantment**:
   - In Settings, click “Guided Setup” for step-by-step help or download `whatnot_extension.zip`.
   - Unzip to a folder (e.g., `~/FoSBot_Whatnot`).
   - In Chrome, go to `chrome://extensions/`, enable “Developer mode,” click “Load unpacked,” and select the folder.
   - On a Whatnot stream, click the extension icon (puzzle piece), enable “Select Mode,” click chat elements, and save.
   - **Need Help?** Watch our 1-minute setup video on Patreon ([insert your video link]).

### Step 4: Wield Your Powers
- **Chat Tab**:
  - See all platform chats in real-time.
  - Send messages or commands (e.g., `!ping` for “Pong!”).
- **Commands Tab**:
  - Click “Add Command” to create new ones (e.g., `!roll` for “Rolled a 15!”).
  - Upload a CSV (`command,response`) to add multiple commands.
  - Edit or delete as needed.
- **Settings Tab**:
  - Manage logins, Twitch channels, and services (start/stop/restart).
- **Commands to Try**:
  - `!checkin`: Marks your presence in the tavern.
  - `!ping`: Tests the bot’s reflexes.
  - `!roll`: Rolls a die (e.g., `!roll d20`).
  - Add your own in the Commands tab!

## The Playbook: Tips for Glory
- **Engage Your Guild**:
  - Use `!roll` for D&D flair (add via Commands tab).
  - Broadcast messages to all platforms from the Chat tab.
- **Troubleshooting**:
  - **Login Issues?** Ensure you’re signed into the right account. Check the video if stuck.
  - **Whatnot Not Working?** Verify selectors in the extension popup.
  - **App Won’t Run?** Confirm Python 3.13 and re-run `pip install -r requirements.txt`.
- **Need a Bard?** Post on our Patreon for help!

## Epic Loot (Future Quests)
- Add more commands like `!quest` for community challenges.
- Share feedback on Patreon to shape FoSBot’s saga!

**Roll a natural 20 and stream on!**

*Created by [Your Name] for the MTG & D&D crew. No OAuth setup needed—log in and play!*


================================================================================
File: combine_files.py
================================================================================

import os
from pathlib import Path

def combine_files_to_txt(output_file="project_files.txt"):
    # Define the root directory (current working directory)
    root_dir = Path.cwd()
    
    # Define file extensions to include (add or remove as needed)
    include_extensions = (
        '.py', '.js', '.ts', '.html', '.css', '.scss', '.json', 
        '.java', '.c', '.cpp', '.cs', '.go', '.rb', '.php', '.sql', 
        '.md', '.txt', '.sh', '.yml', '.yaml', '.xml'
    )
    
    # Define directories and files to exclude
    exclude_dirs = {'.git', 'node_modules', '__pycache__', 'venv', '.venv', 'dist', 'build', 'env', '.idea', '.vscode'}
    exclude_files = {'package-lock.json', 'yarn.lock', output_file}
    
    # Open the output file
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, dirs, files in os.walk(root_dir):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if d not in exclude_dirs]
            
            for file in files:
                # Skip excluded files and non-code files
                if file in exclude_files or not file.endswith(include_extensions):
                    continue
                
                file_path = Path(root) / file
                try:
                    # Read the file content
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                    
                    # Write file path (relative to root) and content to output
                    relative_path = file_path.relative_to(root_dir)
                    outfile.write(f"{'='*80}\n")
                    outfile.write(f"File: {relative_path}\n")
                    outfile.write(f"{'='*80}\n\n")
                    outfile.write(content)
                    outfile.write("\n\n")  # Add spacing between files
                
                except (UnicodeDecodeError, PermissionError) as e:
                    # Skip files that can't be read as text or are inaccessible
                    outfile.write(f"{'='*80}\n")
                    outfile.write(f"File: {relative_path}\n")
                    outfile.write(f"{'='*80}\n")
                    outfile.write(f"Error: Could not read file ({str(e)})\n\n")
    
    print(f"Combined files into {output_file}")

if __name__ == "__main__":
    combine_files_to_txt()

================================================================================
File: create_fosbot_files.sh
================================================================================

#!/bin/bash

# Ensure directories exist
mkdir -p app/core app/apis app/services static whatnot_extension data

# Create root files
cat > .env << 'EOF'
# --- File: .env --- START ---
# Application Settings
COMMAND_PREFIX=!
WS_HOST=localhost
WS_PORT=8000
LOG_LEVEL=DEBUG
DATA_DIR=data

# OAuth Application Credentials (FOR APP OWNER ONLY)
# App owner must set these ONCE in developer portals (Google Cloud, Twitch Dev, Twitter Dev).
# Users do NOT need to configure these—they log in via dashboard buttons.
# KEEP THESE SECRET - DO NOT COMMIT TO GIT
TWITCH_APP_CLIENT_ID=YOUR_TWITCH_CLIENT_ID_HERE
TWITCH_APP_CLIENT_SECRET=YOUR_TWITCH_CLIENT_SECRET_HERE
YOUTUBE_APP_CLIENT_ID=YOUR_YOUTUBE_CLIENT_ID_HERE
YOUTUBE_APP_CLIENT_SECRET=YOUR_YOUTUBE_CLIENT_SECRET_HERE
X_APP_CLIENT_ID=YOUR_X_CLIENT_ID_HERE
X_APP_CLIENT_SECRET=YOUR_X_CLIENT_SECRET_HERE

# Security (FOR APP OWNER ONLY)
# Generate with: python -c "import secrets; print(secrets.token_hex(32))"
APP_SECRET_KEY=YOUR_GENERATED_32_BYTE_HEX_SECRET_KEY_HERE
# --- File: .env --- END ---
EOF

cat > .gitignore << 'EOF'
# --- File: .gitignore --- START ---
# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
build/
dist/
*.egg-info/
venv/

# Environment
.env
*.env

# Data
data/*.json

# Extension
whatnot_extension.zip

# IDEs
.vscode/
.idea/
*.sublime-*

# Logs
*.log

# Misc
.DS_Store
*.swp
*.swo
# --- File: .gitignore --- END ---
EOF

cat > requirements.txt << 'EOF'
# --- File: requirements.txt --- START ---
fastapi>=0.110.0
uvicorn[standard]>=0.29.0
python-dotenv>=1.0.0
twitchio>=2.10.0
google-api-python-client>=2.80.0
google-auth-oauthlib>=1.0.0
google-auth-httplib2>=0.1.0
tweepy>=4.13.0
websockets>=11.0.0
httpx>=0.27.0
requests-oauthlib>=1.3.0
aiohttp>=3.8.0
nest-asyncio>=1.5.0
aiofiles>=23.1.0
pydantic>=2.0.0
typing-extensions>=4.8.0
click>=7.0
h11>=0.8
httptools>=0.5.0
pyyaml>=5.1
uvloop>=0.17.0
watchfiles>=0.13
certifi
googleapis-common-protos>=1.56.2,<2.0.0
protobuf>=3.19.5,<7.0.0
proto-plus>=1.22.3,<2.0.0
cachetools>=2.0.0,<6.0
pyasn1-modules>=0.2.1
rsa>=3.1.4,<5
pyparsing!=3.0.0,!=3.0.1,!=3.0.2,!=3.0.3,<4,>=2.4.2
charset-normalizer<4,>=2
urllib3<3,>=1.21.1
sniffio>=1.1
pyasn1>=0.6.1,<0.7.0
attrs>=17.3.0
frozenlist>=1.1.1
multidict<7.0,>=4.5
yarl<2.0,>=1.0
annotated-types>=0.4.0
typing-inspection>=0.4.0
idna
aiosignal>=1.1.2
oauthlib<4,>=3.2.0
requests<3,>=2.27.0
httpcore>=1.0.0,<2.0.0
aiohappyeyeballs>=2.3.0
propcache>=0.2.0
# --- File: requirements.txt --- END ---
EOF

cat > README.md << 'EOF'
# FoSBot: Your Epic Stream Chat Adventure

Welcome, brave streamer, to **FoSBot**—the ultimate companion for your Magic: The Gathering and Dungeons & Dragons live streams! This bot unites Whatnot, YouTube, Twitch, and X chats into one magical dashboard, letting you engage your party with commands like `!checkin`, `!ping`, and `!roll`. Roll for initiative and let's get started!

## Your Quest: Setup (Level 1 - Easy)

### Prerequisites
- **Python 3.13**: Your trusty spellbook. Install it from [python.org](https://www.python.org/downloads/) or via Homebrew (`brew install python@3.13`).
- **Chrome Browser**: Your enchanted portal to the dashboard.

### Step 1: Unpack the Treasure
1. **Grab the Loot**:
   - Download `fosbot.zip` from our Patreon ([insert your Patreon link]).
   - Unzip it to a folder, like `~/FoSBot`:
     ```bash
     unzip fosbot.zip -d ~/FoSBot
     ```

### Step 2: Cast the Setup Spell
1. **Enter the Dungeon**:
   - Open Terminal (Mac: Spotlight > "Terminal").
   - Navigate to your folder:
     ```bash
     cd ~/FoSBot
     ```
2. **Prepare Your Magic**:
   - Create a virtual environment and install dependencies:
     ```bash
     /opt/homebrew/bin/python3.13 -m venv venv
     source venv/bin/activate
     pip install -r requirements.txt
     ```
3. **Launch the Portal**:
   - Run the app:
     ```bash
     uvicorn app.main:app --host localhost --port 8000
     ```
   - If you see “Application startup complete,” you’re ready!

### Step 3: Enter the Dashboard
1. **Open the Gate**:
   - In Chrome, go to http://localhost:8000.
2. **Join the Party**:
   - Go to the **Settings** tab.
   - Click “Login with YouTube,” “Login with Twitch,” and “Login with X.” Sign in to each—no developer portals needed, just your account!
3. **Whatnot Enchantment**:
   - In Settings, click “Guided Setup” for step-by-step help or download `whatnot_extension.zip`.
   - Unzip to a folder (e.g., `~/FoSBot_Whatnot`).
   - In Chrome, go to `chrome://extensions/`, enable “Developer mode,” click “Load unpacked,” and select the folder.
   - On a Whatnot stream, click the extension icon (puzzle piece), enable “Select Mode,” click chat elements, and save.
   - **Need Help?** Watch our 1-minute setup video on Patreon ([insert your video link]).

### Step 4: Wield Your Powers
- **Chat Tab**:
  - See all platform chats in real-time.
  - Send messages or commands (e.g., `!ping` for “Pong!”).
- **Commands Tab**:
  - Click “Add Command” to create new ones (e.g., `!roll` for “Rolled a 15!”).
  - Upload a CSV (`command,response`) to add multiple commands.
  - Edit or delete as needed.
- **Settings Tab**:
  - Manage logins, Twitch channels, and services (start/stop/restart).
- **Commands to Try**:
  - `!checkin`: Marks your presence in the tavern.
  - `!ping`: Tests the bot’s reflexes.
  - `!roll`: Rolls a die (e.g., `!roll d20`).
  - Add your own in the Commands tab!

## The Playbook: Tips for Glory
- **Engage Your Guild**:
  - Use `!roll` for D&D flair (add via Commands tab).
  - Broadcast messages to all platforms from the Chat tab.
- **Troubleshooting**:
  - **Login Issues?** Ensure you’re signed into the right account. Check the video if stuck.
  - **Whatnot Not Working?** Verify selectors in the extension popup.
  - **App Won’t Run?** Confirm Python 3.13 and re-run `pip install -r requirements.txt`.
- **Need a Bard?** Post on our Patreon for help!

## Epic Loot (Future Quests)
- Add more commands like `!quest` for community challenges.
- Share feedback on Patreon to shape FoSBot’s saga!

**Roll a natural 20 and stream on!**

*Created by [Your Name] for the MTG & D&D crew. No OAuth setup needed—log in and play!*
EOF

# Create app/ files
cat > app/__init__.py << 'EOF'
# --- File: app/__init__.py --- START ---
# This file makes 'app' a Python package
# --- File: app/__init__.py --- END ---
EOF

cat > app/main.py << 'EOF'
# --- File: app/main.py --- START ---
import asyncio
import logging
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
from pathlib import Path

# Core Imports
from app.core.config import logger
from app.core.event_bus import event_bus

# API Routers
from app.apis import ws_endpoints, settings_api, auth_api, commands_api

# Service Control & Setup
from app.services.twitch_service import start_twitch_service_task, stop_twitch_service
from app.services.youtube_service import start_youtube_service_task, stop_youtube_service
from app.services.x_service import start_x_service_task, stop_x_service
from app.services.whatnot_bridge import start_whatnot_bridge_task, stop_whatnot_bridge
from app.services.chat_processor import setup_chat_processor
from app.services.dashboard_service import setup_dashboard_service_listeners
from app.services.streamer_command_handler import setup_streamer_command_handler

# Events
from app.events import ServiceControl

# Global State
background_tasks = set()
_service_tasks_map: dict[str, asyncio.Task | None] = {}

# Service Control Mapping
service_control_map = {
    "twitch": {"start": start_twitch_service_task, "stop": stop_twitch_service},
    "youtube": {"start": start_youtube_service_task, "stop": stop_youtube_service},
    "x": {"start": start_x_service_task, "stop": stop_x_service},
    "whatnot": {"start": start_whatnot_bridge_task, "stop": stop_whatnot_bridge},
}

async def handle_service_control(event: ServiceControl):
    """Handles start/stop/restart commands for services via the event bus."""
    logger.info(f"Handling control: '{event.command}' for '{event.service_name}'...")
    control_funcs = service_control_map.get(event.service_name)
    current_task = _service_tasks_map.get(event.service_name)

    if not control_funcs:
        logger.error(f"No control functions found for service '{event.service_name}'.")
        return

    start_func = control_funcs.get("start")
    stop_func = control_funcs.get("stop")

    if event.command == "stop":
        if current_task and not current_task.done():
            logger.info(f"Stopping running/starting service '{event.service_name}'...")
            if stop_func:
                await stop_func()
            else:
                logger.warning(f"No stop function defined but task exists for '{event.service_name}'. Cancelling directly.")
                if not current_task.cancelled():
                    current_task.cancel()
        else:
            logger.info(f"Service '{event.service_name}' not running, no stop action needed.")
        _service_tasks_map[event.service_name] = None

    elif event.command == "start":
        if current_task and not current_task.done():
            logger.warning(f"Service '{event.service_name}' already running or starting.")
            return

        if start_func:
            logger.info(f"Executing start for '{event.service_name}'...")
            new_task = start_func()
            if new_task and isinstance(new_task, asyncio.Task):
                _service_tasks_map[event.service_name] = new_task
                background_tasks.add(new_task)
                new_task.add_done_callback(background_tasks.discard)
                logger.info(f"Task for '{event.service_name}' started and added to background tasks.")
            elif new_task is None:
                logger.warning(f"Start function for '{event.service_name}' did not return a task (disabled/failed pre-check?).")
            else:
                logger.error(f"Start function for '{event.service_name}' returned invalid object: {type(new_task)}")
        else:
            logger.warning(f"No start function defined for '{event.service_name}'.")

    elif event.command == "restart":
        logger.info(f"Executing restart for '{event.service_name}'...")
        if current_task and not current_task.done():
            logger.info("...stopping existing service first.")
            if stop_func:
                await stop_func()
                await asyncio.sleep(1)
            else:
                logger.warning(f"No stop function for restart of '{event.service_name}'. Cancelling directly.")
                if not current_task.cancelled():
                    current_task.cancel()
                await asyncio.sleep(0.1)
        else:
            logger.info("...service not running, attempting start.")

        _service_tasks_map[event.service_name] = None

        if start_func:
            logger.info("...starting new service instance.")
            new_task = start_func()
            if new_task and isinstance(new_task, asyncio.Task):
                _service_tasks_map[event.service_name] = new_task
                background_tasks.add(new_task)
                new_task.add_done_callback(background_tasks.discard)
                logger.info(f"Task for '{event.service_name}' added after restart.")
            elif new_task is None:
                logger.warning(f"Start function for '{event.service_name}' did not return task on restart.")
            else:
                logger.error(f"Start function '{event.service_name}' returned invalid object on restart: {type(new_task)}")
        else:
            logger.warning(f"No start function available for restart of '{event.service_name}'.")

# Lifespan Manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handles application startup and shutdown events."""
    logger.info("--- Application startup sequence initiated ---")
    logger.info("Starting event bus worker..."); await event_bus.start()
    logger.info("Setting up event listeners...");
    setup_chat_processor()
    setup_dashboard_service_listeners()
    setup_streamer_command_handler()
    event_bus.subscribe(ServiceControl, handle_service_control)
    logger.info("Service control handler subscribed.")
    logger.info("Services will start automatically IF valid OAuth tokens are found.")
    initial_start_tasks = [
        handle_service_control(ServiceControl(service_name="whatnot", command="start")),
        handle_service_control(ServiceControl(service_name="youtube", command="start")),
        handle_service_control(ServiceControl(service_name="twitch", command="start")),
        handle_service_control(ServiceControl(service_name="x", command="start"))
    ]
    await asyncio.gather(*initial_start_tasks, return_exceptions=True)
    logger.info("--- Application startup complete. Running! ---")

    yield

    logger.info("--- Application shutdown sequence initiated ---")
    logger.info("Stopping platform services (sending stop commands)...")
    stop_tasks = [
        handle_service_control(ServiceControl(service_name=name, command="stop"))
        for name in service_control_map.keys()
    ]
    await asyncio.gather(*stop_tasks, return_exceptions=True)

    logger.info("Waiting briefly..."); await asyncio.sleep(2)
    logger.info("Stopping event bus worker..."); await event_bus.stop()

    if background_tasks:
        logger.warning(f"Attempting final cancellation for {len(background_tasks)} lingering background tasks...")
        for task in list(background_tasks):
            if task and not task.done():
                task.cancel()
        try:
            await asyncio.wait_for(asyncio.gather(*background_tasks, return_exceptions=True), timeout=5.0)
            logger.debug("Gathered cancelled background tasks successfully.")
        except asyncio.TimeoutError:
            logger.error("Timeout waiting for background tasks to cancel.")
        except Exception as e:
            logger.exception(f"Error during final gathering of cancelled tasks: {e}")
    else:
        logger.info("No lingering background tasks found during shutdown.")
    logger.info("--- Application shutdown complete. ---")

# FastAPI App Creation
app = FastAPI(
    title="FoSBot (Whatnot + YouTube + Twitch + X)",
    version="0.7.0-auto-oauth",
    lifespan=lifespan
)

# Mount Routers
app.include_router(auth_api.router)
app.include_router(ws_endpoints.router, prefix="/ws")
app.include_router(settings_api.router, prefix="/api", tags=["Settings & Control"])
app.include_router(commands_api.router, prefix="/api", tags=["Commands"])

# Mount Static Files
STATIC_DIR = "static"
static_path = Path(STATIC_DIR)
if not static_path.is_dir():
    logger.error(f"Static files directory '{STATIC_DIR}' not found at {static_path.resolve()}. Dashboard UI unavailable.")
else:
    try:
        app.mount("/", StaticFiles(directory=STATIC_DIR, html=True), name="static")
        logger.info(f"Mounted static files for dashboard UI from './{STATIC_DIR}'.")
    except Exception as e:
        logger.exception(f"Failed to mount static files directory './{STATIC_DIR}': {e}")

# Direct Run (Debugging Only)
if __name__ == "__main__":
    import uvicorn
    from app.core.config import WS_HOST, WS_PORT, LOG_LEVEL
    logger.warning("Running via main.py is intended for debugging ONLY. Use 'uvicorn app.main:app --reload'.")
    uvicorn.run("app.main:app", host=WS_HOST, port=WS_PORT, log_level=LOG_LEVEL.lower(), reload=True)
# --- File: app/main.py --- END ---
EOF

# Create app/core/ files
cat > app/core/__init__.py << 'EOF'
# --- File: app/core/__init__.py --- START ---
# Makes 'core' a package
# --- File: app/core/__init__.py --- END ---
EOF

cat > app/core/config.py << 'EOF'
# --- File: app/core/config.py --- START ---
import os
from dotenv import load_dotenv
from pathlib import Path
import logging
import warnings

# Determine project root
project_root = Path(__file__).parent.parent.parent
env_path = project_root / '.env'

# Load .env file
loaded_env = load_dotenv(dotenv_path=env_path, verbose=True)
if loaded_env:
    print(f"Loaded .env config from: {env_path}")
else:
    print(f"INFO: .env file not found at {env_path}. Using defaults/env vars.")

# General App Settings
COMMAND_PREFIX = os.getenv("COMMAND_PREFIX", "!")
WS_HOST = os.getenv("WS_HOST", "localhost")
WS_PORT = int(os.getenv("WS_PORT", "8000"))
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
DATA_DIR = Path(os.getenv("DATA_DIR", project_root / "data"))

# OAuth Application Credentials
TWITCH_APP_CLIENT_ID = os.getenv("TWITCH_APP_CLIENT_ID")
TWITCH_APP_CLIENT_SECRET = os.getenv("TWITCH_APP_CLIENT_SECRET")
YOUTUBE_APP_CLIENT_ID = os.getenv("YOUTUBE_APP_CLIENT_ID")
YOUTUBE_APP_CLIENT_SECRET = os.getenv("YOUTUBE_APP_CLIENT_SECRET")
X_APP_CLIENT_ID = os.getenv("X_APP_CLIENT_ID")
X_APP_CLIENT_SECRET = os.getenv("X_APP_CLIENT_SECRET")

# Security Keys
APP_SECRET_KEY = os.getenv("APP_SECRET_KEY")

# Logging Setup
log_level_int = getattr(logging, LOG_LEVEL, logging.INFO)
logging.basicConfig(
    level=log_level_int,
    format='%(asctime)s - %(name)s [%(levelname)s] - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logging.getLogger("twitchio").setLevel(logging.WARNING)
logging.getLogger("websockets").setLevel(logging.WARNING)
logging.getLogger("google").setLevel(logging.WARNING)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("watchfiles").setLevel(logging.WARNING)

logger = logging.getLogger(__name__)
logger.setLevel(log_level_int)

logger.info(f"Config Loaded: Prefix='{COMMAND_PREFIX}', WS={WS_HOST}:{WS_PORT}, LogLevel={LOG_LEVEL}, DataDir='{DATA_DIR}'")

# Configuration Validation
if not APP_SECRET_KEY:
    warnings.warn("CRITICAL SECURITY WARNING: APP_SECRET_KEY is not set in .env or environment variables. OAuth state validation will be insecure. Please generate a strong key.", RuntimeWarning)
    APP_SECRET_KEY = "insecure_default_key_replace_me"

if not TWITCH_APP_CLIENT_ID:
    logger.warning("Twitch OAuth configuration missing: TWITCH_APP_CLIENT_ID not set.")
if not TWITCH_APP_CLIENT_SECRET:
    logger.warning("Twitch OAuth configuration missing: TWITCH_APP_CLIENT_SECRET not set.")
if not YOUTUBE_APP_CLIENT_ID:
    logger.warning("YouTube OAuth configuration missing: YOUTUBE_APP_CLIENT_ID not set.")
if not YOUTUBE_APP_CLIENT_SECRET:
    logger.warning("YouTube OAuth configuration missing: YOUTUBE_APP_CLIENT_SECRET not set.")
if not X_APP_CLIENT_ID:
    logger.warning("X OAuth configuration missing: X_APP_CLIENT_ID not set.")
if not X_APP_CLIENT_SECRET:
    logger.warning("X OAuth configuration missing: X_APP_CLIENT_SECRET not set.")

# Ensure data directory exists
try:
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    logger.info(f"Data directory verified/created: {DATA_DIR.resolve()}")
except OSError as e:
    logger.error(f"CRITICAL: Could not create/access data directory '{DATA_DIR}': {e}")
# --- File: app/core/config.py --- END ---
EOF

cat > app/core/event_bus.py << 'EOF'
# --- File: app/core/event_bus.py --- START ---
import asyncio
import logging
from collections import defaultdict
from typing import Type, Callable, Dict, List, TypeVar, Coroutine, Any
try:
    from app.events import Event
except ImportError:
    class Event: pass
    print("WARN: Could not import app.events, using placeholder Event for type hints.")

logger = logging.getLogger(__name__)
T = TypeVar('T', bound=Event)

class AsyncEventBus:
    """A simple asynchronous publish/subscribe event bus."""
    def __init__(self):
        self._listeners: Dict[Type[Event], List[Callable[[T], Coroutine[Any, Any, None]]]] = defaultdict(list)
        self._queue: asyncio.Queue = asyncio.Queue(maxsize=1000)
        self._worker_task: asyncio.Task | None = None
        self._running = False

    def subscribe(self, event_type: Type[T], handler: Callable[[T], Coroutine[Any, Any, None]]):
        """Subscribe an async handler to an event type."""
        if not asyncio.iscoroutinefunction(handler):
            raise TypeError(f"Handler {getattr(handler,'__name__', repr(handler))} must be an async function")
        if handler not in self._listeners[event_type]:
            self._listeners[event_type].append(handler)
            logger.debug(f"Handler '{getattr(handler, '__name__', repr(handler))}' subscribed to {event_type.__name__}")
        else:
            logger.warning(f"Handler '{getattr(handler, '__name__', repr(handler))}' already subscribed to {event_type.__name__}. Ignoring.")

    def publish(self, event: Event):
        """Publish an event to the queue for async processing."""
        if not self._running:
            logger.warning(f"Event bus not running, discarding event: {type(event).__name__}")
            return
        try:
            self._queue.put_nowait(event)
            logger.debug(f"Event {type(event).__name__} published (qsize: {self._queue.qsize()}).")
        except asyncio.QueueFull:
            logger.error(f"Event bus queue FULL! Discarding event: {type(event).__name__}. Check handler performance.")

    async def _process_events(self):
        """Worker coroutine that processes events from the queue."""
        logger.info("Event bus processor task started.")
        while self._running:
            try:
                event = await self._queue.get()
                if event is None:
                    logger.debug("Received None sentinel, continuing shutdown check.")
                    if not self._running:
                        break
                    continue

                event_type = type(event)
                logger.debug(f"Processing event {event_type.__name__} from queue (qsize: {self._queue.qsize()}).")

                handlers_to_call = []
                for registered_type, handlers in self._listeners.items():
                    if isinstance(event, registered_type):
                        handlers_to_call.extend(handlers)

                if not handlers_to_call:
                    logger.debug(f"No listeners found for event type {event_type.__name__}")
                    self._queue.task_done()
                    continue

                tasks = [
                    asyncio.create_task(
                        handler(event),
                        name=f"event_handler_{getattr(handler, '__name__', f'unknown_{id(handler)}')}_{event_type.__name__}"
                    )
                    for handler in handlers_to_call
                ]
                results = await asyncio.gather(*tasks, return_exceptions=True)

                for i, result in enumerate(results):
                    if isinstance(result, Exception):
                        handler_name = getattr(handlers_to_call[i], '__name__', repr(handlers_to_call[i]))
                        log_traceback = logger.isEnabledFor(logging.DEBUG)
                        logger.error(f"Exception in handler '{handler_name}' for event {event_type.__name__}: {result}", exc_info=log_traceback)

                self._queue.task_done()

            except asyncio.CancelledError:
                logger.info("Event bus processing task cancelled.")
                break
            except Exception as e:
                logger.exception(f"Unexpected error in event processing loop: {e}")
                await asyncio.sleep(1)

        logger.info("Event bus processor task stopped.")

    async def start(self):
        """Start the background event processing worker."""
        if self._running:
            logger.warning("Event bus already running.")
            return
        self._running = True
        self._worker_task = asyncio.create_task(self._process_events(), name="EventBusProcessor")
        logger.info("Event bus started.")

    async def stop(self):
        """Stop the background event processing worker gracefully."""
        if not self._running or not self._worker_task or self._worker_task.done():
            logger.info("Event bus already stopped or not started.")
            return

        logger.info("Stopping event bus worker...")
        self._running = False
        try:
            self._queue.put_nowait(None)
        except asyncio.QueueFull:
            logger.warning("Event queue full during shutdown.")

        if self._worker_task and not self._worker_task.done():
            if not self._worker_task.cancelling():
                self._worker_task.cancel()
            try:
                await self._worker_task
            except asyncio.CancelledError:
                logger.info("Event bus worker stop confirmed (was cancelled).")
            except Exception as e:
                logger.exception(f"Error during event bus worker shutdown wait: {e}")
        self._worker_task = None

# Global instance
event_bus = AsyncEventBus()
# --- File: app/core/event_bus.py --- END ---
EOF

cat > app/core/json_store.py << 'EOF'
# --- File: app/core/json_store.py --- START ---
import json
import logging
import aiofiles
import asyncio
from pathlib import Path
from typing import Dict, Any, Optional, Union
from collections import defaultdict
import time

from app.core.config import DATA_DIR

logger = logging.getLogger(__name__)

_file_locks: Dict[Path, asyncio.Lock] = defaultdict(asyncio.Lock)

async def load_json_data(filename: str, default: Any = None) -> Optional[Any]:
    """Loads data asynchronously from a JSON file in the data directory."""
    filepath = DATA_DIR / f"{filename}.json"
    lock = _file_locks[filepath]
    async with lock:
        try:
            if not filepath.is_file():
                if filename in [SETTINGS_FILE, COMMANDS_FILE]:
                    logger.warning(f"File not found: {filepath}. Creating empty file.")
                    await save_json_data(filename, {})
                    return {}
                logger.warning(f"JSON file not found: {filepath}. Returning default.")
                return default

            async with aiofiles.open(filepath, mode='r', encoding='utf-8') as f:
                content = await f.read()
            if not content:
                logger.warning(f"JSON file is empty: {filepath}. Returning default.")
                return {} if filename in [SETTINGS_FILE, COMMANDS_FILE] else default
            data = json.loads(content)
            return data
        except json.JSONDecodeError:
            logger.error(f"Error decoding JSON from file: {filepath}. Returning default.", exc_info=True)
            return {} if filename in [SETTINGS_FILE, COMMANDS_FILE] else default
        except Exception as e:
            logger.error(f"Unexpected error loading JSON file {filepath}: {e}", exc_info=True)
            return {} if filename in [SETTINGS_FILE, COMMANDS_FILE] else default

async def save_json_data(filename: str, data: Any) -> bool:
    """Saves data asynchronously to a JSON file in the data directory."""
    filepath = DATA_DIR / f"{filename}.json"
    lock = _file_locks[filepath]
    task_id_part = id(asyncio.current_task()) if asyncio.current_task() else 'notask'
    temp_filepath = filepath.with_suffix(f'.{task_id_part}.tmp')

    async with lock:
        try:
            async with aiofiles.open(temp_filepath, mode='w', encoding='utf-8') as f:
                await f.write(json.dumps(data, indent=4, ensure_ascii=False))
            temp_filepath.rename(filepath)
            logger.info(f"Successfully saved data to {filepath}")
            return True
        except Exception as e:
            logger.error(f"Error saving JSON file {filepath}: {e}", exc_info=True)
            if temp_filepath.exists():
                try:
                    temp_filepath.unlink()
                    logger.debug(f"Removed temporary file {temp_filepath} after error.")
                except OSError as unlink_e:
                    logger.error(f"Error removing temporary file {temp_filepath}: {unlink_e}")
            return False

# Specific Settings and Data File Management
SETTINGS_FILE = "settings"
CHECKINS_FILE = "checkins"
COUNTERS_FILE = "counters"
COMMANDS_FILE = "commands"

async def save_tokens(platform: str, token_data: Dict[str, Any]) -> bool:
    """Saves OAuth token data for a specific platform into settings.json."""
    logger.info(f"Attempting to save tokens for platform: {platform}")
    settings = await load_settings()
    if settings is None:
        settings = {}

    updated_keys = []
    if 'access_token' not in token_data:
        logger.error(f"Missing 'access_token' in token_data for {platform}. Cannot save.")
        return False

    settings[f"{platform}_access_token"] = token_data['access_token']
    updated_keys.append(f"{platform}_access_token")
    if 'refresh_token' in token_data:
        settings[f"{platform}_refresh_token"] = token_data['refresh_token']
        updated_keys.append(f"{platform}_refresh_token")
    if 'expires_in' in token_data:
        try:
            expires_at = time.time() + int(token_data['expires_in']) - 300
            settings[f"{platform}_expires_at"] = expires_at
            updated_keys.append(f"{platform}_expires_at")
        except (ValueError, TypeError) as e:
            logger.error(f"Invalid expires_in value for {platform}: {token_data['expires_in']} - {e}")
    if 'scope' in token_data:
        scopes = token_data['scope']
        if isinstance(scopes, str):
            scopes = scopes.split()
        settings[f"{platform}_scopes"] = list(scopes) if scopes else []
        updated_keys.append(f"{platform}_scopes")

    if 'user_id' in token_data:
        settings[f"{platform}_user_id"] = str(token_data['user_id'])
        updated_keys.append(f"{platform}_user_id")
    if 'user_login' in token_data:
        settings[f"{platform}_user_login"] = token_data['user_login']
        updated_keys.append(f"{platform}_user_login")

    logger.warning(f"Saving OAuth tokens ({', '.join(updated_keys)}) for {platform} to plain JSON file.")
    saved = await save_settings(settings)

    if saved and updated_keys:
        from app.events import SettingsUpdated
        from app.core.event_bus import event_bus
        event_bus.publish(SettingsUpdated(keys_updated=updated_keys))

    return saved

async def load_tokens(platform: str) -> Optional[Dict[str, Any]]:
    """Loads OAuth token data for a specific platform from settings.json."""
    settings = await load_settings()
    if not settings:
        return None

    token_info = {
        "access_token": settings.get(f"{platform}_access_token"),
        "refresh_token": settings.get(f"{platform}_refresh_token"),
        "expires_at": settings.get(f"{platform}_expires_at"),
        "scopes": settings.get(f"{platform}_scopes", []),
        "user_id": settings.get(f"{platform}_user_id"),
        "user_login": settings.get(f"{platform}_user_login"),
    }

    if token_info["access_token"]:
        if token_info["expires_at"] is not None:
            try:
                token_info["expires_at"] = float(token_info["expires_at"])
            except (ValueError, TypeError):
                token_info["expires_at"] = None
        return token_info
    return None

async def clear_tokens(platform: str) -> bool:
    """Removes OAuth token data for a specific platform from settings.json."""
    logger.info(f"Clearing tokens for platform: {platform}")
    settings = await load_settings()
    if settings is None:
        return True

    keys_to_remove = [
        f"{platform}_access_token", f"{platform}_refresh_token",
        f"{platform}_expires_at", f"{platform}_scopes",
        f"{platform}_user_id", f"{platform}_user_login",
        f"{platform.upper()}_TOKEN", f"{platform.upper()}_NICK", f"{platform.upper()}_CLIENT_ID", f"{platform.upper()}_CHANNELS"
    ]
    updated_keys = []
    changed = False
    for key in keys_to_remove:
        if key in settings:
            del settings[key]
            updated_keys.append(key)
            changed = True

    if changed:
        saved = await save_settings(settings)
        if saved and updated_keys:
            from app.events import SettingsUpdated
            from app.core.event_bus import event_bus
            event_bus.publish(SettingsUpdated(keys_updated=updated_keys))
        return saved
    return True

async def load_settings() -> Dict[str, Any]:
    """Loads the main application settings."""
    settings = await load_json_data(SETTINGS_FILE, default={})
    return settings if isinstance(settings, dict) else {}

async def save_settings(settings_data: Dict[str, Any]) -> bool:
    """Saves the main application settings."""
    return await save_json_data(SETTINGS_FILE, settings_data)

async def get_setting(key: str, default: Any = None) -> Any:
    """Convenience function to get a single non-token setting."""
    settings = await load_settings()
    return settings.get(key, default)

async def update_setting(key: str, value: Any) -> bool:
    """Updates a single non-token setting."""
    settings = await load_settings()
    if settings is None:
        settings = {}
    if settings.get(key) != value:
        settings[key] = value
        saved = await save_settings(settings)
        if saved:
            from app.events import SettingsUpdated
            from app.core.event_bus import event_bus
            event_bus.publish(SettingsUpdated(keys_updated=[key]))
        return saved
    return True

async def load_checkins() -> Dict[str, Any]:
    """Loads check-in data."""
    return await load_json_data(CHECKINS_FILE, default={})

async def save_checkins(data: Dict[str, Any]) -> bool:
    """Saves check-in data."""
    return await save_json_data(CHECKINS_FILE, data)

async def load_counters() -> Dict[str, int]:
    """Loads counter data."""
    return await load_json_data(COUNTERS_FILE, default={})

async def save_counters(data: Dict[str, int]) -> bool:
    """Saves counter data."""
    return await save_json_data(COUNTERS_FILE, data)

async def load_commands() -> Dict[str, str]:
    """Loads custom commands."""
    return await load_json_data(COMMANDS_FILE, default={})

async def save_commands(data: Dict[str, str]) -> bool:
    """Saves custom commands."""
    return await save_json_data(COMMANDS_FILE, data)
# --- File: app/core/json_store.py --- END ---
EOF

cat > app/events.py << 'EOF'
# --- File: app/events.py --- START ---
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List
import datetime

@dataclass
class InternalChatMessage:
    platform: str
    channel: str
    user: str
    text: str
    timestamp: str

@dataclass
class BotResponse:
    platform: str
    channel: str
    text: str

class Event: pass

@dataclass
class ChatMessageReceived(Event):
    message: InternalChatMessage

@dataclass
class CommandDetected(Event):
    command: str
    args: list[str]
    source_message: InternalChatMessage

@dataclass
class BotResponseToSend(Event):
    response: BotResponse

@dataclass
class StreamerInputReceived(Event):
    text: str

@dataclass
class BroadcastStreamerMessage(Event):
    text: str

@dataclass
class PlatformStatusUpdate(Event):
    platform: str
    status: str
    message: Optional[str] = None

@dataclass
class LogMessage(Event):
    level: str
    message: str
    module: Optional[str] = None

@dataclass
class SettingsUpdated(Event):
    keys_updated: List[str]

@dataclass
class ServiceControl(Event):
    service_name: str
    command: str

@dataclass
class GameEvent(Event):
    pass
# --- File: app/events.py --- END ---
EOF

# Create app/apis/ files
cat > app/apis/__init__.py << 'EOF'
# --- File: app/apis/__init__.py --- START ---
# Makes 'apis' a Python package
# --- File: app/apis/__init__.py --- END ---
EOF

cat > app/apis/auth_api.py << 'EOF'
# --- File: app/apis/auth_api.py --- START ---
import logging
import secrets
from urllib.parse import urlencode
from typing import Dict, Optional, Any
from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import RedirectResponse
import httpx
import tweepy

# Configuration
from app.core.config import (
    TWITCH_APP_CLIENT_ID, TWITCH_APP_CLIENT_SECRET,
    YOUTUBE_APP_CLIENT_ID, YOUTUBE_APP_CLIENT_SECRET,
    X_APP_CLIENT_ID, X_APP_CLIENT_SECRET, APP_SECRET_KEY
)

# Token Storage
from app.core.json_store import save_tokens, clear_tokens, load_tokens

# Event Bus
from app.core.event_bus import event_bus
from app.events import PlatformStatusUpdate, ServiceControl

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth", tags=["Authentication"])

# Constants
TWITCH_REDIRECT_URI = "http://localhost:8000/auth/twitch/callback"
TWITCH_AUTHORIZATION_BASE_URL = "https://id.twitch.tv/oauth2/authorize"
TWITCH_TOKEN_URL = "https://id.twitch.tv/oauth2/token"
TWITCH_VALIDATE_URL = "https://id.twitch.tv/oauth2/validate"
TWITCH_REVOKE_URL = "https://id.twitch.tv/oauth2/revoke"
TWITCH_SCOPES = ["chat:read", "chat:edit", "channel:read:subscriptions"]

YOUTUBE_REDIRECT_URI = "http://localhost:8000/auth/youtube/callback"
YOUTUBE_AUTHORIZATION_BASE_URL = "https://accounts.google.com/o/oauth2/v2/auth"
YOUTUBE_TOKEN_URL = "https://oauth2.googleapis.com/token"
YOUTUBE_REVOKE_URL = "https://oauth2.googleapis.com/revoke"
YOUTUBE_SCOPES = [
    "https://www.googleapis.com/auth/youtube.readonly",
    "https://www.googleapis.com/auth/youtube.force-ssl"
]

X_REDIRECT_URI = "http://localhost:8000/auth/x/callback"
X_AUTHORIZATION_BASE_URL = "https://api.twitter.com/oauth/authorize"
X_REQUEST_TOKEN_URL = "https://api.twitter.com/oauth/request_token"
X_ACCESS_TOKEN_URL = "https://api.twitter.com/oauth/access_token"
X_SCOPES = ["tweet.read", "tweet.write", "users.read"]

# State Management
_oauth_state_store: dict[str, str] = {}
_x_request_tokens: dict[str, dict] = {}

# Helper Functions
def generate_state() -> str:
    """Generates a secure random state token for OAuth."""
    state = secrets.token_urlsafe(32)
    return state

def verify_state(received_state: str, platform: str) -> bool:
    """Verifies the OAuth state token."""
    stored_state = _oauth_state_store.get(platform)
    if not stored_state or stored_state != received_state:
        logger.error(f"Invalid OAuth state for {platform}. Expected: {stored_state}, Received: {received_state}")
        return False
    del _oauth_state_store[platform]
    return True

async def get_twitch_user_info(access_token: str) -> Optional[Dict[str, Any]]:
    """Fetches Twitch user info using the access token."""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                "https://api.twitch.tv/helix/users",
                headers={"Authorization": f"Bearer {access_token}", "Client-Id": TWITCH_APP_CLIENT_ID}
            )
            response.raise_for_status()
            data = response.json()
            return data["data"][0] if data["data"] else None
        except Exception as e:
            logger.error(f"Error fetching Twitch user info: {e}")
            return None

async def get_youtube_user_info(access_token: str) -> Optional[Dict[str, Any]]:
    """Fetches YouTube user info using the access token."""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                "https://www.googleapis.com/youtube/v3/channels",
                params={"part": "snippet", "mine": "true"},
                headers={"Authorization": f"Bearer {access_token}"}
            )
            response.raise_for_status()
            data = response.json()
            return data["items"][0] if data["items"] else None
        except Exception as e:
            logger.error(f"Error fetching YouTube user info: {e}")
            return None

async def get_x_user_info(client: tweepy.Client) -> Optional[Dict[str, Any]]:
    """Fetches X user info using the Tweepy client."""
    try:
        user = client.get_me(user_fields=["id", "username"])
        return {
            "id": user.data.id,
            "username": user.data.username
        }
    except Exception as e:
        logger.error(f"Error fetching X user info: {e}")
        return None

# Twitch Auth Endpoints
@router.get("/twitch/login")
async def twitch_login():
    if not TWITCH_APP_CLIENT_ID or not TWITCH_APP_CLIENT_SECRET:
        raise HTTPException(status_code=500, detail="Twitch OAuth configuration missing")
    state = generate_state()
    _oauth_state_store["twitch"] = state
    params = {
        "client_id": TWITCH_APP_CLIENT_ID,
        "redirect_uri": TWITCH_REDIRECT_URI,
        "response_type": "code",
        "scope": " ".join(TWITCH_SCOPES),
        "state": state
    }
    auth_url = f"{TWITCH_AUTHORIZATION_BASE_URL}?{urlencode(params)}"
    logger.info("Redirecting to Twitch OAuth authorization")
    return RedirectResponse(auth_url)

@router.get("/twitch/callback")
async def twitch_callback(
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    scope: Optional[str] = Query(None),
    error: Optional[str] = Query(None),
    error_description: Optional[str] = Query(None)
):
    if error:
        logger.error(f"Twitch OAuth error: {error} - {error_description}")
        error_message = f"{error}: {error_description or 'Unknown error'}"
        return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
    if not code or not state:
        error_message = "Missing code or state parameters"
        return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
    if not verify_state(state, "twitch"):
        error_message = "Invalid state parameter"
        return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
    
    async with httpx.AsyncClient() as client:
        try:
            # Exchange code for tokens
            token_response = await client.post(
                TWITCH_TOKEN_URL,
                data={
                    "client_id": TWITCH_APP_CLIENT_ID,
                    "client_secret": TWITCH_APP_CLIENT_SECRET,
                    "code": code,
                    "grant_type": "authorization_code",
                    "redirect_uri": TWITCH_REDIRECT_URI
                }
            )
            token_response.raise_for_status()
            token_data = token_response.json()
            
            # Validate token
            validate_response = await client.get(
                TWITCH_VALIDATE_URL,
                headers={"Authorization": f"OAuth {token_data['access_token']}"}
            )
            validate_response.raise_for_status()
            
            # Fetch user info
            user_info = await get_twitch_user_info(token_data["access_token"])
            if not user_info:
                raise HTTPException(status_code=500, detail="Failed to fetch Twitch user info")
            
            # Save tokens and user info
            await save_tokens("twitch", {
                "access_token": token_data["access_token"],
                "refresh_token": token_data.get("refresh_token"),
                "expires_in": token_data["expires_in"],
                "scope": token_data["scope"].split(),
                "user_id": user_info["id"],
                "user_login": user_info["login"]
            })
            
            logger.info(f"Twitch OAuth successful for user: {user_info['login']}")
            return RedirectResponse("/?auth_success=twitch")
        except httpx.HTTPStatusError as e:
            logger.error(f"Twitch OAuth token exchange failed: {e.response.status_code} - {e.response.text}")
            error_message = f"Token exchange failed: {e.response.status_code}"
            return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
        except Exception as e:
            logger.error(f"Unexpected error in Twitch OAuth callback: {e}")
            error_message = f"Unexpected error: {str(e)}"
            return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")

@router.post("/twitch/logout", status_code=200)
async def twitch_logout():
    tokens = await load_tokens("twitch")
    if tokens and tokens.get("access_token"):
        async with httpx.AsyncClient() as client:
            try:
                await client.post(
                    TWITCH_REVOKE_URL,
                    data={"client_id": TWITCH_APP_CLIENT_ID, "token": tokens["access_token"]}
                )
                logger.info("Twitch token revoked successfully")
            except Exception as e:
                logger.error(f"Error revoking Twitch token: {e}")
    await clear_tokens("twitch")
    event_bus.publish(ServiceControl(service_name="twitch", command="restart"))
    return {"message": "Twitch logged out successfully"}

# YouTube Auth Endpoints
@router.get("/youtube/login")
async def youtube_login():
    if not YOUTUBE_APP_CLIENT_ID or not YOUTUBE_APP_CLIENT_SECRET:
        raise HTTPException(status_code=500, detail="YouTube OAuth configuration missing")
    state = generate_state()
    _oauth_state_store["youtube"] = state
    params = {
        "client_id": YOUTUBE_APP_CLIENT_ID,
        "redirect_uri": YOUTUBE_REDIRECT_URI,
        "response_type": "code",
        "scope": " ".join(YOUTUBE_SCOPES),
        "state": state,
        "access_type": "offline",
        "prompt": "consent"
    }
    auth_url = f"{YOUTUBE_AUTHORIZATION_BASE_URL}?{urlencode(params)}"
    logger.info("Redirecting to YouTube OAuth authorization")
    return RedirectResponse(auth_url)

@router.get("/youtube/callback")
async def youtube_callback(
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    scope: Optional[str] = Query(None),
    error: Optional[str] = Query(None)
):
    if error:
        logger.error(f"YouTube OAuth error: {error}")
        error_message = f"{error}"
        return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
    if not code or not state:
        error_message = "Missing code or state parameters"
        return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
    if not verify_state(state, "youtube"):
        error_message = "Invalid state parameter"
        return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
    
    async with httpx.AsyncClient() as client:
        try:
            # Exchange code for tokens
            token_response = await client.post(
                YOUTUBE_TOKEN_URL,
                data={
                    "client_id": YOUTUBE_APP_CLIENT_ID,
                    "client_secret": YOUTUBE_APP_CLIENT_SECRET,
                    "code": code,
                    "grant_type": "authorization_code",
                    "redirect_uri": YOUTUBE_REDIRECT_URI
                }
            )
            token_response.raise_for_status()
            token_data = token_response.json()
            
            # Fetch user info
            user_info = await get_youtube_user_info(token_data["access_token"])
            if not user_info:
                raise HTTPException(status_code=500, detail="Failed to fetch YouTube user info")
            
            # Save tokens and user info
            await save_tokens("youtube", {
                "access_token": token_data["access_token"],
                "refresh_token": token_data.get("refresh_token"),
                "expires_in": token_data["expires_in"],
                "scope": token_data["scope"].split(),
                "user_id": user_info["id"],
                "user_login": user_info["snippet"]["title"]
            })
            
            logger.info(f"YouTube OAuth successful for user: {user_info['snippet']['title']}")
            return RedirectResponse("/?auth_success=youtube")
        except httpx.HTTPStatusError as e:
            logger.error(f"YouTube OAuth token exchange failed: {e.response.status_code} - {e.response.text}")
            error_message = f"Token exchange failed: {e.response.status_code}"
            return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
        except Exception as e:
            logger.error(f"Unexpected error in YouTube OAuth callback: {e}")
            error_message = f"Unexpected error: {str(e)}"
            return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")

@router.post("/youtube/logout", status_code=200)
async def youtube_logout():
    tokens = await load_tokens("youtube")
    if tokens and tokens.get("access_token"):
        async with httpx.AsyncClient() as client:
            try:
                await client.post(
                    YOUTUBE_REVOKE_URL,
                    data={"token": tokens["access_token"]}
                )
                logger.info("YouTube token revoked successfully")
            except Exception as e:
                logger.error(f"Error revoking YouTube token: {e}")
    await clear_tokens("youtube")
    event_bus.publish(ServiceControl(service_name="youtube", command="restart"))
    return {"message": "YouTube logged out successfully"}

# X Auth Endpoints
@router.get("/x/login")
async def x_login():
    if not X_APP_CLIENT_ID or not X_APP_CLIENT_SECRET:
        raise HTTPException(status_code=500, detail="X OAuth configuration missing")
    state = generate_state()
    _oauth_state_store["x"] = state
    try:
        auth = tweepy.OAuth1UserHandler(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            callback=X_REDIRECT_URI
        )
        auth_url = auth.get_authorization_url()
        _x_request_tokens[state] = {
            "request_token": auth.request_token["oauth_token"],
            "request_token_secret": auth.request_token["oauth_token_secret"]
        }
        params = {"state": state}
        auth_url_with_state = f"{auth_url}&{urlencode(params)}"
        logger.info("Redirecting to X OAuth authorization")
        return RedirectResponse(auth_url_with_state)
    except Exception as e:
        logger.error(f"Error initiating X OAuth: {e}")
        error_message = f"OAuth initiation failed: {str(e)}"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")

@router.get("/x/callback")
async def x_callback(
    oauth_token: Optional[str] = Query(None),
    oauth_verifier: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    denied: Optional[str] = Query(None)
):
    if denied:
        logger.error(f"X OAuth denied by user")
        error_message = "User denied access"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")
    if not oauth_token or not oauth_verifier or not state:
        error_message = "Missing OAuth parameters"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")
    if not verify_state(state, "x"):
        error_message = "Invalid state parameter"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")

    request_tokens = _x_request_tokens.get(state)
    if not request_tokens:
        logger.error("No stored request tokens for X OAuth state")
        error_message = "Invalid OAuth session"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")

    try:
        auth = tweepy.OAuth1UserHandler(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            access_token=request_tokens["request_token"],
            access_token_secret=request_tokens["request_token_secret"]
        )
        access_token, access_token_secret = auth.get_access_token(oauth_verifier)
        
        client = tweepy.Client(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            access_token=access_token,
            access_token_secret=access_token_secret
        )
        user_info = await get_x_user_info(client)
        if not user_info:
            raise HTTPException(status_code=500, detail="Failed to fetch X user info")

        await save_tokens("x", {
            "access_token": access_token,
            "access_token_secret": access_token_secret,
            "user_id": user_info["id"],
            "user_login": user_info["username"],
            "scope": X_SCOPES,
            "expires_in": 7200  # X tokens don't expire, use 2 hours as default
        })

        del _x_request_tokens[state]
        logger.info(f"X OAuth successful for user: {user_info['username']}")
        return RedirectResponse("/?auth_success=x")
    except Exception as e:
        logger.error(f"Unexpected error in X OAuth callback: {e}")
        error_message = f"Unexpected error: {str(e)}"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")

@router.post("/x/logout", status_code=200)
async def x_logout():
    tokens = await load_tokens("x")
    if tokens and tokens.get("access_token"):
        # No revoke endpoint for X, just clear locally
        logger.info("X tokens cleared locally (no revoke endpoint)")
    await clear_tokens("x")
    event_bus.publish(ServiceControl(service_name="x", command="restart"))
    return {"message": "X logged out successfully"}
# --- File: app/apis/auth_api.py --- END ---
EOF

cat > app/apis/settings_api.py << 'EOF'
# --- File: app/apis/settings_api.py --- START ---
import logging
from fastapi import APIRouter, HTTPException, Body, status
from pydantic import BaseModel, Field
from typing import Dict, Any, List, Optional

from app.core.json_store import load_settings, update_setting, load_tokens
from app.core.event_bus import event_bus
from app.events import SettingsUpdated, ServiceControl, PlatformStatusUpdate

logger = logging.getLogger(__name__)
router = APIRouter()

# Pydantic Models
class AppSettingsModel(BaseModel):
    COMMAND_PREFIX: Optional[str] = Field(None, min_length=1, max_length=5)
    LOG_LEVEL: Optional[str] = Field(None, pattern=r"^(DEBUG|INFO|WARNING|ERROR|CRITICAL)$")
    TWITCH_CHANNELS: Optional[str] = None

class NonAuthSettingsModel(AppSettingsModel):
    pass

@router.get("/settings", response_model=Dict[str, Any], summary="Get Current Non-Token Settings")
async def get_current_settings():
    logger.debug("GET /api/settings request received")
    all_settings = await load_settings()
    non_token_settings = {
        k: v for k, v in all_settings.items()
        if not any(s in k.lower() for s in ['token', 'secret', 'expires_at', 'scopes', 'app_'])
    }

    platforms = ["twitch", "youtube", "x"]
    for p in platforms:
        tokens = await load_tokens(p)
        non_token_settings[f"{p}_auth_status"] = {
            "logged_in": bool(tokens and tokens.get("access_token")),
            "user_login": tokens.get("user_login") if tokens else None
        }

    logger.debug(f"Returning non-token settings & auth status: {non_token_settings}")
    return non_token_settings

@router.post("/settings", status_code=status.HTTP_200_OK, summary="Update Non-Token Settings")
async def update_settings_endpoint(new_settings: NonAuthSettingsModel = Body(...)):
    logger.info(f"POST /api/settings request received for non-auth settings.")
    update_data = new_settings.dict(exclude_unset=True)
    if not update_data:
        logger.warning("Update settings request received with no data.")
        return {"message": "No settings provided for update."}

    logger.info(f"Attempting to update non-auth keys: {list(update_data.keys())}")
    saved_keys = []
    failed_keys = []

    for key, value in update_data.items():
        try:
            if await update_setting(key, value):
                saved_keys.append(key)
            else:
                failed_keys.append(key)
        except Exception as e:
            logger.exception(f"Error updating setting '{key}': {e}")
            failed_keys.append(key)

    if failed_keys:
        raise HTTPException(status_code=500, detail=f"Failed to save settings for keys: {failed_keys}")
    if not saved_keys:
        return {"message": "No settings were changed."}
    return {"message": f"Settings updated successfully ({', '.join(saved_keys)})."}

@router.post("/control/{service_name}/{command}", status_code=status.HTTP_202_ACCEPTED, summary="Control Services")
async def control_service(service_name: str, command: str):
    allowed_services = ["twitch", "youtube", "x", "whatnot"]
    allowed_commands = ["start", "stop", "restart"]
    service_name = service_name.lower()
    command = command.lower()

    if service_name not in allowed_services:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Service '{service_name}' not recognized.")
    if command not in allowed_commands:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid command '{command}'. Allowed: {allowed_commands}")

    logger.info(f"Control command '{command}' for service '{service_name}' received via API.")
    event_bus.publish(ServiceControl(service_name=service_name, command=command))
    return {"message": f"'{command}' command queued for '{service_name}' service."}
# --- File: app/apis/settings_api.py --- END ---
EOF

cat > app/apis/ws_endpoints.py << 'EOF'
# --- File: app/apis/ws_endpoints.py --- START ---
import logging
import json
import asyncio
from fastapi import APIRouter, WebSocket, WebSocketDisconnect

from app.services.dashboard_service import handle_dashboard_websocket
from app.services.whatnot_bridge import set_whatnot_websocket, clear_whatnot_websocket
from app.core.event_bus import event_bus
from app.events import InternalChatMessage, ChatMessageReceived

logger = logging.getLogger(__name__)
router = APIRouter()

@router.websocket("/dashboard")
async def websocket_dashboard_endpoint(websocket: WebSocket):
    await handle_dashboard_websocket(websocket)

@router.websocket("/whatnot")
async def websocket_whatnot_endpoint(websocket: WebSocket):
    await websocket.accept()
    set_whatnot_websocket(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            logger.debug(f"Received from Whatnot extension: {data}")
            try:
                message_data = json.loads(data)
                msg_type = message_data.get("type")
                if msg_type == "chat_message":
                    payload = message_data.get("payload", {})
                    internal_msg = InternalChatMessage(
                        platform="whatnot",
                        channel=payload.get("channel", "whatnot"),
                        user=payload.get("user", "unknown"),
                        text=payload.get("text", ""),
                        timestamp=payload.get("timestamp", datetime.datetime.utcnow().isoformat())
                    )
                    event_bus.publish(ChatMessageReceived(message=internal_msg))
                elif msg_type == "ping":
                    await websocket.send_json({"type": "pong"})
                else:
                    logger.warning(f"Unknown Whatnot message type: {msg_type}")
            except json.JSONDecodeError:
                logger.error(f"Invalid JSON from Whatnot extension: {data}")
            except Exception as e:
                logger.error(f"Error processing Whatnot message: {e}")
    except WebSocketDisconnect:
        logger.info("Whatnot WebSocket disconnected.")
        clear_whatnot_websocket()
    except Exception as e:
        logger.error(f"Unexpected error in Whatnot WebSocket: {e}")
        clear_whatnot_websocket()
# --- File: app/apis/ws_endpoints.py --- END ---
EOF

cat > app/apis/commands_api.py << 'EOF'
# --- File: app/apis/commands_api.py --- START ---
import logging
import csv
import io
from fastapi import APIRouter, HTTPException, UploadFile, File
from pydantic import BaseModel
from typing import Dict, List

from app.core.json_store import load_commands, save_commands

logger = logging.getLogger(__name__)
router = APIRouter(tags=["Commands"])

class CommandModel(BaseModel):
    command: str
    response: str

@router.get("/commands", response_model=Dict[str, str])
async def get_commands():
    """Fetches all custom commands."""
    return await load_commands()

@router.post("/commands", status_code=201)
async def add_command(command: CommandModel):
    """Adds or updates a custom command."""
    commands = await load_commands()
    commands[command.command] = command.response
    if await save_commands(commands):
        return {"message": f"Command '!{command.command}' added/updated"}
    raise HTTPException(status_code=500, detail="Failed to save command")

@router.delete("/commands/{command}", status_code=200)
async def delete_command(command: str):
    """Deletes a custom command."""
    commands = await load_commands()
    if command in commands:
        del commands[command]
        if await save_commands(commands):
            return {"message": f"Command '!{command}' deleted"}
        raise HTTPException(status_code=500, detail="Failed to delete command")
    raise HTTPException(status_code=404, detail="Command not found")

@router.post("/commands/upload", status_code=201)
async def upload_commands(file: UploadFile = File(...)):
    """Uploads commands from a CSV file."""
    if not file.filename.endswith('.csv'):
        raise HTTPException(status_code=400, detail="File must be a CSV")
    
    commands = await load_commands()
    try:
        content = await file.read()
        csv_file = io.StringIO(content.decode('utf-8'))
        reader = csv.reader(csv_file)
        next(reader, None)  # Skip header if present
        updated = 0
        for row in reader:
            if len(row) >= 2:
                command, response = row[0].strip(), row[1].strip()
                if command:
                    commands[command] = response
                    updated += 1
        if updated > 0:
            if await save_commands(commands):
                return {"message": f"Uploaded/updated {updated} commands"}
            raise HTTPException(status_code=500, detail="Failed to save commands")
        return {"message": "No valid commands found in CSV"}
    except Exception as e:
        logger.error(f"Error processing CSV: {e}")
        raise HTTPException(status_code=500, detail="Error processing CSV")
# --- File: app/apis/commands_api.py --- END ---
EOF

# Create app/services/ files
cat > app/services/__init__.py << 'EOF'
# --- File: app/services/__init__.py --- START ---
# Makes 'services' a package
# --- File: app/services/__init__.py --- END ---
EOF

cat > app/services/twitch_service.py << 'EOF'
# --- File: app/services/twitch_service.py --- START ---
import logging
import asyncio
import time
from twitchio.ext import commands
from twitchio import Client, Chatter, Channel, errors as twitchio_errors
import httpx
from collections import defaultdict
import datetime

# Core imports
from app.core.json_store import load_tokens, save_tokens, load_settings
from app.core.config import TWITCH_APP_CLIENT_ID, TWITCH_APP_CLIENT_SECRET
from app.core.event_bus import event_bus
from app.events import (
    InternalChatMessage,
    ChatMessageReceived,
    BotResponseToSend,
    BotResponse,
    PlatformStatusUpdate,
    SettingsUpdated,
    ServiceControl,
    LogMessage,
)

logger = logging.getLogger(__name__)

_STATE = {"task": None, "instance": None, "running": False, "connected": False, "settings": {}}
_run_task: asyncio.Task | None = None

# Twitch OAuth constants
TWITCH_TOKEN_URL = "https://id.twitch.tv/oauth2/token"

class TwitchBot(commands.Bot):
    """Custom Twitch Bot class extending twitchio."""
    def __init__(self, token, nick, client_id, channels):
        self.initial_channels_list = [ch.strip().lower() for ch in channels if ch.strip()]
        if not self.initial_channels_list:
            logger.warning("TwitchBot initialized with no channels.")
        if token and not token.startswith('oauth:'):
            token = f'oauth:{token}'

        super().__init__(
            token=token,
            client_id=client_id,
            nick=nick.lower(),
            prefix=None,
            initial_channels=self.initial_channels_list
        )
        self._closing = False
        self._response_queue = asyncio.Queue(maxsize=100)
        self._sender_task: asyncio.Task | None = None
        logger.debug(f"TwitchBot instance created for nick '{self.nick}'.")

    async def event_ready(self):
        """Called when the bot has successfully connected to Twitch."""
        logger.info(f"Twitch bot connected as '{self.nick}'.")
        _STATE["connected"] = True
        event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connected'))
        self._sender_task = asyncio.create_task(self._message_sender(), name="TwitchMessageSender")

    async def event_message(self, message):
        """Handles incoming chat messages."""
        if message.echo:
            return
        logger.debug(f"Received message from {message.author.name}: {message.content}")
        internal_msg = InternalChatMessage(
            platform="twitch",
            channel=message.channel.name,
            user=message.author.name,
            text=message.content,
            timestamp=datetime.datetime.utcnow().isoformat()
        )
        event_bus.publish(ChatMessageReceived(message=internal_msg))
        await self.handle_commands(message)

    async def event_join(self, channel: Channel, user: Chatter):
        logger.debug(f"User {user.name} joined channel {channel.name}")

    async def event_part(self, channel: Channel, user: Chatter):
        logger.debug(f"User {user.name} parted channel {channel.name}")

    async def event_error(self, error: Exception, data: str = None):
        logger.error(f"Twitch bot error: {error} (Data: {data})", exc_info=True)
        event_bus.publish(PlatformStatusUpdate(
            platform='twitch',
            status='error',
            message=f"Bot error: {type(error).__name__}"
        ))

    async def event_close(self):
        logger.warning("Twitch bot WebSocket closed.")
        _STATE["connected"] = False
        event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnected'))

    def queue_response(self, event: BotResponseToSend):
        """Queues a response to be sent to a Twitch channel."""
        try:
            self._response_queue.put_nowait(event)
            logger.debug(f"Queued response to {event.response.channel}: {event.response.text}")
        except asyncio.QueueFull:
            logger.error(f"Twitch response queue full! Dropping message to {event.response.channel}: {event.response.text}")

    async def _message_sender(self):
        """Sends queued messages to Twitch channels."""
        while not self._closing:
            try:
                event = await self._response_queue.get()
                response = event.response
                try:
                    channel = self.get_channel(response.channel.lower())
                    if channel:
                        await channel.send(response.text)
                        logger.debug(f"Sent message to {response.channel}: {response.text}")
                    else:
                        logger.error(f"Cannot send to {response.channel}: Channel not joined.")
                except Exception as e:
                    logger.error(f"Error sending message to {response.channel}: {e}", exc_info=True)
                self._response_queue.task_done()
            except asyncio.CancelledError:
                logger.info("Twitch message sender cancelled.")
                break
            except Exception as e:
                logger.error(f"Unexpected error in message sender: {e}", exc_info=True)
                await asyncio.sleep(1)

    async def custom_shutdown(self):
        """Gracefully shuts down the bot."""
        self._closing = True
        logger.info("Initiating Twitch bot shutdown...")
        if self._sender_task and not self._sender_task.done():
            self._sender_task.cancel()
            try:
                await self._sender_task
            except asyncio.CancelledError:
                pass
        try:
            await self.close()
        except Exception as e:
            logger.error(f"Error during Twitch bot close: {e}")
        logger.info("Twitch bot shutdown complete.")

async def refresh_twitch_token(refresh_token: str) -> dict | None:
    """Refreshes the Twitch OAuth token using the refresh token."""
    logger.info("Attempting to refresh Twitch OAuth token...")
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                TWITCH_TOKEN_URL,
                data={
                    "grant_type": "refresh_token",
                    "refresh_token": refresh_token,
                    "client_id": TWITCH_APP_CLIENT_ID,
                    "client_secret": TWITCH_APP_CLIENT_SECRET
                }
            )
            response.raise_for_status()
            token_data = response.json()
            logger.info("Twitch token refreshed successfully.")
            return {
                "access_token": token_data.get("access_token"),
                "refresh_token": token_data.get("refresh_token"),
                "expires_in": token_data.get("expires_in"),
                "scope": token_data.get("scope", "").split()
            }
        except httpx.HTTPStatusError as e:
            logger.error(f"Token refresh failed: HTTP {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error during token refresh: {e}", exc_info=True)
            return None

async def run_twitch_service():
    """Main runner for the Twitch service using OAuth tokens."""
    global _STATE, _run_task
    logger.info("Twitch service runner started.")
    while True:
        if _run_task and _run_task.cancelled():
            logger.info("Twitch run loop cancelled.")
            break

        # Load OAuth tokens
        logger.debug("Loading Twitch OAuth tokens...")
        token_data = await load_tokens("twitch")
        settings_data = await load_settings()
        _STATE["settings"] = settings_data

        # Get channels from settings (fallback to user_login)
        TWITCH_CHANNELS_RAW = settings_data.get("TWITCH_CHANNELS", "")
        TWITCH_CHANNELS = [ch.strip().lower() for ch in TWITCH_CHANNELS_RAW.split(',') if ch.strip()]
        if not TWITCH_CHANNELS and token_data and token_data.get("user_login"):
            TWITCH_CHANNELS = [token_data["user_login"].lower()]
            logger.info(f"No TWITCH_CHANNELS specified, defaulting to user channel: {TWITCH_CHANNELS}")

        # Validate token and required data
        if (
            not token_data
            or not token_data.get("access_token")
            or not token_data.get("user_login")
            or not TWITCH_APP_CLIENT_ID
            or not TWITCH_CHANNELS
        ):
            missing = []
            if not token_data or not token_data.get("access_token"):
                missing.append("access_token")
            if not token_data or not token_data.get("user_login"):
                missing.append("user_login")
            if not TWITCH_APP_CLIENT_ID:
                missing.append("TWITCH_APP_CLIENT_ID")
            if not TWITCH_CHANNELS:
                missing.append("channels")
            logger.warning(f"Twitch service disabled. Missing: {', '.join(missing)}. Waiting for settings update...")
            event_bus.publish(PlatformStatusUpdate(
                platform='twitch',
                status='disabled',
                message=f"Missing: {', '.join(missing)}"
            ))
            await wait_for_settings_update({
                "twitch_access_token",
                "twitch_user_login",
                "TWITCH_CHANNELS"
            })
            continue

        # Check token expiry and attempt refresh if needed
        expires_at = token_data.get("expires_at")
        if expires_at and expires_at < time.time() +300:  # 5-minute buffer
            logger.info("Twitch access token expired or expiring soon. Attempting refresh...")
            refresh_data = await refresh_twitch_token(token_data.get("refresh_token"))
            if refresh_data:
                await save_tokens("twitch", refresh_data)
                token_data = await load_tokens("twitch")  # Reload updated tokens
                logger.info("Token refreshed and saved successfully.")
            else:
                logger.error("Token refresh failed. Waiting for manual re-authentication...")
                event_bus.publish(PlatformStatusUpdate(
                    platform='twitch',
                    status='auth_error',
                    message="Token refresh failed"
                ))
                await wait_for_settings_update({"twitch_access_token"})
                continue

        _STATE["running"] = True
        attempt = 0
        MAX_ATTEMPTS = 5
        bot_instance = None
        while _STATE.get("running") and attempt < MAX_ATTEMPTS:
            attempt += 1
            try:
                logger.info(f"Starting Twitch bot (Attempt {attempt}/{MAX_ATTEMPTS})...")
                event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connecting'))
                bot_instance = TwitchBot(
                    token=token_data["access_token"],
                    nick=token_data["user_login"],
                    client_id=TWITCH_APP_CLIENT_ID,
                    channels=TWITCH_CHANNELS
                )
                _STATE["instance"] = bot_instance
                await bot_instance.start()
                logger.warning("Twitch bot start() returned (connection closed/lost).")
            except asyncio.CancelledError:
                logger.info("Twitch run attempt cancelled.")
                _STATE["running"] = False
                break
            except twitchio_errors.AuthenticationError as e:
                logger.error(f"Twitch authentication failed: {e}")
                event_bus.publish(PlatformStatusUpdate(
                    platform='twitch',
                    status='auth_error',
                    message="Authentication failed"
                ))
                _STATE["running"] = False
                await wait_for_settings_update({"twitch_access_token"})
                break
            except Exception as e:
                logger.error(f"Twitch connection failed (Attempt {attempt}): {e}", exc_info=True)
                event_bus.publish(PlatformStatusUpdate(
                    platform='twitch',
                    status='error',
                    message=f"Connect failed: {type(e).__name__}"
                ))
            finally:
                if bot_instance:
                    await bot_instance.custom_shutdown()
                    _STATE["instance"] = None
                    bot_instance = None

            if not _STATE.get("running"):
                break
            if attempt >= MAX_ATTEMPTS:
                logger.error("Max Twitch connection attempts reached. Waiting for settings update...")
                event_bus.publish(PlatformStatusUpdate(
                    platform='twitch',
                    status='error',
                    message='Max connection attempts reached'
                ))
                await wait_for_settings_update({
                    "twitch_access_token",
                    "twitch_user_login",
                    "TWITCH_CHANNELS"
                })
                break

            wait_time = min(attempt * 10, 60)
            logger.info(f"Waiting {wait_time}s before Twitch retry...")
            try:
                await asyncio.sleep(wait_time)
            except asyncio.CancelledError:
                logger.info("Twitch retry sleep cancelled.")
                _STATE["running"] = False
                break

        if not _STATE.get("running"):
            logger.info("Twitch service run loop exiting.")
            break

async def wait_for_settings_update(relevant_keys: set):
    """Waits for a SettingsUpdated event affecting relevant keys."""
    logger.info(f"Waiting for settings update affecting: {relevant_keys}...")
    future = asyncio.get_running_loop().create_future()
    async def settings_listener(event: SettingsUpdated):
        if any(key in relevant_keys for key in event.keys_updated):
            logger.info("Relevant settings updated, resuming service loop.")
            if not future.done():
                future.set_result(True)
    event_bus.subscribe(SettingsUpdated, settings_listener)
    try:
        await future
    except asyncio.CancelledError:
        logger.info("Wait for settings update cancelled.")

async def stop_twitch_service():
    """Stops the Twitch service gracefully."""
    global _STATE, _run_task
    logger.info("Stop requested for Twitch service.")
    _STATE["running"] = False
    bot_instance = _STATE.get("instance")
    if bot_instance:
        await bot_instance.custom_shutdown()
        _STATE["instance"] = None
    if _run_task and not _run_task.done():
        logger.info("Cancelling Twitch run task...")
        _run_task.cancel()
        try:
            await _run_task
        except asyncio.CancelledError:
            logger.info("Twitch run task cancellation confirmed.")
    _run_task = None
    _STATE["task"] = None
    _STATE["connected"] = False
    logger.info("Twitch service stopped.")
    event_bus.publish(PlatformStatusUpdate(platform='twitch', status='stopped'))

async def handle_settings_update(event: SettingsUpdated):
    """Handles settings updates that affect Twitch service."""
    relevant_keys = {
        "twitch_access_token",
        "twitch_refresh_token",
        "twitch_expires_at",
        "twitch_scopes",
        "twitch_user_id",
        "twitch_user_login",
        "TWITCH_CHANNELS"
    }
    if any(key in relevant_keys for key in event.keys_updated):
        logger.info("Twitch-relevant settings updated, requesting service restart...")
        event_bus.publish(ServiceControl(service_name="twitch", command="restart"))

def start_twitch_service_task() -> asyncio.Task | None:
    """Creates and returns a task for running the Twitch service."""
    global _STATE, _run_task
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("Twitch service task already running.")
        return _STATE["task"]
    logger.info("Creating background task for Twitch service.")
    _run_task = asyncio.create_task(run_twitch_service(), name="TwitchServiceRunner")
    _STATE["task"] = _run_task
    event_bus.subscribe(SettingsUpdated, handle_settings_update)
    return _run_task
# --- File: app/services/twitch_service.py --- END ---
EOF

cat > app/services/youtube_service.py << 'EOF'
# --- File: app/services/youtube_service.py --- START ---
import logging
import asyncio
import time
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import httpx
from datetime import datetime

from app.core.event_bus import event_bus
from app.events import (
    PlatformStatusUpdate,
    SettingsUpdated,
    ServiceControl,
    BotResponseToSend,
    InternalChatMessage,
    ChatMessageReceived
)
from app.core.json_store import load_tokens, save_tokens
from app.core.config import YOUTUBE_APP_CLIENT_ID, YOUTUBE_APP_CLIENT_SECRET

logger = logging.getLogger(__name__)
_STATE = {"task": None, "running": False, "connected": False}
_last_message_id: str | None = None
_run_task: asyncio.Task | None = None

YOUTUBE_TOKEN_URL = "https://oauth2.googleapis.com/token"

async def refresh_youtube_token(refresh_token: str) -> dict | None:
    """Refreshes the YouTube OAuth token using the refresh token."""
    logger.info("Attempting to refresh YouTube OAuth token...")
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                YOUTUBE_TOKEN_URL,
                data={
                    "grant_type": "refresh_token",
                    "refresh_token": refresh_token,
                    "client_id": YOUTUBE_APP_CLIENT_ID,
                    "client_secret": YOUTUBE_APP_CLIENT_SECRET
                }
            )
            response.raise_for_status()
            token_data = response.json()
            logger.info("YouTube token refreshed successfully.")
            return {
                "access_token": token_data.get("access_token"),
                "refresh_token": token_data.get("refresh_token", refresh_token),
                "expires_in": token_data.get("expires_in"),
                "scope": token_data.get("scope", "").split()
            }
        except httpx.HTTPStatusError as e:
            logger.error(f"YouTube token refresh failed: HTTP {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error during YouTube token refresh: {e}", exc_info=True)
            return None

async def handle_youtube_response(event: BotResponseToSend):
    """Handles bot responses destined for YouTube live chat."""
    if event.response.platform != "youtube":
        return
    tokens = await load_tokens("youtube")
    if not tokens or not tokens.get("access_token"):
        logger.error("Cannot send YouTube response: No valid tokens")
        return
    
    credentials = Credentials(
        token=tokens["access_token"],
        refresh_token=tokens.get("refresh_token"),
        token_uri="https://oauth2.googleapis.com/token",
        client_id=YOUTUBE_APP_CLIENT_ID,
        client_secret=YOUTUBE_APP_CLIENT_SECRET
    )
    
    try:
        youtube = build("youtube", "v3", credentials=credentials)
        live_chat_id = await get_live_chat_id(youtube, tokens["user_id"])
        if not live_chat_id:
            logger.error("No active live chat found for sending response")
            return
        
        youtube.liveChatMessages().insert(
            part="snippet",
            body={
                "snippet": {
                    "liveChatId": live_chat_id,
                    "type": "textMessageEvent",
                    "textMessageDetails": {"messageText": event.response.text}
                }
            }
        ).execute()
        logger.debug(f"Sent YouTube live chat message: {event.response.text}")
    except HttpError as e:
        logger.error(f"Error sending YouTube live chat message: {e}")
        event_bus.publish(PlatformStatusUpdate(
            platform='youtube',
            status='error',
            message=f"Send failed: {e.reason}"
        ))
    except Exception as e:
        logger.error(f"Unexpected error sending YouTube message: {e}")

async def get_live_chat_id(youtube, channel_id: str) -> str | None:
    """Fetches the active live chat ID for the user's live broadcast."""
    try:
        broadcasts = youtube.liveBroadcasts().list(
            part="id,snippet",
            broadcastStatus="active",
            broadcastType="all"
        ).execute()
        for item in broadcasts.get("items", []):
            if item["snippet"]["channelId"] == channel_id:
                return item["snippet"].get("liveChatId")
        logger.warning("No active YouTube live broadcast found")
        return None
    except HttpError as e:
        logger.error(f"Error fetching YouTube live chat ID: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error fetching live chat ID: {e}")
        return None

async def poll_youtube_chat(youtube, live_chat_id: str):
    """Polls the YouTube live chat for new messages."""
    global _last_message_id
    next_page_token = None
    while _STATE["running"]:
        try:
            request = youtube.liveChatMessages().list(
                liveChatId=live_chat_id,
                part="id,snippet,authorDetails",
                pageToken=next_page_token,
                maxResults=200
            )
            response = request.execute()
            
            for item in response.get("items", []):
                message_id = item["id"]
                if message_id == _last_message_id:
                    continue
                _last_message_id = message_id
                
                snippet = item["snippet"]
                author = item["authorDetails"]
                message_text = snippet.get("textMessageDetails", {}).get("messageText", "")
                
                internal_msg = InternalChatMessage(
                    platform="youtube",
                    channel=author.get("channelId", "unknown"),
                    user=author.get("displayName", "unknown"),
                    text=message_text,
                    timestamp=snippet.get("publishedAt", datetime.utcnow().isoformat())
                )
                event_bus.publish(ChatMessageReceived(message=internal_msg))
            
            next_page_token = response.get("nextPageToken")
            polling_interval = response.get("pollingIntervalMillis", 5000) / 1000.0
            await asyncio.sleep(min(polling_interval, 10))
        
        except HttpError as e:
            if e.resp.status in [403, 404]:
                logger.warning("YouTube live chat unavailable or forbidden")
                event_bus.publish(PlatformStatusUpdate(
                    platform='youtube',
                    status='disconnected',
                    message="Live chat unavailable"
                ))
                return
            logger.error(f"Error polling YouTube live chat: {e}")
            event_bus.publish(PlatformStatusUpdate(
                platform='youtube',
                status='error',
                message=f"Poll failed: {e.reason}"
            ))
            await asyncio.sleep(10)
        except Exception as e:
            logger.error(f"Unexpected error polling YouTube chat: {e}")
            await asyncio.sleep(10)

async def run_youtube_service():
    """Main runner for YouTube live chat integration."""
    global _STATE, _run_task
    logger.info("YouTube service runner started.")
    _STATE["running"] = True
    
    while _STATE["running"]:
        tokens = await load_tokens("youtube")
        if not tokens or not tokens.get("access_token") or not tokens.get("user_id"):
            logger.warning("YouTube service disabled: Missing tokens or user info")
            event_bus.publish(PlatformStatusUpdate(
                platform='youtube',
                status='disabled',
                message="Missing authentication tokens or user info"
            ))
            await wait_for_settings_update({"youtube_access_token", "youtube_user_id"})
            continue
        
        # Check token expiry
        expires_at = tokens.get("expires_at")
        if expires_at and expires_at < time.time() + 300:
            logger.info("YouTube token expired or expiring soon. Attempting refresh...")
            refresh_data = await refresh_youtube_token(tokens.get("refresh_token"))
            if refresh_data:
                await save_tokens("youtube", refresh_data)
                tokens = await load_tokens("youtube")
                logger.info("YouTube token refreshed and saved")
            else:
                logger.error("YouTube token refresh failed")
                event_bus.publish(PlatformStatusUpdate(
                    platform='youtube',
                    status='auth_error',
                    message="Token refresh failed"
                ))
                await wait_for_settings_update({"youtube_access_token"})
                continue
        
        credentials = Credentials(
            token=tokens["access_token"],
            refresh_token=tokens.get("refresh_token"),
            token_uri="https://oauth2.googleapis.com/token",
            client_id=YOUTUBE_APP_CLIENT_ID,
            client_secret=YOUTUBE_APP_CLIENT_SECRET
        )
        
        try:
            youtube = build("youtube", "v3", credentials=credentials)
            live_chat_id = await get_live_chat_id(youtube, tokens["user_id"])
            if not live_chat_id:
                logger.warning("No active YouTube live chat found")
                event_bus.publish(PlatformStatusUpdate(
                    platform='youtube',
                    status='disconnected',
                    message="No active live stream"
                ))
                await asyncio.sleep(30)
                continue
            
            logger.info(f"Connected to YouTube live chat ID: {live_chat_id}")
            _STATE["connected"] = True
            event_bus.publish(PlatformStatusUpdate(platform='youtube', status='connected'))
            
            await poll_youtube_chat(youtube, live_chat_id)
        
        except Exception as e:
            logger.error(f"YouTube service error: {e}")
            event_bus.publish(PlatformStatusUpdate(
                platform='youtube',
                status='error',
                message=f"Service error: {type(e).__name__}"
            ))
            await asyncio.sleep(10)
    
    logger.info("YouTube service run loop exiting")
    _STATE["running"] = False
    _STATE["connected"] = False

async def wait_for_settings_update(relevant_keys: set):
    """Waits for a SettingsUpdated event affecting relevant keys."""
    logger.info(f"Waiting for YouTube settings update: {relevant_keys}")
    future = asyncio.get_running_loop().create_future()
    async def settings_listener(event: SettingsUpdated):
        if any(key in relevant_keys for key in event.keys_updated):
            logger.info("YouTube settings updated, resuming service")
            if not future.done():
                future.set_result(True)
    event_bus.subscribe(SettingsUpdated, settings_listener)
    try:
        await future
    except asyncio.CancelledError:
        logger.info("YouTube settings wait cancelled")

async def stop_youtube_service():
    """Stops the YouTube service gracefully."""
    global _STATE, _run_task
    logger.info("Stopping YouTube service...")
    _STATE["running"] = False
    _STATE["connected"] = False
    if _run_task and not _run_task.done():
        _run_task.cancel()
        try:
            await _run_task
        except asyncio.CancelledError:
            logger.info("YouTube run task cancelled")
    _run_task = None
    _STATE["task"] = None
    event_bus.publish(PlatformStatusUpdate(platform='youtube', status='stopped'))
    logger.info("YouTube service stopped")

def start_youtube_service_task() -> asyncio.Task | None:
    """Creates a task for running the YouTube service."""
    global _STATE, _run_task
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("YouTube service already running")
        return _STATE["task"]
    logger.info("Starting YouTube service task")
    _run_task = asyncio.create_task(run_youtube_service(), name="YouTubeServiceRunner")
    _STATE["task"] = _run_task
    event_bus.subscribe(BotResponseToSend, handle_youtube_response)
    return _run_task
# --- File: app/services/youtube_service.py --- END ---
EOF

cat > app/services/x_service.py << 'EOF'
# --- File: app/services/x_service.py --- START ---
import logging
import asyncio
import time
import tweepy
from app.core.event_bus import event_bus
from app.events import (
    PlatformStatusUpdate,
    SettingsUpdated,
    ServiceControl,
    BotResponseToSend,
    InternalChatMessage,
    ChatMessageReceived
)
from app.core.json_store import load_tokens
from app.core.config import X_APP_CLIENT_ID, X_APP_CLIENT_SECRET

logger = logging.getLogger(__name__)
_STATE = {"task": None, "running": False, "connected": False}
_run_task: asyncio.Task | None = None

async def handle_x_response(event: BotResponseToSend):
    """Handles bot responses destined for X."""
    if event.response.platform != "x":
        return
    tokens = await load_tokens("x")
    if not tokens or not tokens.get("access_token"):
        logger.error("Cannot send X response: No valid tokens")
        return
    
    try:
        client = tweepy.Client(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            access_token=tokens["access_token"],
            access_token_secret=tokens.get("access_token_secret")
        )
        client.create_tweet(text=event.response.text)
        logger.debug(f"Sent X tweet: {event.response.text}")
    except Exception as e:
        logger.error(f"Error sending X tweet: {e}")
        event_bus.publish(PlatformStatusUpdate(
            platform='x',
            status='error',
            message=f"Send failed: {str(e)}"
        ))

async def run_x_service():
    """Main runner for X service."""
    global _STATE, _run_task
    logger.info("X service runner started.")
    _STATE["running"] = True
    
    while _STATE["running"]:
        tokens = await load_tokens("x")
        if not tokens or not tokens.get("access_token"):
            logger.warning("X service disabled: Missing tokens")
            event_bus.publish(PlatformStatusUpdate(
                platform='x',
                status='disabled',
                message="Missing authentication tokens"
            ))
            await wait_for_settings_update({"x_access_token"})
            continue
        
        try:
            client = tweepy.Client(
                consumer_key=X_APP_CLIENT_ID,
                consumer_secret=X_APP_CLIENT_SECRET,
                access_token=tokens["access_token"],
                access_token_secret=tokens.get("access_token_secret")
            )
            user_info = client.get_me()
            logger.info(f"Connected to X as {user_info.data.username}")
            _STATE["connected"] = True
            event_bus.publish(PlatformStatusUpdate(platform='x', status='connected'))
            
            # Simulate chat by monitoring mentions
            last_mention_id = None
            while _STATE["running"]:
                try:
                    mentions = client.get_users_mentions(
                        id=user_info.data.id,
                        since_id=last_mention_id,
                        tweet_fields=["created_at"]
                    )
                    if mentions.data:
                        for tweet in mentions.data:
                            last_mention_id = max(last_mention_id or "0", str(tweet.id))
                            internal_msg = InternalChatMessage(
                                platform="x",
                                channel=user_info.data.username,
                                user=str(tweet.author_id),
                                text=tweet.text,
                                timestamp=tweet.created_at.isoformat()
                            )
                            event_bus.publish(ChatMessageReceived(message=internal_msg))
                    
                    await asyncio.sleep(30)
                
                except Exception as e:
                    logger.error(f"Error polling X mentions: {e}")
                    event_bus.publish(PlatformStatusUpdate(
                        platform='x',
                        status='error',
                        message=f"Poll failed: {str(e)}"
                    ))
                    await asyncio.sleep(60)
        
        except Exception as e:
            logger.error(f"X service error: {e}")
            event_bus.publish(PlatformStatusUpdate(
                platform='x',
                status='error',
                message=f"Service error: {str(e)}"
            ))
            await asyncio.sleep(60)
    
    logger.info("X service run loop exiting")
    _STATE["running"] = False
    _STATE["connected"] = False

async def wait_for_settings_update(relevant_keys: set):
    """Waits for a SettingsUpdated event."""
    logger.info(f"Waiting for X settings update: {relevant_keys}")
    future = asyncio.get_running_loop().create_future()
    async def settings_listener(event: SettingsUpdated):
        if any(key in relevant_keys for key in event.keys_updated):
            logger.info("X settings updated, resuming service")
            if not future.done():
                future.set_result(True)
    event_bus.subscribe(SettingsUpdated, settings_listener)
    try:
        await future
    except asyncio.CancelledError:
        logger.info("X settings wait cancelled")

async def stop_x_service():
    """Stops the X service gracefully."""
    global _STATE, _run_task
    logger.info("Stopping X service...")
    _STATE["running"] = False
    _STATE["connected"] = False
    if _run_task and not _run_task.done():
        _run_task.cancel()
        try:
            await _run_task
        except asyncio.CancelledError:
            logger.info("X run task cancelled")
    _run_task = None
    _STATE["task"] = None
    event_bus.publish(PlatformStatusUpdate(platform='x', status='stopped'))
    logger.info("X service stopped")

def start_x_service_task() -> asyncio.Task | None:
    """Creates a task for running the X service."""
    global _STATE, _run_task
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("X service already running")
        return _STATE["task"]
    logger.info("Starting X service task")
    _run_task = asyncio.create_task(run_x_service(), name="XServiceRunner")
    _STATE["task"] = _run_task
    event_bus.subscribe(BotResponseToSend, handle_x_response)
    return _run_task
# --- File: app/services/x_service.py --- END ---
EOF

cat > app/services/chat.py << 'EOF'
# --- File: app/services/chat.py --- START ---
import logging
import asyncio
import datetime
import random
from app.core.event_bus import event_bus
from app.events import (
    ChatMessageReceived,
    CommandDetected,
    BotResponse,
    BotResponseToSend,
    StreamerInputReceived,
    BroadcastStreamerMessage,
)
from app.core.config import COMMAND_PREFIX
from app.core.json_store import load_checkins, save_checkins, load_commands

logger = logging.getLogger(__name__)

async def handle_chat_message(event: ChatMessageReceived):
    """Processes incoming chat messages and detects commands."""
    message = event.message
    logger.debug(f"Processing chat message from {message.platform}/{message.channel}/{message.user}: {message.text}")
    
    if message.text.startswith(COMMAND_PREFIX):
        parts = message.text[len(COMMAND_PREFIX):].strip().split()
        if parts:
            command = parts[0].lower()
            args = parts[1:]
            event_bus.publish(CommandDetected(
                command=command,
                args=args,
                source_message=message
            ))

async def handle_command(event: CommandDetected):
    """Handles detected commands and triggers appropriate responses."""
    command = event.command
    source = event.source_message
    logger.info(f"Command detected: !{command} from {source.platform}/{source.user}")
    
    response_text = None
    if command == "checkin":
        checkins = await load_checkins()
        user_key = f"{source.platform}:{source.user}"
        checkins[user_key] = {
            "last_checkin": datetime.datetime.utcnow().isoformat(),
            "platform": source.platform,
            "user": source.user,
            "channel": source.channel
        }
        await save_checkins(checkins)
        response_text = f"@{source.user} checked in successfully!"
    
    elif command == "ping":
        response_text = "Pong!"
    
    elif command == "roll":
        die = event.args[0].lower() if event.args else "d20"
        if die.startswith("d") and die[1:].isdigit():
            sides = int(die[1:])
            if sides > 0:
                result = random.randint(1, sides)
                response_text = f"@{source.user} rolled a {result} on a {die}!"
            else:
                response_text = "Invalid die: Must have at least 1 side."
        else:
            response_text = "Usage: !roll dN (e.g., !roll d20)"
    
    else:
        # Check custom commands
        commands = await load_commands()
        if command in commands:
            response_text = commands[command].replace("{user}", f"@{source.user}")
    
    if response_text:
        event_bus.publish(BotResponseToSend(
            response=BotResponse(
                platform=source.platform,
                channel=source.channel,
                text=response_text
            )
        ))

async def handle_streamer_input(event: StreamerInputReceived):
    """Handles input from the streamer via the dashboard."""
    logger.info(f"Streamer input received: {event.text}")
    if event.text.startswith(COMMAND_PREFIX):
        parts = event.text[len(COMMAND_PREFIX):].strip().split()
        if parts:
            command = parts[0].lower()
            args = parts[1:]
            event_bus.publish(CommandDetected(
                command=command,
                args=args,
                source_message=InternalChatMessage(
                    platform="dashboard",
                    channel="all",
                    user="streamer",
                    text=event.text,
                    timestamp=datetime.datetime.utcnow().isoformat()
                )
            ))
    else:
        event_bus.publish(BroadcastStreamerMessage(text=event.text))

def setup_chat_processor():
    """Sets up event listeners for chat processing."""
    logger.info("Setting up chat processor...")
    event_bus.subscribe(ChatMessageReceived, handle_chat_message)
    event_bus.subscribe(CommandDetected, handle_command)
    event_bus.subscribe(StreamerInputReceived, handle_streamer_input)
# --- File: app/services/chat.py --- END ---
EOF

cat > app/services/whatnot_bridge.py << 'EOF'
# --- File: app/services/whatnot_bridge.py --- START ---
import logging
import asyncio
from fastapi import WebSocket
from app.core.event_bus import event_bus
from app.events import BotResponseToSend, PlatformStatusUpdate

logger = logging.getLogger(__name__)
_STATE = {"websocket": None, "task": None, "running": False}
_run_task: asyncio.Task | None = None

async def handle_whatnot_response(event: BotResponseToSend):
    """Handles bot responses destined for Whatnot."""
    if event.response.platform != "whatnot":
        return
    websocket = _STATE.get("websocket")
    if not websocket:
        logger.error("No active Whatnot WebSocket to send response")
        return
    
    try:
        await websocket.send_json({
            "type": "chat_message",
            "payload": {
                "channel": event.response.channel,
                "text": event.response.text
            }
        })
        logger.debug(f"Sent Whatnot response: {event.response.text}")
    except Exception as e:
        logger.error(f"Error sending Whatnot response: {e}")

def set_whatnot_websocket(websocket: WebSocket):
    """Sets the active Whatnot WebSocket connection."""
    _STATE["websocket"] = websocket
    logger.info("Whatnot WebSocket set")
    event_bus.publish(PlatformStatusUpdate(platform="whatnot", status="connected"))

def clear_whatnot_websocket():
    """Clears the Whatnot WebSocket connection."""
    _STATE["websocket"] = None
    logger.info("Whatnot WebSocket cleared")
    event_bus.publish(PlatformStatusUpdate(platform="whatnot", status="disconnected"))

async def run_whatnot_bridge():
    """Main runner for Whatnot bridge service."""
    global _STATE, _run_task
    logger.info("Whatnot bridge service started")
    _STATE["running"] = True
    
    while _STATE["running"]:
        if not _STATE.get("websocket"):
            logger.debug("No Whatnot WebSocket connected, waiting...")
            event_bus.publish(PlatformStatusUpdate(platform="whatnot", status="disconnected"))
            await asyncio.sleep(5)
        else:
            await asyncio.sleep(5)  # Keep task alive
    
    logger.info("Whatnot bridge service exiting")
    _STATE["running"] = False

async def stop_whatnot_bridge():
    """Stops the Whatnot bridge service."""
    global _STATE, _run_task
    logger.info("Stopping Whatnot bridge...")
    _STATE["running"] = False
    if _STATE.get("websocket"):
        try:
            await _STATE["websocket"].close()
        except Exception as e:
            logger.error(f"Error closing Whatnot WebSocket: {e}")
        _STATE["websocket"] = None
    
    if _run_task and not _run_task.done():
        _run_task.cancel()
        try:
            await _run_task
        except asyncio.CancelledError:
            logger.info("Whatnot bridge task cancelled")
    
    _run_task = None
    _STATE["task"] = None
    event_bus.publish(PlatformStatusUpdate(platform="whatnot", status="stopped"))
    logger.info("Whatnot bridge stopped")

def start_whatnot_bridge_task() -> asyncio.Task | None:
    """Creates a task for running the Whatnot bridge."""
    global _STATE, _run_task
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("Whatnot bridge already running")
        return _STATE["task"]
    
    logger.info("Starting Whatnot bridge task")
    _run_task = asyncio.create_task(run_whatnot_bridge(), name="WhatnotBridgeRunner")
    _STATE["task"] = _run_task
    event_bus.subscribe(BotResponseToSend, handle_whatnot_response)
    return _run_task
# --- File: app/services/whatnot_bridge.py --- END ---
EOF

cat > app/services/dashboard_service.py << 'EOF'
# --- File: app/services/dashboard_service.py --- START ---
import logging
import json
import asyncio
from fastapi import WebSocket, WebSocketDisconnect
from app.core.event_bus import event_bus
from app.events import (
    InternalChatMessage,
    ChatMessageReceived,
    PlatformStatusUpdate,
    LogMessage,
    StreamerInputReceived,
    BotResponseToSend,
    BroadcastStreamerMessage,
)
from app.core.json_store import load_tokens

logger = logging.getLogger(__name__)
_active_websockets: set[WebSocket] = set()

async def broadcast_to_dashboards(data: dict):
    """Broadcasts a message to all connected dashboard WebSockets."""
    if not _active_websockets:
        return
    disconnected = []
    for ws in _active_websockets:
        try:
            await ws.send_json(data)
        except Exception as e:
            logger.error(f"Error broadcasting to dashboard WebSocket: {e}")
            disconnected.append(ws)
    
    for ws in disconnected:
        _active_websockets.discard(ws)

async def handle_chat_message(event: ChatMessageReceived):
    """Forwards chat messages to the dashboard."""
    message = event.message
    await broadcast_to_dashboards({
        "type": "chat_message",
        "payload": {
            "platform": message.platform,
            "channel": message.channel,
            "user": message.user,
            "text": message.text,
            "timestamp": message.timestamp
        }
    })

async def handle_status_update(event: PlatformStatusUpdate):
    """Forwards platform status updates to the dashboard."""
    await broadcast_to_dashboards({
        "type": "status_update",
        "payload": {
            "platform": event.platform,
            "status": event.status,
            "message": event.message
        }
    })

async def handle_log_message(event: LogMessage):
    """Forwards log messages to the dashboard."""
    await broadcast_to_dashboards({
        "type": "log_message",
        "payload": {
            "level": event.level,
            "message": event.message,
            "module": event.module
        }
    })

async def handle_bot_response(event: BotResponseToSend):
    """Forwards bot responses to the dashboard for display."""
    response = event.response
    await broadcast_to_dashboards({
        "type": "bot_response",
        "payload": {
            "platform": response.platform,
            "channel": response.channel,
            "text": response.text
        }
    })

async def handle_broadcast_message(event: BroadcastStreamerMessage):
    """Handles streamer broadcasts by sending to all platforms."""
    platforms = ["twitch", "youtube", "x", "whatnot"]
    for platform in platforms:
        tokens = await load_tokens(platform)
        if tokens and tokens.get("access_token"):
            event_bus.publish(BotResponseToSend(
                response=BotResponse(
                    platform=platform,
                    channel=tokens.get("user_login", "default"),
                    text=event.text
                )
            ))

async def handle_dashboard_websocket(websocket: WebSocket):
    """Manages a dashboard WebSocket connection."""
    await websocket.accept()
    _active_websockets.add(websocket)
    logger.info("Dashboard WebSocket connected")
    
    try:
        while True:
            data = await websocket.receive_text()
            try:
                message = json.loads(data)
                msg_type = message.get("type")
                payload = message.get("payload", {})
                
                if msg_type == "streamer_input":
                    event_bus.publish(StreamerInputReceived(text=payload.get("text", "")))
                elif msg_type == "ping":
                    await websocket.send_json({"type": "pong"})
                else:
                    logger.warning(f"Unknown dashboard message type: {msg_type}")
            
            except json.JSONDecodeError:
                logger.error(f"Invalid JSON from dashboard: {data}")
            except Exception as e:
                logger.error(f"Error processing dashboard message: {e}")
    
    except WebSocketDisconnect:
        logger.info("Dashboard WebSocket disconnected")
        _active_websockets.discard(websocket)
    except Exception as e:
        logger.error(f"Unexpected error in dashboard WebSocket: {e}")
        _active_websockets.discard(websocket)

def setup_dashboard_service_listeners():
    """Sets up event listeners for dashboard updates."""
    logger.info("Setting up dashboard service listeners...")
    event_bus.subscribe(ChatMessageReceived, handle_chat_message)
    event_bus.subscribe(PlatformStatusUpdate, handle_status_update)
    event_bus.subscribe(LogMessage, handle_log_message)
    event_bus.subscribe(BotResponseToSend, handle_bot_response)
    event_bus.subscribe(BroadcastStreamerMessage, handle_broadcast_message)
# --- File: app/services/dashboard_service.py --- END ---
EOF

cat > app/services/streamer_command_handler.py << 'EOF'
# --- File: app/services/streamer_command_handler.py --- START ---
import logging
from app.core.event_bus import event_bus
from app.events import CommandDetected, BotResponseToSend, BotResponse

logger = logging.getLogger(__name__)

async def handle_streamer_command(event: CommandDetected):
    """Handles commands issued by the streamer."""
    if event.source_message.platform != "dashboard":
        return
    
    command = event.command
    source = event.source_message
    logger.info(f"Streamer command detected: !{command}")
    
    response_text = None
    if command == "announce":
        message = " ".join(event.args) if event.args else "Hello everyone!"
        response_text = f"Announcement: {message}"
        # Broadcast to all platforms
        platforms = ["twitch", "youtube", "x", "whatnot"]
        for platform in platforms:
            event_bus.publish(BotResponseToSend(
                response=BotResponse(
                    platform=platform,
                    channel=source.channel,
                    text=response_text
                )
            ))
    
    elif command == "status":
        response_text = "Bot is running! Check the dashboard for platform statuses."
        event_bus.publish(BotResponseToSend(
            response=BotResponse(
                platform="dashboard",
                channel=source.channel,
                text=response_text
            )
        ))

def setup_streamer_command_handler():
    """Sets up event listeners for streamer commands."""
    logger.info("Setting up streamer command handler...")
    event_bus.subscribe(CommandDetected, handle_streamer_command)
# --- File: app/services/streamer_command_handler.py --- END ---
EOF

# Create static/ files
cat > static/index.html << 'EOF'
<!-- File: static/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FoSBot Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
        #header { background: #333; color: white; padding: 10px; text-align: center; }
        #tab-buttons { margin: 10px 0; }
        .tab-button { padding: 8px 16px; margin-right: 5px; background: #ddd; border: none; cursor: pointer; }
        .tab-button.active { background: #007bff; color: white; }
        #main-content { display: flex; }
        #content-area { flex: 3; background: white; padding: 15px; border-radius: 5px; }
        #sidebar { flex: 1; margin-left: 10px; background: #e9ecef; padding: 10px; border-radius: 5px; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #chat-output { max-height: 500px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
        .chat-message { margin: 5px 0; }
        .chat-message-whatnot { color: #ff4500; }
        .chat-message-youtube { color: #ff0000; }
        .chat-message-twitch { color: #9146ff; }
        .chat-message-x { color: #1da1f2; }
        #streamer-input { width: 100%; padding: 5px; margin-top: 10px; }
        #sendButton, #clearButton { margin-top: 5px; padding: 5px 10px; }
        #status-indicators div { margin: 5px 0; }
        .status-light { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .status-light.connected { background: green; }
        .status-light.disconnected { background: red; }
        .status-light.error { background: orange; }
        .status-light.disabled { background: gray; }
        .settings-section { margin-bottom: 20px; }
        .settings-section h3 { margin-bottom: 10px; }
        .auth-status { display: inline-block; margin-right: 10px; }
        .control-button { margin: 5px; padding: 5px 10px; }
        .download-link { color: #007bff; text-decoration: underline; cursor: pointer; }
        .instructions { margin-top: 10px; font-size: 14px; }
        #commands-table { width: 100%; border-collapse: collapse; }
        #commands-table th, #commands-table td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        #commands-table th { background: #f4f4f4; }
        .command-action { cursor: pointer; color: #007bff; }
        #add-command-form { margin-top: 10px; }
        #add-command-form input { margin: 5px 0; padding: 5px; width: 100%; }
        #csv-upload { margin-top: 10px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
        .modal-content { background: white; margin: 15% auto; padding: 20px; width: 50%; border-radius: 5px; }
        .close { float: right; cursor: pointer; font-size: 20px; }
    </style>
</head>
<body>
    <div id="header">
        <h1>FoSBot Dashboard</h1>
    </div>
    <div id="tab-buttons">
        <button class="tab-button active" data-tab="chat">Chat</button>
        <button class="tab-button" data-tab="commands">Commands</button>
        <button class="tab-button" data-tab="settings">Settings</button>
    </div>
    <div id="main-content">
        <div id="content-area">
            <!-- Chat Tab -->
            <div id="chat-container" class="tab-content active" data-tab-content="chat">
                <h2>Live Chat</h2>
                <div id="chat-output"></div>
                <input type="text" id="streamerInput" placeholder="Type a message or command...">
                <button id="sendButton">Send</button>
                <button id="clearButton">Clear Chat</button>
            </div>

            <!-- Commands Tab -->
            <div id="commands-container" class="tab-content" data-tab-content="commands">
                <h2>Manage Commands</h2>
                <p>Create custom commands like <code>!roll</code> for your streams!</p>
                <table id="commands-table">
                    <thead>
                        <tr>
                            <th>Command</th>
                            <th>Response</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <form id="add-command-form">
                    <input type="text" id="command-name" placeholder="Command (e.g., roll)" required>
                    <input type="text" id="command-response" placeholder="Response (e.g., Rolled a {user} d20!)" required>
                    <button type="submit">Add Command</button>
                </form>
                <div id="csv-upload">
                    <label for="csv-file">Upload CSV (format: command,response):</label>
                    <input type="file" id="csv-file" accept=".csv">
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings-container" class="tab-content" data-tab-content="settings">
                <h2>Application Settings</h2>
                <p id="settings-status"></p>

                <!-- Whatnot Section -->
                <div class="settings-section">
                    <h3>Whatnot Integration</h3>
                    <div id="whatnot-status-area">
                        <span class="auth-status">Status: Loading...</span>
                    </div>
                    <p>
                        <a href="/whatnot_extension.zip" class="download-link" download>Download Whatnot Extension</a>
                        <button class="control-button" onclick="openWhatnotGuide()">Guided Setup</button>
                    </p>
                    <div class="instructions">
                        <strong>Quick Setup:</strong>
                        <p>Click "Guided Setup" for step-by-step help or download the extension and follow the README!</p>
                    </div>
                </div>

                <!-- YouTube Section -->
                <div class="settings-section">
                    <h3>YouTube Authentication</h3>
                    <div id="youtube-auth-area">
                        <span class="auth-status">Loading...</span>
                        <button class="control-button" data-platform="youtube" data-action="login">Login</button>
                        <button class="control-button" data-platform="youtube" data-action="logout" disabled>Logout</button>
                    </div>
                </div>

                <!-- Twitch Section -->
                <div class="settings-section">
                    <h3>Twitch Authentication</h3>
                    <div id="twitch-auth-area">
                        <span class="auth-status">Loading...</span>
                        <button class="control-button" data-platform="twitch" data-action="login">Login</button>
                        <button class="control-button" data-platform="twitch" data-action="logout" disabled>Logout</button>
                    </div>
                </div>

                <!-- X Section -->
                <div class="settings-section">
                    <h3>X Authentication</h3>
                    <div id="x-auth-area">
                        <span class="auth-status">Loading...</span>
                        <button class="control-button" data-platform="x" data-action="login">Login</button>
                        <button class="control-button" data-platform="x" data-action="logout" disabled>Logout</button>
                    </div>
                </div>

                <!-- App Config Section -->
                <div class="settings-section">
                    <h3>General Settings</h3>
                    <form id="app-settings-form">
                        <label>Command Prefix:</label><br>
                        <input type="text" name="COMMAND_PREFIX" maxlength="5" value="!"><br>
                        <label>Log Level:</label><br>
                        <select name="LOG_LEVEL">
                            <option value="DEBUG">DEBUG</option>
                            <option value="INFO">INFO</option>
                            <option value="WARNING">WARNING</option>
                            <option value="ERROR">ERROR</option>
                            <option value="CRITICAL">CRITICAL</option>
                        </select><br>
                        <label>Extra Twitch Channels (optional, comma-separated):</label><br>
                        <input type="text" name="TWITCH_CHANNELS" placeholder="channel1,channel2"><br>
                        <button type="submit">Save</button>
                    </form>
                </div>

                <!-- Service Control Section -->
                <div class="settings-section">
                    <h3>Service Control</h3>
                    <div>
                        <button class="control-button" data-service="whatnot" data-command="start">Start Whatnot</button>
                        <button class="control-button" data-service="whatnot" data-command="stop">Stop Whatnot</button>
                        <button class="control-button" data-service="whatnot" data-command="restart">Restart Whatnot</button>
                    </div>
                    <div>
                        <button class="control-button" data-service="youtube" data-command="start">Start YouTube</button>
                        <button class="control-button" data-service="youtube" data-command="stop">Stop YouTube</button>
                        <button class="control-button" data-service="youtube" data-command="restart">Restart YouTube</button>
                    </div>
                    <div>
                        <button class="control-button" data-service="twitch" data-command="start">Start Twitch</button>
                        <button class="control-button" data-service="twitch" data-command="stop">Stop Twitch</button>
                        <button class="control-button" data-service="twitch" data-command="restart">Restart Twitch</button>
                    </div>
                    <div>
                        <button class="control-button" data-service="x" data-command="start">Start X</button>
                        <button class="control-button" data-service="x" data-command="stop">Stop X</button>
                        <button class="control-button" data-service="x" data-command="restart">Restart X</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div id="sidebar">
            <h3>Status</h3>
            <div id="status-indicators">
                <div id="status-ws"><span class="status-light"></span><span class="status-text">WebSocket: Unknown</span></div>
                <div id="status-whatnot"><span class="status-light"></span><span class="status-text">Whatnot: Unknown</span></div>
                <div id="status-youtube"><span class="status-light"></span><span class="status-text">YouTube: Unknown</span></div>
                <div id="status-twitch"><span class="status-light"></span><span class="status-text">Twitch: Unknown</span></div>
                <div id="status-x"><span class="status-light"></span><span class="status-text">X: Unknown</span></div>
            </div>
            <h3>Logs</h3>
            <div id="log-output" style="max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;"></div>
        </div>
    </div>

    <!-- Whatnot Setup Modal -->
    <div id="whatnot-guide-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeWhatnotGuide()">×</span>
            <h3>Whatnot Extension Setup</h3>
            <ol>
                <li>Click <a href="/whatnot_extension.zip" download>"Download Whatnot Extension"</a> above.</li>
                <li>Unzip to a folder (e.g., <code>~/FoSBot_Whatnot</code>).</li>
                <li>In Chrome, go to <code>chrome://extensions/</code>, enable "Developer mode," click "Load unpacked," select the folder.</li>
                <li>On a Whatnot stream, click the extension icon, enable "Select Mode," click chat elements, save.</li>
            </ol>
            <p><strong>Watch:</strong> <a href="https://patreon.com/yourvideo" target="_blank">Setup Video</a></p>
            <button onclick="closeWhatnotGuide()">Close</button>
        </div>
    </div>

    <script src="main.js"></script>
</body>
</html>
<!-- File: static/index.html -->
EOF

cat > static/main.js << 'EOF'
// --- File: static/main.js --- START ---
const ws = new WebSocket(`ws://${window.location.hostname}:8000/ws/dashboard`);
let isWebSocketConnected = false;

ws.onopen = () => {
    console.log('WebSocket connected to dashboard');
    isWebSocketConnected = true;
    updateStatusIndicator('ws', 'connected', 'WebSocket: Connected');
    ws.send(JSON.stringify({ type: 'ping' }));
};

ws.onclose = () => {
    console.log('WebSocket disconnected');
    isWebSocketConnected = false;
    updateStatusIndicator('ws', 'disconnected', 'WebSocket: Disconnected');
};

ws.onerror = (error) => {
    console.error('WebSocket error:', error);
    updateStatusIndicator('ws', 'error', 'WebSocket: Error');
};

ws.onmessage = (event) => {
    try {
        const data = JSON.parse(event.data);
        switch (data.type) {
            case 'chat_message':
                displayChatMessage(data.payload);
                break;
            case 'bot_response':
                displayBotResponse(data.payload);
                break;
            case 'status_update':
                updatePlatformStatus(data.payload);
                break;
            case 'log_message':
                displayLogMessage(data.payload);
                break;
            case 'pong':
                console.log('Received pong from server');
                break;
            default:
                console.warn('Unknown message type:', data.type);
        }
    } catch (e) {
        console.error('Error parsing WebSocket message:', e);
    }
};

function updateStatusIndicator(platform, status, message) {
    const indicator = document.getElementById(`status-${platform}`);
    if (indicator) {
        const light = indicator.querySelector('.status-light');
        const text = indicator.querySelector('.status-text');
        light.className = `status-light ${status}`;
        text.textContent = message;
    }
}

function displayChatMessage(payload) {
    const chatOutput = document.getElementById('chat-output');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message chat-message-${payload.platform}`;
    messageDiv.textContent = `[${payload.platform}/${payload.channel}] ${payload.user}: ${payload.text}`;
    chatOutput.appendChild(messageDiv);
    chatOutput.scrollTop = chatOutput.scrollHeight;
}

function displayBotResponse(payload) {
    const chatOutput = document.getElementById('chat-output');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message chat-message-${payload.platform}`;
    messageDiv.textContent = `[${payload.platform}/${payload.channel}] Bot: ${payload.text}`;
    chatOutput.appendChild(messageDiv);
    chatOutput.scrollTop = chatOutput.scrollHeight;
}

function displayLogMessage(payload) {
    const logOutput = document.getElementById('log-output');
    const logDiv = document.createElement('div');
    logDiv.textContent = `[${payload.level}] ${payload.module || 'unknown'}: ${payload.message}`;
    logOutput.appendChild(logDiv);
    logOutput.scrollTop = logOutput.scrollHeight;
}

function updatePlatformStatus(payload) {
    const platform = payload.platform;
    const statusArea = document.getElementById(`${platform}-auth-area`) || document.getElementById(`${platform}-status-area`);
    if (statusArea) {
        const statusSpan = statusArea.querySelector('.auth-status');
        let statusText = `Status: ${payload.status}`;
        if (payload.message) {
            statusText += ` (${payload.message})`;
        }
        statusSpan.textContent = statusText;
    }
    updateStatusIndicator(platform, payload.status, `${platform.charAt(0).toUpperCase() + platform.slice(1)}: ${payload.status}`);
}

function openWhatnotGuide() {
    document.getElementById('whatnot-guide-modal').style.display = 'block';
}

function closeWhatnotGuide() {
    document.getElementById('whatnot-guide-modal').style.display = 'none';
}

document.addEventListener('DOMContentLoaded', () => {
    // Tab Switching
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            
            button.classList.add('active');
            const tabId = button.dataset.tab;
            document.querySelector(`[data-tab-content="${tabId}"]`).classList.add('active');
        });
    });

    // Send Button
    const sendButton = document.getElementById('sendButton');
    const streamerInput = document.getElementById('streamerInput');
    
    sendButton.addEventListener('click', () => {
        const text = streamerInput.value.trim();
        if (text && isWebSocketConnected) {
            ws.send(JSON.stringify({
                type: 'streamer_input',
                payload: { text }
            }));
            streamerInput.value = '';
        }
    });

    streamerInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendButton.click();
        }
    });

    // Clear Chat Button
    const clearButton = document.getElementById('clearButton');
    clearButton.addEventListener('click', () => {
        document.getElementById('chat-output').innerHTML = '';
    });

    // Settings Form
    const settingsForm = document.getElementById('app-settings-form');
    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(settingsForm);
        const settings = {};
        formData.forEach((value, key) => {
            settings[key] = value;
        });
        
        try {
            const response = await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });
            const result = await response.json();
            document.getElementById('settings-status').textContent = result.message;
        } catch (error) {
            document.getElementById('settings-status').textContent = 'Error saving settings';
            console.error('Error saving settings:', error);
        }
    });

    // Auth Buttons
    const authButtons = document.querySelectorAll('.control-button[data-platform]');
    authButtons.forEach(button => {
        button.addEventListener('click', async () => {
            const platform = button.dataset.platform;
            const action = button.dataset.action;
            
            if (action === 'login') {
                window.location.href = `/auth/${platform}/login`;
            } else if (action === 'logout') {
                try {
                    const response = await fetch(`/auth/${platform}/logout`, { method: 'POST' });
                    const result = await response.json();
                    alert(result.message);
                    fetchSettings();
                } catch (error) {
                    alert(`Oops, ${platform} logout fumbled like a critical miss! Try again?`);
                    console.error(`Error logging out from ${platform}:`, error);
                }
            }
        });
    });

    // Service Control Buttons
    const controlButtons = document.querySelectorAll('.control-button[data-service]');
    controlButtons.forEach(button => {
        button.addEventListener('click', async () => {
            const service = button.dataset.service;
            const command = button.dataset.command;
            
            try {
                const response = await fetch(`/api/control/${service}/${command}`, { method: 'POST' });
                const result = await response.json();
                console.log(result.message);
            } catch (error) {
                console.error(`Error executing ${command} for ${service}:`, error);
            }
        });
    });

    // Commands Management
    const commandsTableBody = document.querySelector('#commands-table tbody');
    const addCommandForm = document.getElementById('add-command-form');
    const csvFileInput = document.getElementById('csv-file');

    async function fetchCommands() {
        try {
            const response = await fetch('/api/commands');
            const commands = await response.json();
            commandsTableBody.innerHTML = '';
            for (const [command, response] of Object.entries(commands)) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>!${command}</td>
                    <td>${response}</td>
                    <td>
                        <span class="command-action" onclick="deleteCommand('${command}')">Delete</span>
                    </td>
                `;
                commandsTableBody.appendChild(row);
            }
        } catch (error) {
            console.error('Error fetching commands:', error);
        }
    }

    addCommandForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const command = document.getElementById('command-name').value.trim().toLowerCase();
        const response = document.getElementById('command-response').value.trim();
        
        try {
            const res = await fetch('/api/commands', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command, response })
            });
            const result = await res.json();
            alert(result.message);
            fetchCommands();
            addCommandForm.reset();
        } catch (error) {
            alert('Failed to add command. Did we roll a 1?');
            console.error('Error adding command:', error);
        }
    });

    csvFileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/commands/upload', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();
                alert(result.message);
                fetchCommands();
                csvFileInput.value = '';
            } catch (error) {
                alert('CSV upload crit-failed! Check format and try again.');
                console.error('Error uploading CSV:', error);
            }
        }
    });

    window.deleteCommand = async (command) => {
        if (confirm(`Delete !${command}?`)) {
            try {
                const response = await fetch(`/api/commands/${command}`, { method: 'DELETE' });
                const result = await response.json();
                alert(result.message);
                fetchCommands();
            } catch (error) {
                alert(`Couldn’t delete !${command}. Gremlins in the code!`);
                console.error('Error deleting command:', error);
            }
        }
    };

    // Fetch Initial Settings
    async function fetchSettings() {
        try {
            const response = await fetch('/api/settings');
            const settings = await response.json();
            
            // Update form fields
            settingsForm.querySelector('[name="COMMAND_PREFIX"]').value = settings.COMMAND_PREFIX || '!';
            settingsForm.querySelector('[name="LOG_LEVEL"]').value = settings.LOG_LEVEL || 'INFO';
            settingsForm.querySelector('[name="TWITCH_CHANNELS"]').value = settings.TWITCH_CHANNELS || '';
            
            // Update auth statuses
            ['twitch', 'youtube', 'x'].forEach(platform => {
                const authArea = document.getElementById(`${platform}-auth-area`);
                if (authArea) {
                    const statusSpan = authArea.querySelector('.auth-status');
                    const loginButton = authArea.querySelector('[data-action="login"]');
                    const logoutButton = authArea.querySelector('[data-action="logout"]');
                    
                    const authStatus = settings[`${platform}_auth_status`];
                    if (authStatus.logged_in) {
                        statusSpan.textContent = `Logged in as ${authStatus.user_login}`;
                        loginButton.disabled = true;
                        logoutButton.disabled = false;
                    } else {
                        statusSpan.textContent = 'Not logged in';
                        loginButton.disabled = false;
                        logoutButton.disabled = true;
                    }
                }
            });
            
            // Update Whatnot status
            const whatnotStatus = document.getElementById('whatnot-status-area').querySelector('.auth-status');
            whatnotStatus.textContent = 'Extension required';
            
        } catch (error) {
            console.error('Error fetching settings:', error);
        }
    }

    fetchSettings();
    fetchCommands();
    
    // Handle auth_success and auth_error
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auth_success')) {
        fetchSettings();
        window.history.replaceState({}, document.title, window.location.pathname);
    } else if (urlParams.get('auth_error')) {
        const platform = urlParams.get('auth_error');
        const message = urlParams.get('message') || 'Unknown error';
        let funnyMessage;
        switch (platform) {
            case 'twitch':
                funnyMessage = `Twitch rejected us like a bad d20 roll! (${message}) Try again?`;
                break;
            case 'youtube':
                funnyMessage = `YouTube said no like a grumpy DM! (${message}) Retry?`;
                break;
            case 'x':
                funnyMessage = `X ghosted us like a sneaky rogue! (${message}) Give it another shot?`;
                break;
            default:
                funnyMessage = `Something broke like a goblin’s trap! (${message}) Try again?`;
        }
        alert(funnyMessage);
        window.history.replaceState({}, document.title, window.location.pathname);
    }
});
// --- File: static/main.js --- END ---
EOF

# Create whatnot_extension/ files
cat > whatnot_extension/manifest.json << 'EOF'
{
    "manifest_version": 3,
    "name": "FoSBot Whatnot Bridge",
    "version": "0.7.0",
    "description": "Connects Whatnot live streams to FoSBot",
    "permissions": [
        "storage",
        "activeTab"
    ],
    "background": {
        "service_worker": "background.js"
    },
    "content_scripts": [
        {
            "matches": ["https://*.whatnot.com/*"],
            "js": ["content.js"]
        }
    ],
    "action": {
        "default_popup": "popup.html"
    }
}
EOF

cat > whatnot_extension/background.js << 'EOF'
// --- File: whatnot_extension/background.js --- START ---
let ws = null;

function connectWebSocket() {
    ws = new WebSocket('ws://localhost:8000/ws/whatnot');
    
    ws.onopen = () => {
        console.log('WebSocket connected to FoSBot');
        ws.send(JSON.stringify({ type: 'ping' }));
    };
    
    ws.onclose = () => {
        console.log('WebSocket disconnected');
        setTimeout(connectWebSocket, 5000);
    };
    
    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
    };
    
    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'pong') {
                console.log('Received pong from FoSBot');
            } else {
                console.log('Received message:', data);
            }
        } catch (e) {
            console.error('Error parsing WebSocket message:', e);
        }
    };
}

connectWebSocket();

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === 'chat_message' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'chat_message',
            payload: request.payload
        }));
    }
});
// --- File: whatnot_extension/background.js --- END ---
EOF

cat > whatnot_extension/popup.html << 'EOF'
<!-- File: whatnot_extension/popup.html -->
<!DOCTYPE html>
<html>
<head>
    <title>FoSBot Whatnot Bridge</title>
    <style>
        body { font-family: Arial, sans-serif; width: 300px; padding: 10px; }
        label { display: block; margin: 10px 0 5px; }
        input, button { width: 100%; padding: 5px; margin-bottom: 10px; }
        #status { color: green; }
        #error { color: red; }
    </style>
</head>
<body>
    <h3>FoSBot Whatnot Bridge</h3>
    <label><input type="checkbox" id="selectMode"> Enable Select Mode</label>
    <label>Chat Container Selector:</label>
    <input type="text" id="chatContainerSelector" placeholder=".chat-container">
    <label>Message Selector:</label>
    <input type="text" id="messageSelector" placeholder=".chat-message">
    <label>User Selector:</label>
    <input type="text" id="userSelector" placeholder=".chat-user">
    <label>Text Selector:</label>
    <input type="text" id="textSelector" placeholder=".chat-text">
    <button id="saveButton">Save</button>
    <div id="status"></div>
    <div id="error"></div>
    <p><a href="https://patreon.com/yourvideo" target="_blank">Watch Setup Video</a></p>
    <script src="popup.js"></script>
</body>
</html>
<!-- File: whatnot_extension/popup.html -->
EOF

cat > whatnot_extension/popup.js << 'EOF'
// --- File: whatnot_extension/popup.js --- START ---
document.addEventListener('DOMContentLoaded', () => {
    const selectModeCheckbox = document.getElementById('selectMode');
    const chatContainerInput = document.getElementById('chatContainerSelector');
    const messageInput = document.getElementById('messageSelector');
    const userInput = document.getElementById('userSelector');
    const textInput = document.getElementById('textSelector');
    const saveButton = document.getElementById('saveButton');
    const statusDiv = document.getElementById('status');
    const errorDiv = document.getElementById('error');
    
    // Load saved settings
    chrome.storage.local.get(['chatContainerSelector', 'messageSelector', 'userSelector', 'textSelector', 'selectMode'], (data) => {
        chatContainerInput.value = data.chatContainerSelector || '';
        messageInput.value = data.messageSelector || '';
        userInput.value = data.userSelector || '';
        textInput.value = data.textSelector || '';
        selectModeCheckbox.checked = data.selectMode || false;
    });
    
    // Save settings
    saveButton.addEventListener('click', () => {
        const settings = {
            chatContainerSelector: chatContainerInput.value.trim(),
            messageSelector: messageInput.value.trim(),
            userSelector: userInput.value.trim(),
            textSelector: textInput.value.trim(),
            selectMode: selectModeCheckbox.checked
        };
        
        chrome.storage.local.set(settings, () => {
            statusDiv.textContent = 'Settings saved!';
            errorDiv.textContent = '';
            setTimeout(() => { statusDiv.textContent = ''; }, 2000);
            
            // Notify content script
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
                if (tabs[0]) {
                    chrome.tabs.sendMessage(tabs[0].id, {
                        type: 'update_settings',
                        payload: settings
                    });
                }
            });
        });
    });
    
    // Toggle select mode
    selectModeCheckbox.addEventListener('change', () => {
        chrome.storage.local.set({ selectMode: selectModeCheckbox.checked }, () => {
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
                if (tabs[0]) {
                    chrome.tabs.sendMessage(tabs[0].id, {
                        type: 'toggle_select_mode',
                        payload: { selectMode: selectModeCheckbox.checked }
                    });
                }
            });
        });
    });
});
// --- File: whatnot_extension/popup.js --- END ---
EOF

cat > whatnot_extension/content.js << 'EOF'
// --- File: whatnot_extension/content.js --- START ---
let settings = {
    chatContainerSelector: '',
    messageSelector: '',
    userSelector: '',
    textSelector: '',
    selectMode: false
};

let observer = null;

function startObserving() {
    if (observer) {
        observer.disconnect();
    }
    
    const container = document.querySelector(settings.chatContainerSelector);
    if (!container) {
        console.warn('Chat container not found:', settings.chatContainerSelector);
        return;
    }
    
    observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length) {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        processNode(node);
                    }
                });
            }
        });
    });
    
    observer.observe(container, { childList: true, subtree: true });
    console.log('Started observing chat container:', settings.chatContainerSelector);
}

function processNode(node) {
    const messageElements = settings.messageSelector ? node.querySelectorAll(settings.messageSelector) : [node];
    messageElements.forEach((msgElement) => {
        const userElement = settings.userSelector ? msgElement.querySelector(settings.userSelector) : msgElement;
        const textElement = settings.textSelector ? msgElement.querySelector(settings.textSelector) : msgElement;
        
        const user = userElement ? userElement.textContent.trim() : 'unknown';
        const text = textElement ? textElement.textContent.trim() : '';
        
        if (text) {
            chrome.runtime.sendMessage({
                type: 'chat_message',
                payload: {
                    channel: 'whatnot',
                    user: user,
                    text: text,
                    timestamp: new Date().toISOString()
                }
            });
        }
    });
}

function handleSelectMode(event) {
    if (!settings.selectMode) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    the element = event.target;
    const selector = getSelector(element);
    
    if (confirm(`Use selector "${selector}"?`)) {
        chrome.runtime.sendMessage({
            type: 'suggest_selector',
            payload: { selector }
        });
    }
}

function getSelector(element) {
    if (element.id) return `#${element.id}`;
    if (element.className) return `.${element.className.split(' ').join('.')}`;
    return element.tagName.toLowerCase();
}

chrome.storage.local.get(['chatContainerSelector', 'messageSelector', 'userSelector', 'textSelector', 'selectMode'], (data) => {
    settings = { ...settings, ...data };
    if (settings.chatContainerSelector) {
        startObserving();
    }
});

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === 'update_settings') {
        settings = { ...settings, ...request.payload };
        if (settings.chatContainerSelector) {
            startObserving();
        } else if (observer) {
            observer.disconnect();
            observer = null;
        }
    } else if (request.type === 'toggle_select_mode') {
        settings.selectMode = request.payload.selectMode;
        if (settings.selectMode) {
            document.addEventListener('click', handleSelectMode, true);
        } else {
            document.removeEventListener('click', handleSelectMode, true);
        }
    } else if (request.type === 'suggest_selector') {
        // Handled in popup.js
    }
});
// --- File: whatnot_extension/content.js --- END ---
EOF

# Verify file count and create zip
echo "Verifying file count..."
find . -type f | wc -l
echo "Creating fosbot.zip..."
zip -r fosbot.zip . -x "create_fosbot_files.sh"
echo "Moving fosbot.zip to Desktop..."
mv fosbot.zip ~/Desktop/
echo "Done! Check ~/Desktop/fosbot.zip"

================================================================================
File: app/events.py
================================================================================

from dataclasses import dataclass
from datetime import datetime

@dataclass
class InternalChatMessage:
    platform: str
    channel: str
    user: str
    text: str
    timestamp: str

@dataclass
class ChatMessageReceived:
    message: InternalChatMessage

@dataclass
class PlatformStatusUpdate:
    platform: str
    status: str
    message: str

@dataclass
class ServiceControl:
    service_name: str
    command: str

@dataclass
class SettingsUpdated:
    keys_updated: list

================================================================================
File: app/__init__.py
================================================================================

# --- File: app/__init__.py --- START ---
# This file makes 'app' a Python package
# --- File: app/__init__.py --- END ---


================================================================================
File: app/main.py
================================================================================

import asyncio
import logging
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from contextlib import asynccontextmanager
from pathlib import Path
from fastapi.exceptions import HTTPException

# Core Imports
from app.core.config import logger, settings
from app.core.event_bus import event_bus

# API Routers
from app.apis import ws_endpoints, settings_api, auth_api, commands_api

# Service Control & Setup
from app.services.twitch_service import start_twitch_service_task, stop_twitch_service
from app.services.youtube_service import start_youtube_service_task, stop_youtube_service
from app.services.x_service import start_x_service_task, stop_x_service
from app.services.whatnot_bridge import start_whatnot_bridge_task, stop_whatnot_bridge
from app.services.chat_processor import setup_chat_processor
from app.services.dashboard_service import setup_dashboard_service_listeners
from app.services.streamer_command_handler import setup_streamer_command_handler

# Events
from app.events import ServiceControl

# Global State
background_tasks = set()
_service_tasks_map: dict[str, asyncio.Task | None] = {}

# Service Control Mapping
service_control_map = {
    "twitch": {"start": start_twitch_service_task, "stop": stop_twitch_service},
    "youtube": {"start": start_youtube_service_task, "stop": stop_youtube_service},
    "x": {"start": start_x_service_task, "stop": stop_x_service},
    "whatnot": {"start": start_whatnot_bridge_task, "stop": stop_whatnot_bridge},
}

async def handle_service_control(event: ServiceControl):
    """Handles start/stop/restart commands for services via the event bus."""
    logger.info(f"Handling control: '{event.command}' for '{event.service_name}'...")
    logger.debug(f"Service control event details: {event}")
    control_funcs = service_control_map.get(event.service_name)
    current_task = _service_tasks_map.get(event.service_name)

    if not control_funcs:
        logger.error(f"No control functions found for service '{event.service_name}'.")
        return

    start_func = control_funcs.get("start")
    stop_func = control_funcs.get("stop")

    if event.command == "stop":
        if current_task and not current_task.done():
            logger.info(f"Stopping running/starting service '{event.service_name}'...")
            if stop_func:
                try:
                    await stop_func()
                    logger.info(f"Service '{event.service_name}' stopped successfully.")
                except Exception as e:
                    logger.error(f"Error stopping service '{event.service_name}': {e}")
            else:
                logger.warning(f"No stop function defined but task exists for '{event.service_name}'. Cancelling directly.")
                if not current_task.cancelled():
                    current_task.cancel()
        else:
            logger.info(f"Service '{event.service_name}' not running, no stop action needed.")
        _service_tasks_map[event.service_name] = None

    elif event.command == "start":
        if current_task and not current_task.done():
            logger.warning(f"Service '{event.service_name}' already running or starting.")
            return

        if start_func:
            logger.info(f"Executing start for '{event.service_name}'...")
            try:
                new_task = start_func()
                if new_task and isinstance(new_task, asyncio.Task):
                    _service_tasks_map[event.service_name] = new_task
                    background_tasks.add(new_task)
                    new_task.add_done_callback(background_tasks.discard)
                    logger.info(f"Task for '{event.service_name}' started and added to background tasks.")
                elif new_task is None:
                    logger.warning(f"Start function for '{event.service_name}' did not return a task (disabled/failed pre-check?).")
                else:
                    logger.error(f"Start function for '{event.service_name}' returned invalid object: {type(new_task)}")
            except Exception as e:
                logger.error(f"Error starting service '{event.service_name}': {e}")
        else:
            logger.warning(f"No start function defined for '{event.service_name}'.")

    elif event.command == "restart":
        logger.info(f"Executing restart for '{event.service_name}'...")
        if current_task and not current_task.done():
            logger.info("...stopping existing service first.")
            if stop_func:
                try:
                    await stop_func()
                    await asyncio.sleep(1)
                    logger.info(f"Service '{event.service_name}' stopped for restart.")
                except Exception as e:
                    logger.error(f"Error stopping service '{event.service_name}' for restart: {e}")
            else:
                logger.warning(f"No stop function for restart of '{event.service_name}'. Cancelling directly.")
                if not current_task.cancelled():
                    current_task.cancel()
                await asyncio.sleep(0.1)
        else:
            logger.info("...service not running, attempting start.")

        _service_tasks_map[event.service_name] = None

        if start_func:
            logger.info("...starting new service instance.")
            try:
                new_task = start_func()
                if new_task and isinstance(new_task, asyncio.Task):
                    _service_tasks_map[event.service_name] = new_task
                    background_tasks.add(new_task)
                    new_task.add_done_callback(background_tasks.discard)
                    logger.info(f"Task for '{event.service_name}' added after restart.")
                elif new_task is None:
                    logger.warning(f"Start function for '{event.service_name}' did not return task on restart.")
                else:
                    logger.error(f"Start function '{event.service_name}' returned invalid object on restart: {type(new_task)}")
            except Exception as e:
                logger.error(f"Error restarting service '{event.service_name}': {e}")
        else:
            logger.warning(f"No start function available for restart of '{event.service_name}'.")

# Lifespan Manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handles application startup and shutdown events."""
    logger.info("--- Application startup sequence initiated ---")
    logger.info("Starting event bus worker..."); await event_bus.start()
    logger.info("Setting up event listeners...")
    try:
        await setup_chat_processor()
        logger.debug("Chat processor setup completed")
    except Exception as e:
        logger.error(f"Error setting up chat processor: {e}")
    setup_dashboard_service_listeners()
    setup_streamer_command_handler()
    event_bus.subscribe(ServiceControl, handle_service_control)
    logger.info("Service control handler subscribed.")
    logger.info("Services will start only via user action through the dashboard.")
    logger.info("--- Application startup complete. Running! ---")

    yield

    logger.info("--- Application shutdown sequence initiated ---")
    logger.info("Stopping platform services (sending stop commands)...")
    stop_tasks = [
        handle_service_control(ServiceControl(service_name=name, command="stop"))
        for name in service_control_map.keys()
    ]
    try:
        await asyncio.gather(*stop_tasks, return_exceptions=True)
    except Exception as e:
        logger.error(f"Error stopping services: {e}")

    logger.info("Waiting briefly..."); await asyncio.sleep(1)
    logger.info("Stopping event bus worker..."); await event_bus.stop()

    if background_tasks:
        logger.warning(f"Cancelling {len(background_tasks)} lingering background tasks...")
        for task in list(background_tasks):
            if task and not task.done():
                task.cancel()
        try:
            await asyncio.wait_for(asyncio.gather(*background_tasks, return_exceptions=True), timeout=5.0)
            logger.debug("Cancelled background tasks successfully.")
        except asyncio.TimeoutError:
            logger.error("Timeout waiting for background tasks to cancel.")
        except Exception as e:
            logger.exception(f"Error during task cancellation: {e}")
    else:
        logger.info("No lingering background tasks found.")
    logger.info("--- Application shutdown complete. ---")

# FastAPI App Creation
app = FastAPI(
    title="FoSBot (Whatnot + YouTube + Twitch + X)",
    version="0.7.0-auto-oauth",
    lifespan=lifespan
)

# Serve whatnot_extension.zip from project root
@app.get("/whatnot_extension.zip")
async def serve_whatnot_extension():
    zip_path = Path("whatnot_extension.zip")
    if not zip_path.is_file():
        zip_path = Path("static/whatnot_extension.zip")
        if not zip_path.is_file():
            raise HTTPException(status_code=404, detail="Whatnot extension ZIP file not found")
    return FileResponse(zip_path, media_type="application/zip", filename="whatnot_extension.zip")

# Mount Routers
app.include_router(auth_api.router)
app.include_router(ws_endpoints.router, prefix="/ws")
app.include_router(settings_api.router, prefix="/api", tags=["Settings & Control"])
app.include_router(commands_api.router, prefix="/api", tags=["Commands"])

# Mount Static Files
STATIC_DIR = "static"
static_path = Path(STATIC_DIR)
if not static_path.is_dir():
    logger.error(f"Static files directory '{STATIC_DIR}' not found at {static_path.resolve()}. Dashboard UI unavailable.")
else:
    try:
        app.mount("/", StaticFiles(directory=STATIC_DIR, html=True), name="static")
        logger.info(f"Mounted static files for dashboard UI from './{STATIC_DIR}'.")
    except Exception as e:
        logger.exception(f"Failed to mount static files directory './{STATIC_DIR}': {e}")

# Direct Run (Debugging Only)
if __name__ == "__main__":
    import uvicorn
    logger.warning("Running via main.py is intended for debugging ONLY. Use 'uvicorn app.main:app --reload'.")
    uvicorn.run("app.main:app", host=settings['WS_HOST'], port=settings['WS_PORT'], log_level=settings['LOG_LEVEL'].lower(), reload=True)

================================================================================
File: app/apis/settings_api.py
================================================================================

# --- File: app/apis/settings_api.py --- START ---
import logging
from typing import Dict, Any
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.core.json_store import load_settings, update_setting, load_tokens
from app.core.event_bus import event_bus
from app.events import ServiceControl

logger = logging.getLogger(__name__)
router = APIRouter()

class SettingsUpdate(BaseModel):
    COMMAND_PREFIX: str | None
    LOG_LEVEL: str | None
    TWITCH_CHANNELS: str | None

@router.get("/settings")
async def get_settings() -> Dict[str, Any]:
    """Fetches current application settings and auth statuses."""
    settings = await load_settings()
    if settings is None:
        settings = {}
    
    result = {
        "COMMAND_PREFIX": settings.get("COMMAND_PREFIX", "!"),
        "LOG_LEVEL": settings.get("LOG_LEVEL", "INFO"),
        "TWITCH_CHANNELS": settings.get("TWITCH_CHANNELS", ""),
    }
    
    # Add auth status for each platform
    for platform in ["twitch", "youtube", "x"]:
        tokens = await load_tokens(platform)
        result[f"{platform}_auth_status"] = {
            "logged_in": bool(tokens and tokens.get("access_token")),
            "user_login": tokens.get("user_login") if tokens else None
        }
    
    logger.debug(f"Returning settings: {result}")
    return result

@router.post("/settings")
async def update_settings(settings: SettingsUpdate):
    """Updates application settings."""
    updated = []
    if settings.COMMAND_PREFIX is not None:
        if len(settings.COMMAND_PREFIX) > 5:
            raise HTTPException(status_code=400, detail="COMMAND_PREFIX must be 5 characters or less")
        if await update_setting("COMMAND_PREFIX", settings.COMMAND_PREFIX):
            updated.append("COMMAND_PREFIX")
    
    if settings.LOG_LEVEL is not None:
        valid_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if settings.LOG_LEVEL not in valid_levels:
            raise HTTPException(status_code=400, detail=f"LOG_LEVEL must be one of {valid_levels}")
        if await update_setting("LOG_LEVEL", settings.LOG_LEVEL):
            updated.append("LOG_LEVEL")
    
    if settings.TWITCH_CHANNELS is not None:
        if await update_setting("TWITCH_CHANNELS", settings.TWITCH_CHANNELS):
            updated.append("TWITCH_CHANNELS")
    
    if updated:
        logger.info(f"Settings updated: {updated}")
        return {"message": f"Settings updated: {', '.join(updated)}"}
    return {"message": "No settings changed"}

@router.post("/control/{service}/{command}")
async def control_service(service: str, command: str):
    """Controls platform services (start, stop, restart)."""
    valid_services = ["twitch", "youtube", "x", "whatnot"]
    valid_commands = ["start", "stop", "restart"]
    
    if service not in valid_services:
        raise HTTPException(status_code=400, detail=f"Invalid service. Must be one of {valid_services}")
    if command not in valid_commands:
        raise HTTPException(status_code=400, detail=f"Invalid command. Must be one of {valid_commands}")
    
    logger.info(f"Received control request: {command} for {service}")
    event_bus.publish(ServiceControl(service_name=service, command=command))
    return {"message": f"Sent {command} command to {service} service"}
# --- File: app/apis/settings_api.py --- END ---

================================================================================
File: app/apis/commands_api.py
================================================================================

# --- File: app/apis/commands_api.py --- START ---
import logging
import csv
import io
from fastapi import APIRouter, HTTPException, UploadFile, File
from pydantic import BaseModel
from typing import Dict, List

from app.core.json_store import load_commands, save_commands

logger = logging.getLogger(__name__)
router = APIRouter(tags=["Commands"])

class CommandModel(BaseModel):
    command: str
    response: str

@router.get("/commands", response_model=Dict[str, str])
async def get_commands():
    """Fetches all custom commands."""
    logger.debug("Fetching all commands")
    commands = await load_commands()
    logger.debug(f"Retrieved commands: {commands}")
    return commands

@router.post("/commands", status_code=201)
async def add_command(command: CommandModel):
    """Adds or updates a custom command."""
    logger.debug(f"Adding command: {command.command} with response: {command.response}")
    commands = await load_commands()
    commands[command.command] = command.response
    if await save_commands(commands):
        logger.info(f"Command '!{command.command}' saved successfully")
        return {"message": f"Command '!{command.command}' added/updated"}
    logger.error("Failed to save command")
    raise HTTPException(status_code=500, detail="Failed to save command")

@router.delete("/commands/{command}", status_code=200)
async def delete_command(command: str):
    """Deletes a custom command."""
    logger.debug(f"Deleting command: {command}")
    commands = await load_commands()
    if command in commands:
        del commands[command]
        if await save_commands(commands):
            logger.info(f"Command '!{command}' deleted successfully")
            return {"message": f"Command '!{command}' deleted"}
        logger.error("Failed to delete command")
        raise HTTPException(status_code=500, detail="Failed to delete command")
    logger.warning(f"Command '!{command}' not found")
    raise HTTPException(status_code=404, detail="Command not found")

@router.post("/commands/upload", status_code=201)
async def upload_commands(file: UploadFile = File(...)):
    """Uploads commands from a CSV file."""
    logger.debug(f"Uploading CSV file: {file.filename}")
    if not file.filename.endswith('.csv'):
        logger.error("Uploaded file is not a CSV")
        raise HTTPException(status_code=400, detail="File must be a CSV")
    
    commands = await load_commands()
    try:
        content = await file.read()
        csv_file = io.StringIO(content.decode('utf-8'))
        reader = csv.reader(csv_file)
        next(reader, None)  # Skip header if present
        updated = 0
        for row in reader:
            if len(row) >= 2:
                command, response = row[0].strip(), row[1].strip()
                if command:
                    commands[command] = response
                    updated += 1
                    logger.debug(f"Added from CSV: {command} -> {response}")
        if updated > 0:
            if await save_commands(commands):
                logger.info(f"Uploaded/updated {updated} commands from CSV")
                return {"message": f"Uploaded/updated {updated} commands"}
            logger.error("Failed to save commands from CSV")
            raise HTTPException(status_code=500, detail="Failed to save commands")
        logger.info("No valid commands found in CSV")
        return {"message": "No valid commands found in CSV"}
    except Exception as e:
        logger.error(f"Error processing CSV: {e}")
        raise HTTPException(status_code=500, detail="Error processing CSV")
# --- File: app/apis/commands_api.py --- END ---

================================================================================
File: app/apis/__init__.py
================================================================================

# app/apis/__init__.py
from .settings_api import router as settings_router
from .auth_api import router as auth_router
from .commands_api import router as commands_router
from .ws_endpoints import router as ws_endpoints_router

__all__ = [
    "settings_router",
    "auth_router",
    "commands_router",
    "ws_endpoints_router",
]

================================================================================
File: app/apis/ws_endpoints.py
================================================================================

# app/apis/ws_endpoints.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from app.core.event_bus import event_bus
from app.events import ChatMessageReceived, BroadcastStreamerMessage
import json

router = APIRouter()

class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@router.websocket("/dashboard")
async def websocket_dashboard(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            if data.startswith("streamer_input:"):
                event_bus.publish(ChatMessageReceived(
                    platform="streamer_admin",
                    username="jgleason",
                    message=data.replace("streamer_input:", ""),
                    timestamp=None
                ))
    except WebSocketDisconnect:
        manager.disconnect(websocket)

@router.websocket("/whatnot")
async def websocket_whatnot(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            if message.get("type") == "newMessages":
                for msg in message["data"]:
                    event_bus.publish(ChatMessageReceived(
                        platform="whatnot",
                        username=msg["username"],
                        message=msg["message"],
                        timestamp=None
                    ))
            elif message.get("type") == "inputSelected":
                print("Whatnot input selected:", message["data"])
            elif message.get("type") == "messageSubmitted":
                print("Whatnot message submitted:", message["data"])
            elif message.get("type") == "queryStatus":
                await websocket.send_text(json.dumps({"type": "statusResponse", "data": "Connected"}))
            elif message.get("type") == "sendMessage":
                await websocket.send_text(json.dumps({"type": "sendMessage", "data": message["data"]}))
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        print("Whatnot WebSocket disconnected")
    except json.JSONDecodeError:
        print("Invalid JSON from Whatnot extension")
    except Exception as e:
        print(f"Error in Whatnot WebSocket: {e}")

================================================================================
File: app/apis/auth_api.py
================================================================================

# --- File: app/apis/auth_api.py --- START ---
import logging
import secrets
from urllib.parse import urlencode
from typing import Dict, Optional, Any
from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import RedirectResponse
import httpx
import tweepy
import asyncio

# Configuration
from app.core.config import (
    TWITCH_APP_CLIENT_ID, TWITCH_APP_CLIENT_SECRET,
    YOUTUBE_APP_CLIENT_ID, YOUTUBE_APP_CLIENT_SECRET,
    X_APP_CLIENT_ID, X_APP_CLIENT_SECRET, APP_SECRET_KEY
)

# Token Storage
from app.core.json_store import save_tokens, clear_tokens, load_tokens

# Event Bus
from app.core.event_bus import event_bus
from app.events import PlatformStatusUpdate, ServiceControl

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth", tags=["Authentication"])

# Constants
TWITCH_REDIRECT_URI = "http://localhost:8000/auth/twitch/callback"
TWITCH_AUTHORIZATION_BASE_URL = "https://id.twitch.tv/oauth2/authorize"
TWITCH_TOKEN_URL = "https://id.twitch.tv/oauth2/token"
TWITCH_VALIDATE_URL = "https://id.twitch.tv/oauth2/validate"
TWITCH_REVOKE_URL = "https://id.twitch.tv/oauth2/revoke"
TWITCH_SCOPES = ["chat:read", "chat:edit", "channel:read:subscriptions"]

YOUTUBE_REDIRECT_URI = "http://localhost:8000/auth/youtube/callback"
YOUTUBE_AUTHORIZATION_BASE_URL = "https://accounts.google.com/o/oauth2/v2/auth"
YOUTUBE_TOKEN_URL = "https://oauth2.googleapis.com/token"
YOUTUBE_REVOKE_URL = "https://oauth2.googleapis.com/revoke"
YOUTUBE_SCOPES = [
    "https://www.googleapis.com/auth/youtube.readonly",
    "https://www.googleapis.com/auth/youtube.force-ssl"
]

X_REDIRECT_URI = "http://localhost:8000/auth/x/callback"
X_AUTHORIZATION_BASE_URL = "https://api.twitter.com/oauth/authorize"
X_REQUEST_TOKEN_URL = "https://api.twitter.com/oauth/request_token"
X_ACCESS_TOKEN_URL = "https://api.twitter.com/oauth/access_token"
X_SCOPES = ["tweet.read", "tweet.write", "users.read"]

# State Management
_oauth_state_store: dict[str, str] = {}
_x_request_tokens: dict[str, dict] = {}

# Helper Functions
def generate_state() -> str:
    """Generates a secure random state token for OAuth."""
    state = secrets.token_urlsafe(32)
    return state

def verify_state(received_state: str, platform: str) -> bool:
    """Verifies the OAuth state token."""
    stored_state = _oauth_state_store.get(platform)
    if not stored_state or stored_state != received_state:
        logger.error(f"Invalid OAuth state for {platform}. Expected: {stored_state}, Received: {received_state}")
        return False
    del _oauth_state_store[platform]
    return True

async def get_twitch_user_info(access_token: str) -> Optional[Dict[str, Any]]:
    """Fetches Twitch user info using the access token."""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                "https://api.twitch.tv/helix/users",
                headers={"Authorization": f"Bearer {access_token}", "Client-Id": TWITCH_APP_CLIENT_ID}
            )
            response.raise_for_status()
            data = response.json()
            return data["data"][0] if data["data"] else None
        except Exception as e:
            logger.error(f"Error fetching Twitch user info: {e}")
            return None

async def get_youtube_user_info(access_token: str) -> Optional[Dict[str, Any]]:
    """Fetches YouTube user info using the access token."""
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                "https://www.googleapis.com/youtube/v3/channels",
                params={"part": "snippet", "mine": "true"},
                headers={"Authorization": f"Bearer {access_token}"}
            )
            response.raise_for_status()
            data = response.json()
            return data["items"][0] if data["items"] else None
        except Exception as e:
            logger.error(f"Error fetching YouTube user info: {e}")
            return None

async def get_x_user_info(client: tweepy.Client) -> Optional[Dict[str, Any]]:
    """Fetches X user info using the Tweepy client."""
    try:
        user = client.get_me(user_fields=["id", "username"])
        return {
            "id": user.data.id,
            "username": user.data.username
        }
    except Exception as e:
        logger.error(f"Error fetching X user info: {e}")
        return None

# Twitch Auth Endpoints
@router.get("/twitch/login")
async def twitch_login():
    if not TWITCH_APP_CLIENT_ID or not TWITCH_APP_CLIENT_SECRET:
        raise HTTPException(status_code=500, detail="Twitch OAuth configuration missing")
    state = generate_state()
    _oauth_state_store["twitch"] = state
    params = {
        "client_id": TWITCH_APP_CLIENT_ID,
        "redirect_uri": TWITCH_REDIRECT_URI,
        "response_type": "code",
        "scope": " ".join(TWITCH_SCOPES),
        "state": state
    }
    auth_url = f"{TWITCH_AUTHORIZATION_BASE_URL}?{urlencode(params)}"
    logger.info("Redirecting to Twitch OAuth authorization")
    return RedirectResponse(auth_url)

@router.get("/twitch/callback")
async def twitch_callback(
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    scope: Optional[str] = Query(None),
    error: Optional[str] = Query(None),
    error_description: Optional[str] = Query(None)
):
    if error:
        logger.error(f"Twitch OAuth error: {error} - {error_description}")
        error_message = f"{error}: {error_description or 'Unknown error'}"
        return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
    if not code or not state:
        error_message = "Missing code or state parameters"
        return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
    if not verify_state(state, "twitch"):
        error_message = "Invalid state parameter"
        return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
    
    async with httpx.AsyncClient() as client:
        try:
            # Exchange code for tokens with timeout
            token_response = await asyncio.wait_for(
                client.post(
                    TWITCH_TOKEN_URL,
                    data={
                        "client_id": TWITCH_APP_CLIENT_ID,
                        "client_secret": TWITCH_APP_CLIENT_SECRET,
                        "code": code,
                        "grant_type": "authorization_code",
                        "redirect_uri": TWITCH_REDIRECT_URI
                    }
                ),
                timeout=10.0
            )
            token_response.raise_for_status()
            token_data = token_response.json()
            
            # Validate token
            validate_response = await asyncio.wait_for(
                client.get(
                    TWITCH_VALIDATE_URL,
                    headers={"Authorization": f"OAuth {token_data['access_token']}"}
                ),
                timeout=10.0
            )
            validate_response.raise_for_status()
            
            # Fetch user info
            user_info = await get_twitch_user_info(token_data["access_token"])
            if not user_info:
                raise HTTPException(status_code=500, detail="Failed to fetch Twitch user info")
            
            # Handle scope (string or list)
            scope_list = token_data.get("scope", [])
            if isinstance(scope_list, str):
                scope_list = scope_list.split()
            elif not isinstance(scope_list, list):
                raise ValueError(f"Unexpected scope type: {type(scope_list)}")
            
            # Save tokens and user info in background
            asyncio.create_task(save_tokens("twitch", {
                "access_token": token_data["access_token"],
                "refresh_token": token_data.get("refresh_token"),
                "expires_in": token_data["expires_in"],
                "scope": scope_list,
                "user_id": user_info["id"],
                "user_login": user_info["login"]
            }))
            
            logger.info(f"Twitch OAuth successful for user: {user_info['login']}")
            return RedirectResponse("/?auth_success=twitch")
        except (httpx.HTTPStatusError, asyncio.TimeoutError) as e:
            logger.error(f"Twitch OAuth token exchange failed: {str(e)}")
            error_message = f"Token exchange failed: {str(e)}"
            return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")
        except Exception as e:
            logger.error(f"Unexpected error in Twitch OAuth callback: {e}")
            error_message = f"Unexpected error: {str(e)}"
            return RedirectResponse(f"/?auth_error=twitch&message={urlencode({'error': error_message})}")

@router.post("/twitch/logout", status_code=200)
async def twitch_logout():
    tokens = await load_tokens("twitch")
    if tokens and tokens.get("access_token"):
        async with httpx.AsyncClient() as client:
            try:
                await client.post(
                    TWITCH_REVOKE_URL,
                    data={"client_id": TWITCH_APP_CLIENT_ID, "token": tokens["access_token"]}
                )
                logger.info("Twitch token revoked successfully")
            except Exception as e:
                logger.error(f"Error revoking Twitch token: {e}")
    await clear_tokens("twitch")
    event_bus.publish(ServiceControl(service_name="twitch", command="restart"))
    return {"message": "Twitch logged out successfully"}

# YouTube Auth Endpoints
@router.get("/youtube/login")
async def youtube_login():
    if not YOUTUBE_APP_CLIENT_ID or not YOUTUBE_APP_CLIENT_SECRET:
        raise HTTPException(status_code=500, detail="YouTube OAuth configuration missing")
    state = generate_state()
    _oauth_state_store["youtube"] = state
    params = {
        "client_id": YOUTUBE_APP_CLIENT_ID,
        "redirect_uri": YOUTUBE_REDIRECT_URI,
        "response_type": "code",
        "scope": " ".join(YOUTUBE_SCOPES),
        "state": state,
        "access_type": "offline",
        "prompt": "consent"
    }
    auth_url = f"{YOUTUBE_AUTHORIZATION_BASE_URL}?{urlencode(params)}"
    logger.info("Redirecting to YouTube OAuth authorization")
    return RedirectResponse(auth_url)

@router.get("/youtube/callback")
async def youtube_callback(
    code: Optional[str] = Query(None),
    state: Optional[str] = Query(None),
    scope: Optional[str] = Query(None),
    error: Optional[str] = Query(None)
):
    if error:
        logger.error(f"YouTube OAuth error: {error}")
        error_message = f"{error}"
        return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
    if not code or not state:
        error_message = "Missing code or state parameters"
        return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
    if not verify_state(state, "youtube"):
        error_message = "Invalid state parameter"
        return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
    
    async with httpx.AsyncClient() as client:
        try:
            # Exchange code for tokens with timeout
            token_response = await asyncio.wait_for(
                client.post(
                    YOUTUBE_TOKEN_URL,
                    data={
                        "client_id": YOUTUBE_APP_CLIENT_ID,
                        "client_secret": YOUTUBE_APP_CLIENT_SECRET,
                        "code": code,
                        "grant_type": "authorization_code",
                        "redirect_uri": YOUTUBE_REDIRECT_URI
                    }
                ),
                timeout=10.0
            )
            token_response.raise_for_status()
            token_data = token_response.json()
            
            # Fetch user info with timeout
            user_info = await asyncio.wait_for(
                get_youtube_user_info(token_data["access_token"]),
                timeout=10.0
            )
            if not user_info:
                raise HTTPException(status_code=500, detail="Failed to fetch YouTube user info")
            
            # Save tokens and user info in background
            asyncio.create_task(save_tokens("youtube", {
                "access_token": token_data["access_token"],
                "refresh_token": token_data.get("refresh_token"),
                "expires_in": token_data["expires_in"],
                "scope": token_data["scope"].split(),
                "user_id": user_info["id"],
                "user_login": user_info["snippet"]["title"]
            }))
            
            logger.info(f"YouTube OAuth successful for user: {user_info['snippet']['title']}")
            return RedirectResponse("/?auth_success=youtube")
        except (httpx.HTTPStatusError, asyncio.TimeoutError) as e:
            logger.error(f"YouTube OAuth token exchange failed: {str(e)}")
            error_message = f"Token exchange failed: {str(e)}"
            return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")
        except Exception as e:
            logger.error(f"Unexpected error in YouTube OAuth callback: {e}")
            error_message = f"Unexpected error: {str(e)}"
            return RedirectResponse(f"/?auth_error=youtube&message={urlencode({'error': error_message})}")

@router.post("/youtube/logout", status_code=200)
async def youtube_logout():
    tokens = await load_tokens("youtube")
    if tokens and tokens.get("access_token"):
        async with httpx.AsyncClient() as client:
            try:
                await client.post(
                    YOUTUBE_REVOKE_URL,
                    data={"token": tokens["access_token"]}
                )
                logger.info("YouTube token revoked successfully")
            except Exception as e:
                logger.error(f"Error revoking YouTube token: {e}")
    await clear_tokens("youtube")
    event_bus.publish(ServiceControl(service_name="youtube", command="restart"))
    return {"message": "YouTube logged out successfully"}

# X Auth Endpoints
@router.get("/x/login")
async def x_login():
    if not X_APP_CLIENT_ID or not X_APP_CLIENT_SECRET:
        error_message = "X OAuth configuration missing. Please check X_APP_CLIENT_ID and X_APP_CLIENT_SECRET in your settings."
        logger.error(error_message)
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")
    state = generate_state()
    _oauth_state_store["x"] = state  # Store state for potential future use, though not used in OAuth 1.0a callback
    try:
        auth = tweepy.OAuth1UserHandler(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            callback=X_REDIRECT_URI
        )
        auth_url = auth.get_authorization_url()
        _x_request_tokens[state] = auth.request_token
        logger.info("Redirecting to X OAuth authorization")
        return RedirectResponse(auth_url)
    except Exception as e:
        logger.error(f"Error initiating X OAuth: {e}")
        error_message = str(e)
        if "Callback URL not approved" in error_message:
            error_message = "Callback URL not approved for this X client application. Please add http://localhost:8000/auth/x/callback to your X app settings."
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")

@router.get("/x/callback")
async def x_callback(
    oauth_token: Optional[str] = Query(None),
    oauth_verifier: Optional[str] = Query(None),
    state: Optional[str] = Query(None)  # Optional for X OAuth 1.0a
):
    if not oauth_token or not oauth_verifier:
        error_message = "Missing oauth_token or oauth_verifier parameters"
        logger.error(error_message)
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")
    
    # For X OAuth 1.0a, state is not returned; verify using oauth_token instead
    stored_request_token = None
    for stored_state, request_token in list(_x_request_tokens.items()):
        if request_token.get("oauth_token") == oauth_token:
            stored_request_token = request_token
            del _x_request_tokens[stored_state]
            break
    if not stored_request_token:
        error_message = "Invalid oauth_token parameter"
        logger.error(error_message)
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")
    
    try:
        auth = tweepy.OAuth1UserHandler(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            callback=X_REDIRECT_URI
        )
        auth.request_token = stored_request_token  # Set the full request token dictionary
        access_token, access_token_secret = auth.get_access_token(oauth_verifier)
        client = tweepy.Client(
            consumer_key=X_APP_CLIENT_ID,
            consumer_secret=X_APP_CLIENT_SECRET,
            access_token=access_token,
            access_token_secret=access_token_secret
        )
        user_info = await get_x_user_info(client)
        if not user_info:
            raise HTTPException(status_code=500, detail="Failed to fetch X user info")
        
        # Save tokens in background
        asyncio.create_task(save_tokens("x", {
            "access_token": access_token,
            "access_token_secret": access_token_secret,
            "user_id": user_info["id"],
            "user_login": user_info["username"]
        }))
        logger.info(f"X OAuth successful for user: {user_info['username']}")
        return RedirectResponse("/?auth_success=x")
    except Exception as e:
        logger.error(f"Unexpected error in X OAuth callback: {e}")
        error_message = f"Unexpected error: {str(e)}"
        return RedirectResponse(f"/?auth_error=x&message={urlencode({'error': error_message})}")

@router.post("/x/logout", status_code=200)
async def x_logout():
    tokens = await load_tokens("x")
    if tokens and tokens.get("access_token"):
        # Note: X does not provide a direct revoke endpoint like Twitch/YouTube
        logger.info("X token clearance simulated (no revoke endpoint)")
    await clear_tokens("x")
    event_bus.publish(ServiceControl(service_name="x", command="restart"))
    return {"message": "X logged out successfully"}
# --- File: app/apis/auth_api.py --- END ---

================================================================================
File: app/core/config.py
================================================================================

import logging
import os
from pathlib import Path
from dotenv import load_dotenv
import json

# Setup logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s [%(levelname)s] - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# Load .env file
env_path = Path('.') / '.env'
if env_path.is_file():
    load_dotenv(dotenv_path=env_path)
    logger.info(f"Loaded .env config from: {env_path}")
else:
    logger.warning(f"No .env file found at {env_path}")

# Initialize settings dictionary
settings = {
    'COMMAND_PREFIX': os.getenv('COMMAND_PREFIX', '!'),
    'WS_HOST': os.getenv('WS_HOST', 'localhost'),
    'WS_PORT': int(os.getenv('WS_PORT', 8000)),
    'LOG_LEVEL': os.getenv('LOG_LEVEL', 'DEBUG'),
    'DATA_DIR': os.getenv('DATA_DIR', 'data'),
    'TWITCH_CHANNELS': os.getenv('TWITCH_CHANNELS', ''),
    'twitch_access_token': os.getenv('TWITCH_ACCESS_TOKEN', ''),
    'youtube_api_key': os.getenv('YOUTUBE_API_KEY', ''),
    'x_api_key': os.getenv('X_API_KEY', ''),
    'x_api_secret': os.getenv('X_API_SECRET', ''),
    'x_access_token': os.getenv('X_ACCESS_TOKEN', ''),
    'x_access_token_secret': os.getenv('X_ACCESS_TOKEN_SECRET', '')
}

# Load settings from settings.json
settings_file = Path(settings['DATA_DIR']) / 'settings.json'
if settings_file.is_file():
    try:
        with settings_file.open('r') as f:
            file_settings = json.load(f)
            settings.update(file_settings)
            logger.info(f"Loaded settings from {settings_file}")
    except Exception as e:
        logger.error(f"Error loading settings from {settings_file}: {e}")
else:
    logger.warning(f"No settings.json found at {settings_file}")

# Create data directory if it doesn't exist
data_dir = Path(settings['DATA_DIR'])
if not data_dir.is_dir():
    data_dir.mkdir(parents=True, exist_ok=True)
    logger.info(f"Data directory verified/created: {data_dir}")
else:
    logger.info(f"Data directory exists: {data_dir}")

# Save settings to settings.json
try:
    with settings_file.open('w') as f:
        json.dump(settings, f, indent=2)
    logger.debug(f"Saved settings to {settings_file}")
except Exception as e:
    logger.error(f"Error saving settings to {settings_file}: {e}")

================================================================================
File: app/core/json_store.py
================================================================================

import json
import logging
import aiofiles
import asyncio
from pathlib import Path
from typing import Dict, Any, Optional, Union
from collections import defaultdict
import time

from app.core.config import DATA_DIR

logger = logging.getLogger(__name__)

_file_locks: Dict[Path, asyncio.Lock] = defaultdict(asyncio.Lock)

async def load_json_data(filename: str, default: Any = None) -> Optional[Any]:
    """Loads data asynchronously from a JSON file in the data directory."""
    filepath = DATA_DIR / f"{filename}.json"
    lock = _file_locks[filepath]
    try:
        async with lock:
            try:
                if not filepath.is_file():
                    if filename in [SETTINGS_FILE, COMMANDS_FILE]:
                        logger.warning(f"File not found: {filepath}. Creating empty file.")
                        await save_json_data(filename, {})
                        return {}
                    logger.warning(f"JSON file not found: {filepath}. Returning default.")
                    return default

                async with aiofiles.open(filepath, mode='r', encoding='utf-8') as f:
                    content = await f.read()
                if not content:
                    logger.warning(f"JSON file is empty: {filepath}. Returning default.")
                    return {} if filename in [SETTINGS_FILE, COMMANDS_FILE] else default
                data = json.loads(content)
                return data
            except (json.JSONDecodeError, Exception) as e:
                logger.error(f"Error processing JSON file {filepath}: {e}", exc_info=True)
                return {} if filename in [SETTINGS_FILE, COMMANDS_FILE] else default
    except asyncio.CancelledError:
        logger.warning(f"Operation cancelled while loading {filename}")
        return default
    except Exception as e:
        logger.error(f"Unexpected error acquiring lock for {filename}: {e}")
        return default

async def save_json_data(filename: str, data: Any) -> bool:
    """Saves data asynchronously to a JSON file in the data directory."""
    filepath = DATA_DIR / f"{filename}.json"
    lock = _file_locks[filepath]
    task_id_part = id(asyncio.current_task()) if asyncio.current_task() else 'notask'
    temp_filepath = filepath.with_suffix(f'.{task_id_part}.tmp')

    try:
        async with lock:
            try:
                # Write with timeout to prevent blocking
                async with aiofiles.open(temp_filepath, mode='w', encoding='utf-8') as f:
                    await asyncio.wait_for(
                        f.write(json.dumps(data, indent=4, ensure_ascii=False)),
                        timeout=5.0
                    )
                temp_filepath.rename(filepath)
                logger.info(f"Successfully saved data to {filepath}")
                return True
            except (asyncio.TimeoutError, Exception) as e:
                logger.error(f"Error saving JSON file {filepath}: {e}", exc_info=True)
                if temp_filepath.exists():
                    try:
                        temp_filepath.unlink()
                        logger.debug(f"Removed temporary file {temp_filepath} after error.")
                    except OSError as unlink_e:
                        logger.error(f"Error removing temporary file {temp_filepath}: {unlink_e}")
                return False
    except asyncio.CancelledError:
        logger.warning(f"Operation cancelled while saving {filename}")
        if temp_filepath.exists():
            try:
                temp_filepath.unlink()
                logger.debug(f"Removed temporary file {temp_filepath} after cancellation.")
            except OSError as unlink_e:
                logger.error(f"Error removing temporary file {temp_filepath}: {unlink_e}")
        return False
    except Exception as e:
        logger.error(f"Unexpected error acquiring lock for {filename}: {e}")
        return False

# Specific Settings and Data File Management
SETTINGS_FILE = "settings"
CHECKINS_FILE = "checkins"
COUNTERS_FILE = "counters"
COMMANDS_FILE = "commands"

async def save_tokens(platform: str, token_data: Dict[str, Any]) -> bool:
    """Saves OAuth token data for a specific platform into settings.json."""
    logger.info(f"Attempting to save tokens for platform: {platform}")
    settings = await load_settings()
    if settings is None:
        settings = {}

    updated_keys = []
    if 'access_token' not in token_data:
        logger.error(f"Missing 'access_token' in token_data for {platform}. Cannot save.")
        return False

    settings[f"{platform}_access_token"] = token_data['access_token']
    updated_keys.append(f"{platform}_access_token")
    if 'refresh_token' in token_data:
        settings[f"{platform}_refresh_token"] = token_data['refresh_token']
        updated_keys.append(f"{platform}_refresh_token")
    if 'expires_in' in token_data:
        try:
            expires_at = time.time() + int(token_data['expires_in']) - 300
            settings[f"{platform}_expires_at"] = expires_at
            updated_keys.append(f"{platform}_expires_at")
        except (ValueError, TypeError) as e:
            logger.error(f"Invalid expires_in value for {platform}: {token_data['expires_in']} - {e}")
    if 'scope' in token_data:
        scopes = token_data['scope']
        if isinstance(scopes, str):
            scopes = scopes.split()
        settings[f"{platform}_scopes"] = list(scopes) if scopes else []
        updated_keys.append(f"{platform}_scopes")

    if 'user_id' in token_data:
        settings[f"{platform}_user_id"] = str(token_data['user_id'])
        updated_keys.append(f"{platform}_user_id")
    if 'user_login' in token_data:
        settings[f"{platform}_user_login"] = token_data['user_login']
        updated_keys.append(f"{platform}_user_login")

    logger.warning(f"Saving OAuth tokens ({', '.join(updated_keys)}) for {platform} to plain JSON file.")
    saved = await save_settings(settings)

    if saved and updated_keys:
        from app.events import SettingsUpdated
        from app.core.event_bus import event_bus
        event_bus.publish(SettingsUpdated(keys_updated=updated_keys))

    return saved

async def load_tokens(platform: str) -> Optional[Dict[str, Any]]:
    """Loads OAuth token data for a specific platform from settings.json."""
    settings = await load_settings()
    if not settings:
        return None

    token_info = {
        "access_token": settings.get(f"{platform}_access_token"),
        "refresh_token": settings.get(f"{platform}_refresh_token"),
        "expires_at": settings.get(f"{platform}_expires_at"),
        "scopes": settings.get(f"{platform}_scopes", []),
        "user_id": settings.get(f"{platform}_user_id"),
        "user_login": settings.get(f"{platform}_user_login"),
    }

    if token_info["access_token"]:
        if token_info["expires_at"] is not None:
            try:
                token_info["expires_at"] = float(token_info["expires_at"])
            except (ValueError, TypeError):
                token_info["expires_at"] = None
        return token_info
    return None

async def clear_tokens(platform: str) -> bool:
    """Removes OAuth token data for a specific platform from settings.json."""
    logger.info(f"Clearing tokens for platform: {platform}")
    settings = await load_settings()
    if settings is None:
        return True

    keys_to_remove = [
        f"{platform}_access_token", f"{platform}_refresh_token",
        f"{platform}_expires_at", f"{platform}_scopes",
        f"{platform}_user_id", f"{platform}_user_login",
        f"{platform.upper()}_TOKEN", f"{platform.upper()}_NICK", f"{platform.upper()}_CLIENT_ID", f"{platform.upper()}_CHANNELS"
    ]
    updated_keys = []
    changed = False
    for key in keys_to_remove:
        if key in settings:
            del settings[key]
            updated_keys.append(key)
            changed = True

    if changed:
        saved = await save_settings(settings)
        if saved and updated_keys:
            from app.events import SettingsUpdated
            from app.core.event_bus import event_bus
            event_bus.publish(SettingsUpdated(keys_updated=updated_keys))
        return saved
    return True

async def load_settings() -> Dict[str, Any]:
    """Loads the main application settings."""
    settings = await load_json_data(SETTINGS_FILE, default={})
    return settings if isinstance(settings, dict) else {}

async def save_settings(settings_data: Dict[str, Any]) -> bool:
    """Saves the main application settings."""
    return await save_json_data(SETTINGS_FILE, settings_data)

async def get_setting(key: str, default: Any = None) -> Any:
    """Convenience function to get a single non-token setting."""
    settings = await load_settings()
    return settings.get(key, default)

async def update_setting(key: str, value: Any) -> bool:
    """Updates a single non-token setting."""
    settings = await load_settings()
    if settings is None:
        settings = {}
    if settings.get(key) != value:
        settings[key] = value
        saved = await save_settings(settings)
        if saved:
            from app.events import SettingsUpdated
            from app.core.event_bus import event_bus
            event_bus.publish(SettingsUpdated(keys_updated=[key]))
        return saved
    return True

async def load_checkins() -> Dict[str, Any]:
    """Loads check-in data."""
    return await load_json_data(CHECKINS_FILE, default={})

async def save_checkins(data: Dict[str, Any]) -> bool:
    """Saves check-in data."""
    return await save_json_data(CHECKINS_FILE, data)

async def load_counters() -> Dict[str, int]:
    """Loads counter data."""
    return await load_json_data(COUNTERS_FILE, default={})

async def save_counters(data: Dict[str, int]) -> bool:
    """Saves counter data."""
    return await save_json_data(COUNTERS_FILE, data)

async def load_commands() -> Dict[str, str]:
    """Loads custom commands."""
    return await load_json_data(COMMANDS_FILE, default={})

async def save_commands(data: Dict[str, str]) -> bool:
    """Saves custom commands."""
    return await save_json_data(COMMANDS_FILE, data)

================================================================================
File: app/core/__init__.py
================================================================================

# --- File: app/core/__init__.py --- START ---
# Makes 'core' a package
# --- File: app/core/__init__.py --- END ---


================================================================================
File: app/core/event_bus.py
================================================================================

import asyncio
import logging
from typing import Any, Callable, Type, Dict, List
from collections import defaultdict

logger = logging.getLogger(__name__)

class EventBus:
    def __init__(self):
        self._handlers: Dict[Type[Any], List[Callable[[Any], None]]] = defaultdict(list)
        self._queue = asyncio.Queue()
        self._running = False
        self._task = None

    def subscribe(self, event_type: Type[Any], handler: Callable[[Any], None]) -> None:
        """Subscribe a handler to an event type."""
        self._handlers[event_type].append(handler)
        logger.debug(f"Handler '{handler.__name__}' subscribed to {event_type.__name__}")

    def unsubscribe(self, event_type: Type[Any], handler: Callable[[Any], None]) -> None:
        """Unsubscribe a handler from an event type."""
        if handler in self._handlers[event_type]:
            self._handlers[event_type].remove(handler)
            logger.debug(f"Handler '{handler.__name__}' unsubscribed from {event_type.__name__}")

    def publish(self, event: Any) -> None:
        """Publish an event to the queue."""
        self._queue.put_nowait(event)
        logger.debug(f"Event {type(event).__name__} published (qsize: {self._queue.qsize()}).")

    async def start(self):
        """Start the event bus processor."""
        if not self._running:
            self._running = True
            self._task = asyncio.create_task(self._process_events(), name="EventBusProcessor")
            logger.info("Event bus processor task started.")

    async def stop(self):
        """Stop the event bus processor."""
        if self._running:
            self._running = False
            if self._task and not self._task.done():
                self._task.cancel()
                try:
                    await self._task
                    logger.info("Event bus processor task stopped.")
                except asyncio.CancelledError:
                    logger.info("Event bus processing task cancelled.")
            self._task = None

    async def _process_events(self):
        """Process events from the queue."""
        logger.info("Event bus started.")
        while self._running:
            try:
                event = await asyncio.wait_for(self._queue.get(), timeout=1.0)
                logger.debug(f"Processing event {type(event).__name__} from queue (qsize: {self._queue.qsize()}).")
                for event_type in self._handlers:
                    if isinstance(event, event_type):
                        for handler in self._handlers[event_type]:
                            try:
                                await handler(event)
                                logger.debug(f"Handler '{handler.__name__}' processed {type(event).__name__}")
                            except Exception as e:
                                logger.error(f"Error in handler '{handler.__name__}' for {type(event).__name__}: {e}", exc_info=True)
                self._queue.task_done()
            except asyncio.TimeoutError:
                continue
            except asyncio.CancelledError:
                logger.info("Event bus processing task cancelled.")
                break
            except Exception as e:
                logger.error(f"Error processing event: {e}", exc_info=True)

event_bus = EventBus()

================================================================================
File: app/services/x_service.py
================================================================================

import asyncio
import logging
import tweepy
from app.core.event_bus import event_bus
from app.events import ChatMessageReceived, PlatformStatusUpdate
from app.core.config import settings

logger = logging.getLogger(__name__)

# Global state
_STATE = {"running": False, "task": None}

async def run_x_service():
    """Main runner for X (Twitter) service to monitor mentions."""
    logger.info("X service runner started.")
    if not all([
        settings.get('x_api_key'),
        settings.get('x_api_secret'),
        settings.get('x_access_token'),
        settings.get('x_access_token_secret')
    ]):
        logger.error("Missing X configuration: API credentials not set.")
        event_bus.publish(PlatformStatusUpdate(
            platform='x',
            status='disabled',
            message="Missing API credentials"
        ))
        return

    try:
        client = tweepy.Client(
            consumer_key=settings['x_api_key'],
            consumer_secret=settings['x_api_secret'],
            access_token=settings['x_access_token'],
            access_token_secret=settings['x_access_token_secret']
        )
        logger.debug("Tweepy client initialized")
    except Exception as e:
        logger.error(f"Failed to initialize Tweepy client: {e}")
        event_bus.publish(PlatformStatusUpdate(
            platform='x',
            status='disabled',
            message="Failed to initialize client"
        ))
        return

    _STATE["running"] = True
    since_id = None
    while _STATE["running"]:
        try:
            mentions = client.get_users_mentions(
                id=client.get_me().data.id,
                since_id=since_id,
                expansions=['author_id'],
                user_fields=['username']
            )
            if mentions.data:
                for tweet in mentions.data:
                    author = mentions.includes['users'][0].username if mentions.includes.get('users') else 'Unknown'
                    logger.debug(f"X mention received: {author}: {tweet.text}")
                    event_bus.publish(ChatMessageReceived(
                        message=InternalChatMessage(
                            platform='x',
                            channel='mentions',
                            user=author,
                            text=tweet.text,
                            timestamp=tweet.created_at.isoformat()
                        )
                    ))
                    since_id = max(since_id or 0, tweet.id)
            event_bus.publish(PlatformStatusUpdate(platform='x', status='connected'))
            await asyncio.sleep(60)  # Poll every minute
        except Exception as e:
            logger.error(f"X service error: {e}", exc_info=True)
            event_bus.publish(PlatformStatusUpdate(
                platform='x',
                status='error',
                message=str(e)
            ))
            await asyncio.sleep(10)

async def stop_x_service():
    """Stops the X service gracefully."""
    logger.info("Stop requested for X service.")
    _STATE["running"] = False
    if _STATE.get("task") and not _STATE["task"].done():
        logger.info("Cancelling X service task...")
        _STATE["task"].cancel()
        try:
            await _STATE["task"]
        except asyncio.CancelledError:
            logger.info("X service task cancellation confirmed.")
    _STATE["task"] = None
    event_bus.publish(PlatformStatusUpdate(platform='x', status='stopped'))

def start_x_service_task() -> asyncio.Task | None:
    """Creates and returns a task for running the X service."""
    global _STATE
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("X service task already running.")
        return _STATE["task"]
    logger.info("Creating background task for X service if configured.")
    if all([
        settings.get('x_api_key'),
        settings.get('x_api_secret'),
        settings.get('x_access_token'),
        settings.get('x_access_token_secret')
    ]):
        _STATE["task"] = asyncio.create_task(run_x_service(), name="XServiceRunner")
        return _STATE["task"]
    else:
        logger.warning("X service not started due to missing configuration.")
        event_bus.publish(PlatformStatusUpdate(platform='x', status='disabled', message="Missing configuration"))
        return None

================================================================================
File: app/services/streamer_command_handler.py
================================================================================

# --- File: app/services/streamer_command_handler.py --- START ---
import logging
from app.core.event_bus import event_bus
from app.events import CommandDetected, BotResponseToSend, BotResponse

logger = logging.getLogger(__name__)

async def handle_streamer_command(event: CommandDetected):
    """Handles commands issued by the streamer."""
    if event.source_message.platform != "dashboard":
        return
    
    command = event.command
    source = event.source_message
    logger.info(f"Streamer command detected: !{command}")
    
    response_text = None
    if command == "announce":
        message = " ".join(event.args) if event.args else "Hello everyone!"
        response_text = f"Announcement: {message}"
        # Broadcast to all platforms
        platforms = ["twitch", "youtube", "x", "whatnot"]
        for platform in platforms:
            event_bus.publish(BotResponseToSend(
                response=BotResponse(
                    platform=platform,
                    channel=source.channel,
                    text=response_text
                )
            ))
    
    elif command == "status":
        response_text = "Bot is running! Check the dashboard for platform statuses."
        event_bus.publish(BotResponseToSend(
            response=BotResponse(
                platform="dashboard",
                channel=source.channel,
                text=response_text
            )
        ))

def setup_streamer_command_handler():
    """Sets up event listeners for streamer commands."""
    logger.info("Setting up streamer command handler...")
    event_bus.subscribe(CommandDetected, handle_streamer_command)
# --- File: app/services/streamer_command_handler.py --- END ---


================================================================================
File: app/services/chat_processor.py
================================================================================

import logging
from app.core.event_bus import event_bus
from app.core.json_store import load_json_data, save_json_data
from app.events import ChatMessageReceived
from typing import Dict

logger = logging.getLogger(__name__)

# Command registry
COMMANDS = {
    "ping": lambda msg: "Pong!",
    "socials": lambda msg: "Follow me: twitch.tv/fos_gamers, youtube.com/@fos_gamers, x.com/fos_gamers",
    "lurk": lambda msg: "Thanks for lurking, {}! o/".format(msg.username),
    "hype": lambda msg: "LET'S GO! HYPE HYPE HYPE! {}",
    "checkin": lambda msg: handle_checkin(msg),
    "seen": lambda msg: handle_seen(msg),
    "uptime": lambda msg: "Uptime feature not implemented yet.",
    "commands": lambda msg: "Available commands: !ping, !socials, !lurk, !hype, !checkin, !seen, !uptime, !commands",
    "death": lambda msg: handle_counter(msg, "death"),
    "showcount": lambda msg: handle_showcount(msg)
}

# Cooldowns in seconds
COMMAND_COOLDOWNS = {"ping": 5, "socials": 10, "lurk": 5, "hype": 15, "checkin": 300, "seen": 10}

# In-memory cooldown tracking
cooldowns = {}

async def setup_chat_processor():
    event_bus.subscribe(ChatMessageReceived, handle_chat_message)
    logger.info("Setting up chat processor...")

async def handle_chat_message(event: ChatMessageReceived):
    if event.platform == "streamer_admin":
        await handle_streamer_command(event)
        return
    if event.platform not in ["twitch", "youtube", "x", "whatnot"]:
        return
    if await process_command(event):
        return
    await handle_unknown_command(event)

async def handle_streamer_command(event: ChatMessageReceived):
    if event.message.startswith("!broadcast "):
        event_bus.publish(BroadcastStreamerMessage(message=event.message.replace("!broadcast ", ""), platform="all"))
    else:
        event_bus.publish(ChatMessageReceived(platform=event.platform, username=event.username, message=event.message, timestamp=event.timestamp))

async def process_command(event: ChatMessageReceived):
    for cmd, handler in COMMANDS.items():
        if event.message.startswith(f"!{cmd}"):
            if await check_cooldown(event.username, cmd):
                response = handler(event)
                event_bus.publish(BroadcastStreamerMessage(message=response, platform=event.platform))
                return True
            return False
    return False

async def check_cooldown(username: str, command: str) -> bool:
    key = f"{username}:{command}"
    if key in cooldowns and cooldowns[key] > time.time():
        return False
    cooldowns[key] = time.time() + COMMAND_COOLDOWNS.get(command, 0)
    return True

async def handle_checkin(event: ChatMessageReceived):
    checkins = await load_json_data("checkins")
    checkins[event.username] = {"last_checkin": str(time.time()), "count": checkins.get(event.username, {}).get("count", 0) + 1}
    await save_json_data("checkins", checkins)
    return f"Checked in, {event.username}! Count: {checkins[event.username]['count']}"

async def handle_seen(event: ChatMessageReceived):
    checkins = await load_json_data("checkins")
    last_seen = checkins.get(event.message.replace("!seen ", ""), {}).get("last_checkin", "never")
    return f"{event.message.replace('!seen ', '')} last seen: {last_seen}"

async def handle_counter(event: ChatMessageReceived):
    counters = await load_json_data("counters")
    counter_name = event.message.replace("!death", "").strip() or "death"
    counters[counter_name] = counters.get(counter_name, 0) + 1
    await save_json_data("counters", counters)
    return f"{counter_name} count: {counters[counter_name]}"

async def handle_showcount(event: ChatMessageReceived):
    counters = await load_json_data("counters")
    return "\n".join([f"{k}: {v}" for k, v in counters.items()]) or "No counters yet."

async def handle_unknown_command(event: ChatMessageReceived):
    response = f"Sorry, {event.username}, unknown command! Try !commands for a list."
    event_bus.publish(BroadcastStreamerMessage(message=response, platform=event.platform))

================================================================================
File: app/services/__init__.py
================================================================================

# --- File: app/services/__init__.py --- START ---
# Makes 'services' a package
# --- File: app/services/__init__.py --- END ---


================================================================================
File: app/services/dashboard_service.py
================================================================================

# --- File: app/services/dashboard_service.py --- START ---
import logging
import json
import asyncio
from fastapi import WebSocket, WebSocketDisconnect
from app.core.event_bus import event_bus
from app.events import (
    InternalChatMessage,
    ChatMessageReceived,
    PlatformStatusUpdate,
    LogMessage,
    StreamerInputReceived,
    BotResponseToSend,
    BroadcastStreamerMessage,
)
from app.core.json_store import load_tokens

logger = logging.getLogger(__name__)
_active_websockets: set[WebSocket] = set()

async def broadcast_to_dashboards(data: dict):
    """Broadcasts a message to all connected dashboard WebSockets."""
    if not _active_websockets:
        return
    disconnected = []
    for ws in _active_websockets:
        try:
            await ws.send_json(data)
        except Exception as e:
            logger.error(f"Error broadcasting to dashboard WebSocket: {e}")
            disconnected.append(ws)
    
    for ws in disconnected:
        _active_websockets.discard(ws)

async def handle_chat_message(event: ChatMessageReceived):
    """Forwards chat messages to the dashboard."""
    message = event.message
    await broadcast_to_dashboards({
        "type": "chat_message",
        "payload": {
            "platform": message.platform,
            "channel": message.channel,
            "user": message.user,
            "text": message.text,
            "timestamp": message.timestamp
        }
    })

async def handle_status_update(event: PlatformStatusUpdate):
    """Forwards platform status updates to the dashboard."""
    await broadcast_to_dashboards({
        "type": "status_update",
        "payload": {
            "platform": event.platform,
            "status": event.status,
            "message": event.message
        }
    })

async def handle_log_message(event: LogMessage):
    """Forwards log messages to the dashboard."""
    await broadcast_to_dashboards({
        "type": "log_message",
        "payload": {
            "level": event.level,
            "message": event.message,
            "module": event.module
        }
    })

async def handle_bot_response(event: BotResponseToSend):
    """Forwards bot responses to the dashboard for display."""
    response = event.response
    await broadcast_to_dashboards({
        "type": "bot_response",
        "payload": {
            "platform": response.platform,
            "channel": response.channel,
            "text": response.text
        }
    })

async def handle_broadcast_message(event: BroadcastStreamerMessage):
    """Handles streamer broadcasts by sending to all platforms."""
    platforms = ["twitch", "youtube", "x", "whatnot"]
    for platform in platforms:
        tokens = await load_tokens(platform)
        if tokens and tokens.get("access_token"):
            event_bus.publish(BotResponseToSend(
                response=BotResponse(
                    platform=platform,
                    channel=tokens.get("user_login", "default"),
                    text=event.text
                )
            ))

async def handle_dashboard_websocket(websocket: WebSocket):
    """Manages a dashboard WebSocket connection."""
    await websocket.accept()
    _active_websockets.add(websocket)
    logger.info("Dashboard WebSocket connected")
    
    try:
        while True:
            data = await websocket.receive_text()
            try:
                message = json.loads(data)
                msg_type = message.get("type")
                payload = message.get("payload", {})
                
                if msg_type == "streamer_input":
                    event_bus.publish(StreamerInputReceived(text=payload.get("text", "")))
                elif msg_type == "ping":
                    await websocket.send_json({"type": "pong"})
                else:
                    logger.warning(f"Unknown dashboard message type: {msg_type}")
            
            except json.JSONDecodeError:
                logger.error(f"Invalid JSON from dashboard: {data}")
            except Exception as e:
                logger.error(f"Error processing dashboard message: {e}")
    
    except WebSocketDisconnect:
        logger.info("Dashboard WebSocket disconnected")
        _active_websockets.discard(websocket)
    except Exception as e:
        logger.error(f"Unexpected error in dashboard WebSocket: {e}")
        _active_websockets.discard(websocket)

def setup_dashboard_service_listeners():
    """Sets up event listeners for dashboard updates."""
    logger.info("Setting up dashboard service listeners...")
    event_bus.subscribe(ChatMessageReceived, handle_chat_message)
    event_bus.subscribe(PlatformStatusUpdate, handle_status_update)
    event_bus.subscribe(LogMessage, handle_log_message)
    event_bus.subscribe(BotResponseToSend, handle_bot_response)
    event_bus.subscribe(BroadcastStreamerMessage, handle_broadcast_message)
# --- File: app/services/dashboard_service.py --- END ---


================================================================================
File: app/services/chat.py
================================================================================

# --- File: app/services/chat.py --- START ---
import logging
import asyncio
import datetime
import random
from app.core.event_bus import event_bus
from app.events import (
    ChatMessageReceived,
    CommandDetected,
    BotResponse,
    BotResponseToSend,
    StreamerInputReceived,
    BroadcastStreamerMessage,
)
from app.core.config import COMMAND_PREFIX
from app.core.json_store import load_checkins, save_checkins, load_commands

logger = logging.getLogger(__name__)

async def handle_chat_message(event: ChatMessageReceived):
    """Processes incoming chat messages and detects commands."""
    message = event.message
    logger.debug(f"Processing chat message from {message.platform}/{message.channel}/{message.user}: {message.text}")
    
    if message.text.startswith(COMMAND_PREFIX):
        parts = message.text[len(COMMAND_PREFIX):].strip().split()
        if parts:
            command = parts[0].lower()
            args = parts[1:]
            event_bus.publish(CommandDetected(
                command=command,
                args=args,
                source_message=message
            ))

async def handle_command(event: CommandDetected):
    """Handles detected commands and triggers appropriate responses."""
    command = event.command
    source = event.source_message
    logger.info(f"Command detected: !{command} from {source.platform}/{source.user}")
    
    response_text = None
    if command == "checkin":
        checkins = await load_checkins()
        user_key = f"{source.platform}:{source.user}"
        checkins[user_key] = {
            "last_checkin": datetime.datetime.utcnow().isoformat(),
            "platform": source.platform,
            "user": source.user,
            "channel": source.channel
        }
        await save_checkins(checkins)
        response_text = f"@{source.user} checked in successfully!"
    
    elif command == "ping":
        response_text = "Pong!"
    
    elif command == "roll":
        die = event.args[0].lower() if event.args else "d20"
        if die.startswith("d") and die[1:].isdigit():
            sides = int(die[1:])
            if sides > 0:
                result = random.randint(1, sides)
                response_text = f"@{source.user} rolled a {result} on a {die}!"
            else:
                response_text = "Invalid die: Must have at least 1 side."
        else:
            response_text = "Usage: !roll dN (e.g., !roll d20)"
    
    else:
        # Check custom commands
        commands = await load_commands()
        if command in commands:
            response_text = commands[command].replace("{user}", f"@{source.user}")
    
    if response_text:
        event_bus.publish(BotResponseToSend(
            response=BotResponse(
                platform=source.platform,
                channel=source.channel,
                text=response_text
            )
        ))

async def handle_streamer_input(event: StreamerInputReceived):
    """Handles input from the streamer via the dashboard."""
    logger.info(f"Streamer input received: {event.text}")
    if event.text.startswith(COMMAND_PREFIX):
        parts = event.text[len(COMMAND_PREFIX):].strip().split()
        if parts:
            command = parts[0].lower()
            args = parts[1:]
            event_bus.publish(CommandDetected(
                command=command,
                args=args,
                source_message=InternalChatMessage(
                    platform="dashboard",
                    channel="all",
                    user="streamer",
                    text=event.text,
                    timestamp=datetime.datetime.utcnow().isoformat()
                )
            ))
    else:
        event_bus.publish(BroadcastStreamerMessage(text=event.text))

def setup_chat_processor():
    """Sets up event listeners for chat processing."""
    logger.info("Setting up chat processor...")
    event_bus.subscribe(ChatMessageReceived, handle_chat_message)
    event_bus.subscribe(CommandDetected, handle_command)
    event_bus.subscribe(StreamerInputReceived, handle_streamer_input)
# --- File: app/services/chat.py --- END ---


================================================================================
File: app/services/youtube_service.py
================================================================================

import asyncio
import logging
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from app.core.event_bus import event_bus
from app.events import ChatMessageReceived, PlatformStatusUpdate
from app.core.config import settings

logger = logging.getLogger(__name__)

# Global state
_STATE = {"running": False, "task": None}

async def run_youtube_service():
    """Main runner for YouTube live chat service."""
    logger.info("YouTube service runner started.")
    youtube = None
    try:
        youtube = build('youtube', 'v3', developerKey=settings.get('youtube_api_key'))
        logger.debug("YouTube API client initialized")
    except Exception as e:
        logger.error(f"Failed to initialize YouTube API client: {e}")
        event_bus.publish(PlatformStatusUpdate(
            platform='youtube',
            status='disabled',
            message="Failed to initialize API client"
        ))
        return

    _STATE["running"] = True
    while _STATE["running"]:
        try:
            # Find active live broadcast
            request = youtube.liveBroadcasts().list(
                part="id,snippet",
                broadcastStatus="active",
                maxResults=1
            )
            response = await asyncio.get_event_loop().run_in_executor(None, request.execute)
            if not response.get('items'):
                logger.warning("No active YouTube live broadcasts found.")
                event_bus.publish(PlatformStatusUpdate(
                    platform='youtube',
                    status='waiting',
                    message="No active live broadcasts"
                ))
                await asyncio.sleep(60)
                continue

            live_broadcast = response['items'][0]
            live_chat_id = live_broadcast['snippet']['liveChatId']
            logger.info(f"Found active live chat: {live_chat_id}")
            event_bus.publish(PlatformStatusUpdate(platform='youtube', status='connected'))

            # Poll live chat messages
            next_page_token = None
            while _STATE["running"]:
                request = youtube.liveChatMessages().list(
                    liveChatId=live_chat_id,
                    part="snippet,authorDetails",
                    pageToken=next_page_token
                )
                response = await asyncio.get_event_loop().run_in_executor(None, request.execute)
                for item in response.get('items', []):
                    snippet = item['snippet']
                    author = item['authorDetails']
                    event_bus.publish(ChatMessageReceived(
                        message=InternalChatMessage(
                            platform='youtube',
                            channel=author.get('channelId', 'unknown'),
                            user=author.get('displayName', 'Unknown'),
                            text=snippet.get('displayMessage', ''),
                            timestamp=snippet.get('publishedAt', '')
                        )
                    ))
                    logger.debug(f"YouTube message: {author.get('displayName')}: {snippet.get('displayMessage')}")
                next_page_token = response.get('nextPageToken')
                polling_interval = response.get('pollingIntervalMillis', 5000) / 1000
                await asyncio.sleep(polling_interval)
        except HttpError as e:
            logger.error(f"YouTube API error: {e}")
            event_bus.publish(PlatformStatusUpdate(
                platform='youtube',
                status='error',
                message=str(e)
            ))
            await asyncio.sleep(10)
        except Exception as e:
            logger.error(f"YouTube service error: {e}", exc_info=True)
            event_bus.publish(PlatformStatusUpdate(
                platform='youtube',
                status='error',
                message=str(e)
            ))
            await asyncio.sleep(10)

async def stop_youtube_service():
    """Stops the YouTube service gracefully."""
    logger.info("Stop requested for YouTube service.")
    _STATE["running"] = False
    if _STATE.get("task") and not _STATE["task"].done():
        logger.info("Cancelling YouTube service task...")
        _STATE["task"].cancel()
        try:
            await _STATE["task"]
        except asyncio.CancelledError:
            logger.info("YouTube service task cancellation confirmed.")
    _STATE["task"] = None
    event_bus.publish(PlatformStatusUpdate(platform='youtube', status='stopped'))

def start_youtube_service_task() -> asyncio.Task | None:
    """Creates and returns a task for running the YouTube service."""
    global _STATE
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("YouTube service task already running.")
        return _STATE["task"]
    logger.info("Creating background task for YouTube service if configured.")
    if settings.get('youtube_api_key'):
        _STATE["task"] = asyncio.create_task(run_youtube_service(), name="YouTubeServiceRunner")
        return _STATE["task"]
    else:
        logger.warning("YouTube service not started due to missing API key.")
        event_bus.publish(PlatformStatusUpdate(platform='youtube', status='disabled', message="Missing API key"))
        return None

================================================================================
File: app/services/twitch_service.py
================================================================================

import asyncio
import logging
from typing import Optional
from twitchio.ext import commands
from app.core.event_bus import event_bus
from app.events import ChatMessageReceived, PlatformStatusUpdate, ServiceControl
from app.core.config import settings

logger = logging.getLogger(__name__)

# Global state
_STATE = {"running": False, "bot": None, "task": None}

class TwitchBot(commands.Bot):
    def __init__(self):
        super().__init__(
            token=settings.get('twitch_access_token', ''),
            prefix=settings.get('COMMAND_PREFIX', '!'),
            initial_channels=[settings.get('TWITCH_CHANNELS', '')]
        )

    async def event_ready(self):
        logger.info("Twitch bot connected and ready.")
        event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connected'))

    async def event_message(self, message):
        if message.author is None:
            return
        logger.debug(f"Twitch message received: {message.author.name}: {message.content}")
        event_bus.publish(ChatMessageReceived(
            message=InternalChatMessage(
                platform='twitch',
                channel=message.channel.name,
                user=message.author.name,
                text=message.content,
                timestamp=message.timestamp.isoformat()
            )
        ))
        await self.handle_commands(message)

    @commands.command(name='ping')
    async def ping(self, ctx):
        await ctx.send('Pong!')
        logger.debug(f"Twitch ping command executed by {ctx.author.name}")

async def run_twitch_bot():
    """Main runner for Twitch bot service."""
    logger.info("Twitch bot runner started.")
    if not settings.get('twitch_access_token') or not settings.get('TWITCH_CHANNELS'):
        logger.error("Missing Twitch configuration: access token or channels not set.")
        event_bus.publish(PlatformStatusUpdate(
            platform='twitch',
            status='disabled',
            message="Missing access token or channels"
        ))
        return

    _STATE["bot"] = TwitchBot()
    _STATE["running"] = True
    while _STATE["running"]:
        try:
            await _STATE["bot"].start()
        except Exception as e:
            logger.error(f"Twitch bot failed: {e}", exc_info=True)
            event_bus.publish(PlatformStatusUpdate(
                platform='twitch',
                status='error',
                message=str(e)
            ))
            if _STATE["running"]:
                await asyncio.sleep(10)

async def stop_twitch_bot():
    """Stops the Twitch bot service gracefully."""
    logger.info("Stop requested for Twitch bot.")
    _STATE["running"] = False
    if _STATE["bot"]:
        try:
            await _STATE["bot"].close()
            logger.info("Twitch bot stopped successfully.")
        except Exception as e:
            logger.error(f"Error stopping Twitch bot: {e}")
    if _STATE.get("task") and not _STATE["task"].done():
        logger.info("Cancelling Twitch bot task...")
        _STATE["task"].cancel()
        try:
            await _STATE["task"]
        except asyncio.CancelledError:
            logger.info("Twitch bot task cancellation confirmed.")
    _STATE["task"] = None
    event_bus.publish(PlatformStatusUpdate(platform='twitch', status='stopped'))

def start_twitch_service_task() -> Optional[asyncio.Task]:
    """Creates and returns a task for running the Twitch bot."""
    global _STATE
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("Twitch bot task already running.")
        return _STATE["task"]
    logger.info("Creating background task for Twitch service if configured.")
    if settings.get('twitch_access_token') and settings.get('TWITCH_CHANNELS'):
        _STATE["task"] = asyncio.create_task(run_twitch_bot(), name="TwitchBotRunner")
        return _STATE["task"]
    else:
        logger.warning("Twitch service not started due to missing configuration.")
        event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disabled', message="Missing configuration"))
        return None

================================================================================
File: app/services/whatnot_bridge.py
================================================================================

import asyncio
import logging
import websockets
from fastapi import WebSocket
from app.core.event_bus import event_bus
from app.events import ChatMessageReceived, PlatformStatusUpdate, ServiceControl, SettingsUpdated
from app.core.config import settings

logger = logging.getLogger(__name__)

# Global state
_STATE = {"running": False, "task": None}
_websockets: set[WebSocket] = set()

async def run_whatnot_bridge():
    """Main runner for Whatnot bridge service."""
    logger.info("Whatnot bridge runner started.")
    WS_HOST = settings.get('WS_HOST', 'localhost')
    WS_PORT = settings.get('WS_PORT', 8000)
    if not WS_HOST or not WS_PORT:
        logger.error("Missing WebSocket configuration: WS_HOST or WS_PORT not set.")
        event_bus.publish(PlatformStatusUpdate(
            platform='whatnot',
            status='disabled',
            message="Missing WebSocket host or port"
        ))
        return

    _STATE["running"] = True
    while _STATE["running"]:
        try:
            async with websockets.serve(handle_websocket, WS_HOST, WS_PORT, ping_interval=30, ping_timeout=30):
                logger.info(f"Whatnot WebSocket server running on ws://{WS_HOST}:{WS_PORT}/ws/whatnot")
                event_bus.publish(PlatformStatusUpdate(platform='whatnot', status='connected'))
                await asyncio.Future()  # Run until cancelled
        except Exception as e:
            logger.error(f"Whatnot WebSocket server failed: {e}", exc_info=True)
            event_bus.publish(PlatformStatusUpdate(
                platform='whatnot',
                status='error',
                message=str(e)
            ))
            if _STATE["running"]:
                await asyncio.sleep(10)

async def handle_websocket(websocket: WebSocket):
    """Handles WebSocket connections for Whatnot bridge."""
    try:
        await websocket.accept()
        _websockets.add(websocket)
        logger.info("Whatnot WebSocket client connected")
        async def handle_message(message: ChatMessageReceived):
            if message.message.platform == 'whatnot':
                try:
                    await websocket.send_json({
                        'type': 'chat_message',
                        'payload': {
                            'username': message.message.user,
                            'message': message.message.text,
                            'platform': message.message.platform
                        }
                    })
                    logger.debug(f"Sent Whatnot message to client: {message.message.text}")
                except Exception as e:
                    logger.error(f"Error sending message to Whatnot client: {e}")

        event_bus.subscribe(ChatMessageReceived, handle_message)
        try:
            while True:
                data = await websocket.receive_json()
                logger.debug(f"Received Whatnot WebSocket message: {data}")
                if data.get('type') == 'chat_message':
                    event_bus.publish(ChatMessageReceived(
                        message=InternalChatMessage(
                            platform='whatnot',
                            channel='unknown',
                            user=data['payload']['username'],
                            text=data['payload']['message'],
                            timestamp=datetime.now().isoformat()
                        )
                    ))
                elif data.get('type') == 'queryStatus':
                    await websocket.send_json({'type': 'pong'})
                elif data.get('type') == 'debug':
                    logger.debug(f"Extension debug: {data.get('message')}")
        except websockets.exceptions.ConnectionClosed:
            logger.info("Whatnot WebSocket client disconnected")
        finally:
            event_bus.unsubscribe(ChatMessageReceived, handle_message)
            _websockets.remove(websocket)
    except Exception as e:
        logger.error(f"Whatnot WebSocket handler error: {e}", exc_info=True)

async def stop_whatnot_bridge():
    """Stops the Whatnot bridge service gracefully."""
    logger.info("Stop requested for Whatnot bridge.")
    _STATE["running"] = False
    for websocket in list(_websockets):
        try:
            await websocket.close()
            _websockets.remove(websocket)
        except Exception as e:
            logger.error(f"Error closing Whatnot WebSocket: {e}")
    if _STATE.get("task") and not _STATE["task"].done():
        logger.info("Cancelling Whatnot bridge task...")
        _STATE["task"].cancel()
        try:
            await _STATE["task"]
        except asyncio.CancelledError:
            logger.info("Whatnot bridge task cancellation confirmed.")
    _STATE["task"] = None
    logger.info("Whatnot bridge stopped.")
    event_bus.publish(PlatformStatusUpdate(platform='whatnot', status='stopped'))

async def handle_settings_update(event: SettingsUpdated):
    """Handles settings updates that affect Whatnot bridge."""
    relevant_keys = {"WS_HOST", "WS_PORT"}
    if any(key in relevant_keys for key in event.keys_updated):
        logger.info("Whatnot-relevant settings updated, requesting service restart...")
        event_bus.publish(ServiceControl(service_name="whatnot", command="restart"))

def start_whatnot_bridge_task() -> asyncio.Task | None:
    """Creates and returns a task for running the Whatnot bridge."""
    global _STATE
    if _STATE.get("task") and not _STATE["task"].done():
        logger.warning("Whatnot bridge task already running.")
        return _STATE["task"]
    logger.info("Creating background task for Whatnot bridge if WebSocket is configured.")
    if settings.get('WS_HOST') and settings.get('WS_PORT'):
        _STATE["task"] = asyncio.create_task(run_whatnot_bridge(), name="WhatnotBridgeRunner")
        event_bus.subscribe(SettingsUpdated, handle_settings_update)
        return _STATE["task"]
    else:
        logger.warning("Whatnot bridge not started due to missing WebSocket configuration.")
        event_bus.publish(PlatformStatusUpdate(platform='whatnot', status='disabled', message="Missing WebSocket configuration"))
        return None

================================================================================
File: static/index.html
================================================================================

<!-- File: static/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FoSBot Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
        #header { background: #333; color: white; padding: 10px; text-align: center; }
        #tab-buttons { margin: 10px 0; }
        .tab-button { padding: 8px 16px; margin-right: 5px; background: #ddd; border: none; cursor: pointer; }
        .tab-button.active { background: #007bff; color: white; }
        #main-content { display: flex; }
        #content-area { flex: 3; background: white; padding: 15px; border-radius: 5px; }
        #sidebar { flex: 1; margin-left: 10px; background: #e9ecef; padding: 10px; border-radius: 5px; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        #chat-output { max-height: 500px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; }
        .chat-message { margin: 5px 0; }
        .chat-message-whatnot { color: #ff4500; }
        .chat-message-youtube { color: #ff0000; }
        .chat-message-twitch { color: #9146ff; }
        .chat-message-x { color: #1da1f2; }
        #streamer-input { width: 100%; padding: 5px; margin-top: 10px; }
        #sendButton, #clearButton { margin-top: 5px; padding: 5px 10px; }
        #status-indicators div { margin: 5px 0; }
        .status-light { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .status-light.connected { background: green; }
        .status-light.disconnected { background: red; }
        .status-light.error { background: orange; }
        .status-light.disabled { background: gray; }
        .settings-section { margin-bottom: 20px; }
        .settings-section h3 { margin-bottom: 10px; }
        .auth-status { display: inline-block; margin-right: 10px; }
        .control-button { margin: 5px; padding: 5px 10px; }
        .download-link { color: #007bff; text-decoration: underline; cursor: pointer; }
        .instructions { margin-top: 10px; font-size: 14px; }
        #commands-table { width: 100%; border-collapse: collapse; }
        #commands-table th, #commands-table td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        #commands-table th { background: #f4f4f4; }
        .command-action { cursor: pointer; color: #007bff; }
        #add-command-form { margin-top: 10px; }
        #add-command-form input { margin: 5px 0; padding: 5px; width: 100%; }
        #csv-upload { margin-top: 10px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); }
        .modal-content { background: white; margin: 15% auto; padding: 20px; width: 50%; border-radius: 5px; }
        .close { float: right; cursor: pointer; font-size: 20px; }
    </style>
</head>
<body>
    <div id="header">
        <h1>FoSBot Dashboard</h1>
    </div>
    <div id="tab-buttons">
        <button class="tab-button active" data-tab="chat">Chat</button>
        <button class="tab-button" data-tab="commands">Commands</button>
        <button class="tab-button" data-tab="settings">Settings</button>
    </div>
    <div id="main-content">
        <div id="content-area">
            <!-- Chat Tab -->
            <div id="chat-container" class="tab-content active" data-tab-content="chat">
                <h2>Live Chat</h2>
                <div id="chat-output"></div>
                <input type="text" id="streamerInput" placeholder="Type a message or command...">
                <button id="sendButton">Send</button>
                <button id="clearButton">Clear Chat</button>
            </div>

            <!-- Commands Tab -->
            <div id="commands-container" class="tab-content" data-tab-content="commands">
                <h2>Manage Commands</h2>
                <p>Create custom commands like <code>!roll</code> for your streams!</p>
                <table id="commands-table">
                    <thead>
                        <tr>
                            <th>Command</th>
                            <th>Response</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <form id="add-command-form">
                    <input type="text" id="command-name" placeholder="Command (e.g., roll)" required>
                    <input type="text" id="command-response" placeholder="Response (e.g., Rolled a {user} d20!)" required>
                    <button type="submit">Add Command</button>
                </form>
                <div id="csv-upload">
                    <label for="csv-file">Upload CSV (format: command,response):</label>
                    <input type="file" id="csv-file" accept=".csv">
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings-container" class="tab-content" data-tab-content="settings">
                <h2>Application Settings</h2>
                <p id="settings-status"></p>

                <!-- Whatnot Section -->
                <div class="settings-section">
                    <h3>Whatnot Integration</h3>
                    <div id="whatnot-status-area">
                        <span class="auth-status">Status: Loading...</span>
                    </div>
                    <p>
                        <a href="/whatnot_extension.zip" class="download-link" download>Download Whatnot Extension</a>
                        <button class="control-button" onclick="openWhatnotGuide()">Guided Setup</button>
                    </p>
                    <div class="instructions">
                        <strong>Quick Setup:</strong>
                        <p>Click "Guided Setup" for step-by-step help or download the extension and follow the README!</p>
                    </div>
                </div>

                <!-- YouTube Section -->
                <div class="settings-section">
                    <h3>YouTube Authentication</h3>
                    <div id="youtube-auth-area">
                        <span class="auth-status">Loading...</span>
                        <button class="control-button" data-platform="youtube" data-action="login">Login</button>
                        <button class="control-button" data-platform="youtube" data-action="logout" disabled>Logout</button>
                    </div>
                </div>

                <!-- Twitch Section -->
                <div class="settings-section">
                    <h3>Twitch Authentication</h3>
                    <div id="twitch-auth-area">
                        <span class="auth-status">Loading...</span>
                        <button class="control-button" data-platform="twitch" data-action="login">Login</button>
                        <button class="control-button" data-platform="twitch" data-action="logout" disabled>Logout</button>
                    </div>
                </div>

                <!-- X Section -->
                <div class="settings-section">
                    <h3>X Authentication</h3>
                    <div id="x-auth-area">
                        <span class="auth-status">Loading...</span>
                        <button class="control-button" data-platform="x" data-action="login">Login</button>
                        <button class="control-button" data-platform="x" data-action="logout" disabled>Logout</button>
                    </div>
                </div>

                <!-- App Config Section -->
                <div class="settings-section">
                    <h3>General Settings</h3>
                    <form id="app-settings-form">
                        <label>Command Prefix:</label><br>
                        <input type="text" name="COMMAND_PREFIX" maxlength="5" value="!"><br>
                        <label>Log Level:</label><br>
                        <select name="LOG_LEVEL">
                            <option value="DEBUG">DEBUG</option>
                            <option value="INFO">INFO</option>
                            <option value="WARNING">WARNING</option>
                            <option value="ERROR">ERROR</option>
                            <option value="CRITICAL">CRITICAL</option>
                        </select><br>
                        <label>Extra Twitch Channels (optional, comma-separated):</label><br>
                        <input type="text" name="TWITCH_CHANNELS" placeholder="channel1,channel2"><br>
                        <button type="submit">Save</button>
                    </form>
                </div>

                <!-- Service Control Section -->
                <div class="settings-section">
                    <h3>Service Control</h3>
                    <div>
                        <button class="control-button" data-service="whatnot" data-command="start">Start Whatnot</button>
                        <button class="control-button" data-service="whatnot" data-command="stop">Stop Whatnot</button>
                        <button class="control-button" data-service="whatnot" data-command="restart">Restart Whatnot</button>
                    </div>
                    <div>
                        <button class="control-button" data-service="youtube" data-command="start">Start YouTube</button>
                        <button class="control-button" data-service="youtube" data-command="stop">Stop YouTube</button>
                        <button class="control-button" data-service="youtube" data-command="restart">Restart YouTube</button>
                    </div>
                    <div>
                        <button class="control-button" data-service="twitch" data-command="start">Start Twitch</button>
                        <button class="control-button" data-service="twitch" data-command="stop">Stop Twitch</button>
                        <button class="control-button" data-service="twitch" data-command="restart">Restart Twitch</button>
                    </div>
                    <div>
                        <button class="control-button" data-service="x" data-command="start">Start X</button>
                        <button class="control-button" data-service="x" data-command="stop">Stop X</button>
                        <button class="control-button" data-service="x" data-command="restart">Restart X</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div id="sidebar">
            <h3>Status</h3>
            <div id="status-indicators">
                <div id="status-ws"><span class="status-light"></span><span class="status-text">WebSocket: Unknown</span></div>
                <div id="status-whatnot"><span class="status-light"></span><span class="status-text">Whatnot: Unknown</span></div>
                <div id="status-youtube"><span class="status-light"></span><span class="status-text">YouTube: Unknown</span></div>
                <div id="status-twitch"><span class="status-light"></span><span class="status-text">Twitch: Unknown</span></div>
                <div id="status-x"><span class="status-light"></span><span class="status-text">X: Unknown</span></div>
            </div>
            <h3>Logs</h3>
            <div id="log-output" style="max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;"></div>
        </div>
    </div>

    <!-- Whatnot Setup Modal -->
    <div id="whatnot-guide-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeWhatnotGuide()">×</span>
            <h3>Whatnot Extension Setup</h3>
            <ol>
                <li>Click <a href="/whatnot_extension.zip" download>"Download Whatnot Extension"</a> above.</li>
                <li>Unzip to a folder (e.g., <code>~/FoSBot_Whatnot</code>).</li>
                <li>In Chrome, go to <code>chrome://extensions/</code>, enable "Developer mode," click "Load unpacked," select the folder.</li>
                <li>On a Whatnot stream, click the extension icon, enable "Select Mode," click chat elements, save.</li>
            </ol>
            <p><strong>Watch:</strong> <a href="https://patreon.com/yourvideo" target="_blank">Setup Video</a></p>
            <button onclick="closeWhatnotGuide()">Close</button>
        </div>
    </div>

    <script src="main.js"></script>
</body>
</html>
<!-- File: static/index.html -->


================================================================================
File: static/main.js
================================================================================

// Main dashboard script
document.addEventListener('DOMContentLoaded', () => {
    const statusIndicators = {
        twitch: document.getElementById('twitch-status'),
        youtube: document.getElementById('youtube-status'),
        x: document.getElementById('x-status'),
        whatnot: document.getElementById('whatnot-status')
    };

    const ws = new WebSocket('ws://localhost:8000/ws/dashboard');
    ws.onopen = () => {
        console.log('Dashboard WebSocket connected');
    };
    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'status_update') {
                const { platform, status } = data.payload;
                const indicator = statusIndicators[platform];
                if (indicator) {
                    indicator.style.backgroundColor = status === 'connected' ? 'green' : 'red';
                    console.log(`Status update: ${platform} is ${status}`);
                }
            }
        } catch (e) {
            console.error('Error parsing dashboard WebSocket message:', e);
        }
    };
    ws.onclose = () => {
        console.log('Dashboard WebSocket disconnected, retrying in 5s');
        setTimeout(() => {
            location.reload();
        }, 5000);
    };

    // Fetch initial settings and commands
    fetch('/api/settings').then(res => res.json()).then(data => {
        document.getElementById('command-prefix').value = data.COMMAND_PREFIX;
        document.getElementById('log-level').value = data.LOG_LEVEL;
        document.getElementById('twitch-channels').value = data.TWITCH_CHANNELS;
        updateAuthStatus(data.twitch_auth_status, 'twitch');
        updateAuthStatus(data.youtube_auth_status, 'youtube');
        updateAuthStatus(data.x_auth_status, 'x');
    });

    fetch('/api/commands').then(res => res.json()).then(commands => {
        const commandList = document.getElementById('command-list');
        Object.entries(commands).forEach(([name, response]) => {
            const li = document.createElement('li');
            li.textContent = `!${name}: ${response}`;
            commandList.appendChild(li);
        });
    });

    function updateAuthStatus(auth, platform) {
        const statusEl = document.getElementById(`${platform}-auth-status`);
        if (auth.logged_in) {
            statusEl.textContent = `Logged in as ${auth.user_login}`;
            statusEl.style.color = 'green';
        } else {
            statusEl.textContent = 'Not logged in';
            statusEl.style.color = 'red';
        }
    }

    // Control buttons
    document.querySelectorAll('.control-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const [platform, action] = btn.id.split('-');
            fetch(`/api/control/${platform}/${action}`, { method: 'POST' })
                .then(res => res.json())
                .then(data => console.log(`${platform} ${action}:`, data))
                .catch(err => console.error('Control error:', err));
        });
    });
});

================================================================================
File: whatnot_extension/popup.js
================================================================================

document.addEventListener('DOMContentLoaded', () => {
    console.log('Popup initialized');
    const setupModeCheckbox = document.getElementById('setupMode');
    const testButton = document.getElementById('testButton');
    const statusDiv = document.getElementById('status');
    const modeStatusDiv = document.getElementById('modeStatus');
    let ws = null;

    // Initialize WebSocket for debug logging
    function initDebugWebSocket() {
        ws = new WebSocket('ws://localhost:8000/ws/debug');
        ws.onopen = () => {
            console.log('Debug WebSocket connected');
            sendDebugLog('Popup WebSocket connected');
        };
        ws.onclose = () => {
            console.log('Debug WebSocket disconnected, retrying in 5s');
            setTimeout(initDebugWebSocket, 5000);
        };
        ws.onerror = (error) => {
            console.error('Debug WebSocket error:', error);
        };
    }
    initDebugWebSocket();

    function sendDebugLog(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'debug', message }));
        }
    }

    // Load saved settings
    chrome.storage.local.get(['setupMode'], (data) => {
        const isSetupMode = data.setupMode || false;
        setupModeCheckbox.checked = isSetupMode;
        updateModeStatus(isSetupMode);
        console.log('Loaded settings:', data);
        sendDebugLog(`Popup loaded settings: ${JSON.stringify(data)}`);
        updateConnectionStatus();
    });

    // Update setup mode status
    function updateModeStatus(isOn) {
        modeStatusDiv.textContent = `Setup Mode: ${isOn ? 'On' : 'Off'}`;
        modeStatusDiv.style.color = isOn ? 'green' : 'gray';
        sendDebugLog(`Setup mode updated: ${isOn ? 'On' : 'Off'}`);
    }

    // Update connection status
    function updateConnectionStatus() {
        chrome.runtime.sendMessage({ type: 'query_status' }, (response) => {
            if (chrome.runtime.lastError) {
                console.error('Status query error:', chrome.runtime.lastError);
                statusDiv.textContent = 'Error: Start the FoSBot app first!';
                statusDiv.className = 'error';
                sendDebugLog(`Status query error: ${chrome.runtime.lastError.message}`);
                setTimeout(updateConnectionStatus, 5000);
                return;
            }
            if (response && response.wsConnected) {
                statusDiv.textContent = 'Connected to FoSBot app';
                statusDiv.className = 'success';
                sendDebugLog('Connected to FoSBot app');
            } else {
                statusDiv.textContent = 'Start the FoSBot app and Whatnot service';
                statusDiv.className = 'error';
                sendDebugLog('Not connected to FoSBot app or Whatnot service');
            }
            setTimeout(updateConnectionStatus, 5000);
        });
    }

    // Toggle setup mode
    setupModeCheckbox.addEventListener('change', () => {
        const isChecked = setupModeCheckbox.checked;
        console.log('Setup Mode toggled:', isChecked);
        sendDebugLog(`Setup Mode toggled: ${isChecked}`);
        chrome.storage.local.set({ setupMode: isChecked }, () => {
            updateModeStatus(isChecked);
            chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
                if (tabs[0] && tabs[0].url.match(/^https:\/\/.*\.whatnot\.com\/.*/)) {
                    console.log('Sending toggle_setup_mode to tab:', tabs[0].id);
                    sendDebugLog(`Sending toggle_setup_mode to tab ${tabs[0].id}`);
                    chrome.tabs.sendMessage(tabs[0].id, {
                        type: 'toggle_setup_mode',
                        payload: { setupMode: isChecked }
                    }, (response) => {
                        if (chrome.runtime.lastError) {
                            console.error('Message error:', chrome.runtime.lastError);
                            statusDiv.textContent = 'Error: Ensure you are on a Whatnot stream page';
                            statusDiv.className = 'error';
                            sendDebugLog(`Message error: ${chrome.runtime.lastError.message}`);
                            setupModeCheckbox.checked = false;
                            chrome.storage.local.set({ setupMode: false });
                        } else {
                            console.log('Toggle setup response:', response);
                            sendDebugLog(`Toggle setup response: ${JSON.stringify(response)}`);
                        }
                    });
                } else {
                    statusDiv.textContent = 'Error: Open a Whatnot stream page first';
                    statusDiv.className = 'error';
                    setupModeCheckbox.checked = false;
                    chrome.storage.local.set({ setupMode: false });
                    sendDebugLog('Setup mode disabled: Not on a Whatnot page');
                }
            });
        });
    });

    // Test button
    testButton.addEventListener('click', () => {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            if (tabs[0] && tabs[0].url.match(/^https:\/\/.*\.whatnot\.com\/.*/)) {
                console.log('Sending test_settings to tab:', tabs[0].id);
                sendDebugLog(`Sending test_settings to tab ${tabs[0].id}`);
                chrome.tabs.sendMessage(tabs[0].id, { type: 'test_settings' }, (response) => {
                    if (chrome.runtime.lastError) {
                        console.error('Test error:', chrome.runtime.lastError);
                        statusDiv.textContent = 'Error: Reload the Whatnot page';
                        statusDiv.className = 'error';
                        sendDebugLog(`Test error: ${chrome.runtime.lastError.message}`);
                        return;
                    }
                    if (response && response.success) {
                        statusDiv.textContent = 'Setup works! Chat is ready';
                        statusDiv.className = 'success';
                        sendDebugLog('Setup test successful');
                    } else {
                        statusDiv.textContent = 'Setup failed. Try setting up again or watch the video';
                        statusDiv.className = 'error';
                        sendDebugLog('Setup test failed');
                    }
                });
            } else {
                statusDiv.textContent = 'Error: Open a Whatnot stream page first';
                statusDiv.className = 'error';
                sendDebugLog('Test settings failed: Not on a Whatnot page');
            }
        });
    });
});

================================================================================
File: whatnot_extension/background.js
================================================================================

let ws = null;
let debugWs = null;

function connectWebSocket() {
    console.log('Attempting WebSocket connection to FoSBot');
    ws = new WebSocket('ws://localhost:8000/ws/whatnot');
    ws.onopen = () => {
        console.log('WebSocket connected to FoSBot');
        sendDebugLog('Background WebSocket connected to FoSBot');
        ws.send(JSON.stringify({ type: 'ping' }));
    };
    ws.onclose = () => {
        console.log('WebSocket disconnected, retrying in 5 seconds');
        sendDebugLog('Background WebSocket disconnected, retrying in 5s');
        setTimeout(connectWebSocket, 5000);
    };
    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        sendDebugLog(`Background WebSocket error: ${error}`);
    };
    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            console.log('Received message:', data);
            sendDebugLog(`Background received message: ${JSON.stringify(data)}`);
            if (data.type === 'pong') {
                console.log('Received pong from FoSBot');
                sendDebugLog('Background received pong from FoSBot');
            }
        } catch (e) {
            console.error('Error parsing WebSocket message:', e);
            sendDebugLog(`Background error parsing WebSocket message: ${e.message}`);
        }
    };
}

function initDebugWebSocket() {
    debugWs = new WebSocket('ws://localhost:8000/ws/debug');
    debugWs.onopen = () => {
        console.log('Background Debug WebSocket connected');
        sendDebugLog('Background Debug WebSocket connected');
    };
    debugWs.onclose = () => {
        console.log('Background Debug WebSocket disconnected, retrying in 5s');
        setTimeout(initDebugWebSocket, 5000);
    };
    debugWs.onerror = (error) => {
        console.error('Background Debug WebSocket error:', error);
    };
}
initDebugWebSocket();

function sendDebugLog(message) {
    if (debugWs && debugWs.readyState === WebSocket.OPEN) {
        debugWs.send(JSON.stringify({ type: 'debug', message }));
    }
}

connectWebSocket();

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log('Background received message:', request);
    sendDebugLog(`Background received message: ${JSON.stringify(request)}`);
    if (request.type === 'chat_message' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'chat_message',
            payload: request.payload
        }));
        sendResponse({ success: true });
        sendDebugLog('Background sent chat message to FoSBot');
    } else if (request.type === 'query_status') {
        sendResponse({
            wsConnected: ws && ws.readyState === WebSocket.OPEN,
            selectorsValid: true // Handled by content.js
        });
        sendDebugLog(`Background query status: wsConnected=${ws && ws.readyState === WebSocket.OPEN}`);
    } else {
        sendResponse({ success: false });
        sendDebugLog('Background message not handled');
    }
    return true; // Keep channel open
});

================================================================================
File: whatnot_extension/popup.html
================================================================================

<!DOCTYPE html>
<html>
<head>
    <title>FoSBot Whatnot Helper</title>
    <style>
        body { font-family: Arial, sans-serif; width: 350px; padding: 15px; }
        h3 { margin: 0 0 10px; }
        label { display: block; margin: 10px 0 5px; font-weight: bold; }
        input, button { width: 100%; padding: 8px; margin-bottom: 10px; box-sizing: border-box; }
        button { background: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background: #0056b3; }
        #status { font-size: 14px; margin: 10px 0; }
        #status.success { color: green; }
        #status.error { color: red; }
        #modeStatus { font-size: 16px; font-weight: bold; margin: 10px 0; }
        .instructions { font-size: 12px; margin-bottom: 10px; }
        .instructions ol { margin: 0; padding-left: 20px; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <h3>FoSBot Whatnot Helper</h3>
    <div id="modeStatus">Setup Mode: Checking...</div>
    <div id="status">Checking connection...</div>
    <label><input type="checkbox" id="setupMode"> Turn On Setup Mode</label>
    <div class="instructions">
        <p><strong>How to set up:</strong></p>
        <ol>
            <li>Start the FoSBot app in Terminal.</li>
            <li>Open a Whatnot stream page.</li>
            <li>Check "Turn On Setup Mode" above.</li>
            <li>Follow the box on the page to click chat parts.</li>
            <li>Click "Test Setup" when done.</li>
        </ol>
    </div>
    <button id="testButton">Test Setup</button>
    <p><a href="https://patreon.com/yourvideo" target="_blank">Watch Setup Video</a></p>
    <script src="popup.js"></script>
</body>
</html>

================================================================================
File: whatnot_extension/manifest.json
================================================================================

{
    "manifest_version": 3,
    "name": "FoSBot Whatnot Helper",
    "version": "0.7.2",
    "description": "Connects Whatnot live streams to FoSBot",
    "permissions": [
        "storage",
        "activeTab"
    ],
    "background": {
        "service_worker": "background.js"
    },
    "content_scripts": [
        {
            "matches": ["https://*.whatnot.com/*"],
            "js": ["content.js"]
        }
    ],
    "action": {
        "default_popup": "popup.html"
    }
}

================================================================================
File: whatnot_extension/content.js
================================================================================

console.log('Content script initialized');

(function () {
    let chatInputSelector = '';
    let chatContainerSelector = '';
    let messageItemSelector = '';
    let usernameSelector = '';
    let messageTextSelector = '';
    let ws = null;
    let debugWs = null;
    let controlPanel = null;
    let currentSelectorType = null;
    let selectorIndex = 0;
    let handleMouseMove = null;
    let handleClick = null;

    const selectorTypes = [
        { id: 'chatContainer', prompt: 'where all chat messages show up' },
        { id: 'message', prompt: 'one single chat message' },
        { id: 'user', prompt: 'a username in a chat message' },
        { id: 'text', prompt: 'the text of a chat message' }
    ];
    const selectors = {
        chatContainer: '',
        message: '',
        user: '',
        text: ''
    };

    // Initialize debug WebSocket
    function initDebugWebSocket() {
        debugWs = new WebSocket('ws://localhost:8000/ws/debug');
        debugWs.onopen = () => {
            console.log('Debug WebSocket connected');
            sendDebugLog('Content script WebSocket connected');
        };
        debugWs.onclose = () => {
            console.log('Debug WebSocket disconnected, retrying in 5s');
            setTimeout(initDebugWebSocket, 5000);
        };
        debugWs.onerror = (error) => {
            console.error('Debug WebSocket error:', error);
        };
    }
    initDebugWebSocket();

    function sendDebugLog(message) {
        if (debugWs && debugWs.readyState === WebSocket.OPEN) {
            debugWs.send(JSON.stringify({ type: 'debug', message }));
        }
    }

    // Load saved selectors
    chrome.storage.local.get(['chatInputSelector', 'chatContainerSelector', 'messageSelector', 'userSelector', 'textSelector'], (result) => {
        chatInputSelector = result.chatInputSelector || '';
        chatContainerSelector = result.chatContainerSelector || '';
        messageItemSelector = result.messageSelector || '';
        usernameSelector = result.userSelector || '';
        messageTextSelector = result.textSelector || '';
        console.log('Loaded selectors:', result);
        sendDebugLog(`Loaded selectors: ${JSON.stringify(result)}`);
        initializeWebSocket();
        setupChatInput();
        if (chatContainerSelector) {
            setupMutationObserver();
        }
    });

    // Initialize WebSocket
    function initializeWebSocket() {
        if (ws) ws.close();
        ws = new WebSocket('ws://localhost:8000/ws/whatnot');
        ws.onopen = () => {
            console.log('Whatnot WebSocket connected');
            sendDebugLog('Whatnot WebSocket connected');
            queryStatus();
        };
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);
                sendDebugLog(`WebSocket message received: ${JSON.stringify(data)}`);
                if (data.type === 'pong') {
                    console.log('Received pong from FoSBot');
                    sendDebugLog('Received pong from FoSBot');
                } else if (data.type === 'sendMessage') {
                    handlePostToWhatnot(data.data);
                }
            } catch (e) {
                console.error('Error parsing WebSocket message:', e);
                sendDebugLog(`Error parsing WebSocket message: ${e.message}`);
            }
        };
        ws.onclose = () => {
            console.log('Whatnot WebSocket disconnected');
            sendDebugLog('Whatnot WebSocket disconnected');
            setTimeout(initializeWebSocket, 2000);
        };
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            sendDebugLog(`WebSocket error: ${error}`);
        };
    }

    // Setup chat input
    function setupChatInput() {
        if (!chatInputSelector) {
            sendDebugLog('No chat input selector configured');
            return;
        }
        const chatInput = document.querySelector(chatInputSelector);
        if (chatInput) {
            chatInput.addEventListener('focus', () => {
                console.log('Chat input area selected');
                sendDebugLog('Chat input area selected');
                sendMessageToFoSBot({ type: 'inputSelected', data: 'Chat input focused' });
            });
        } else {
            console.warn('Chat input selector not found:', chatInputSelector);
            sendDebugLog(`Chat input selector not found: ${chatInputSelector}`);
        }
    }

    // Setup MutationObserver
    function setupMutationObserver() {
        if (!chatContainerSelector) {
            sendDebugLog('No chat container selector for MutationObserver');
            return;
        }
        const chatContainer = document.querySelector(chatContainerSelector);
        if (chatContainer) {
            const observer = new MutationObserver(captureChatMessages);
            observer.observe(chatContainer, { childList: true, subtree: true });
            console.log('MutationObserver set up for:', chatContainerSelector);
            sendDebugLog(`MutationObserver set up for: ${chatContainerSelector}`);
        } else {
            console.warn('Chat container not found for MutationObserver:', chatContainerSelector);
            sendDebugLog(`Chat container not found for MutationObserver: ${chatContainerSelector}`);
        }
    }

    // Capture chat messages
    function captureChatMessages() {
        if (!chatContainerSelector || !messageItemSelector || !usernameSelector || !messageTextSelector) {
            console.warn('Missing selectors:', {
                chatContainer: chatContainerSelector,
                message: messageItemSelector,
                user: usernameSelector,
                text: messageTextSelector
            });
            sendDebugLog(`Missing selectors: chatContainer=${chatContainerSelector}, message=${messageItemSelector}, user=${usernameSelector}, text=${messageTextSelector}`);
            return false;
        }
        const chatContainer = document.querySelector(chatContainerSelector);
        if (!chatContainer) {
            console.warn('Chat container not found:', chatContainerSelector);
            sendDebugLog(`Chat container not found: ${chatContainerSelector}`);
            return false;
        }
        const messages = Array.from(chatContainer.querySelectorAll(messageItemSelector)).map(item => ({
            username: item.querySelector(usernameSelector)?.textContent.trim() || 'Unknown',
            message: item.querySelector(messageTextSelector)?.textContent.trim() || ''
        }));
        if (messages.length > 0) {
            console.log('Captured Whatnot messages:', messages);
            sendDebugLog(`Captured Whatnot messages: ${JSON.stringify(messages)}`);
            sendMessageToFoSBot({ type: 'chat_message', payload: messages, platform: 'whatnot' });
            return true;
        }
        return false;
    }

    // Handle message submission
    function handlePostToWhatnot(message) {
        if (!chatInputSelector) {
            console.warn('No chat input selector');
            sendDebugLog('No chat input selector for posting message');
            return;
        }
        const chatInput = document.querySelector(chatInputSelector);
        const submitButton = document.querySelector('button[type="submit"], [data-testid="send-message"]');
        if (chatInput && submitButton) {
            chatInput.value = message;
            submitButton.click();
            console.log('Message submitted to Whatnot:', message);
            sendDebugLog(`Message submitted to Whatnot: ${message}`);
            sendMessageToFoSBot({ type: 'messageSubmitted', data: message, platform: 'whatnot' });
        } else {
            console.warn('Chat input or submit button not found:', { chatInput, submitButton });
            sendDebugLog(`Chat input or submit button not found: input=${chatInput}, button=${submitButton}`);
        }
    }

    // Send message to FoSBot
    function sendMessageToFoSBot(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(message));
            console.log('Sent message to FoSBot:', message);
            sendDebugLog(`Sent message to FoSBot: ${JSON.stringify(message)}`);
        } else {
            console.warn('WebSocket not connected:', message);
            sendDebugLog(`WebSocket not connected for message: ${JSON.stringify(message)}`);
        }
    }

    // Query status
    function queryStatus() {
        sendMessageToFoSBot({ type: 'queryStatus' });
    }

    // Create control panel
    function createControlPanel() {
        if (controlPanel) controlPanel.remove();
        if (selectorIndex >= selectorTypes.length || selectorIndex < 0) {
            console.error('Invalid selector index:', selectorIndex);
            sendDebugLog(`Invalid selector index: ${selectorIndex}`);
            selectorIndex = 0;
        }
        controlPanel = document.createElement('div');
        controlPanel.style.cssText = `
            position: fixed; top: 10px; right: 10px; width: 300px; background: white;
            border: 1px solid #ccc; padding: 15px; z-index: 100000; box-shadow: 0 0 10px rgba(0,0,0,0.3);
            font-family: Arial, sans-serif; font-size: 14px;
        `;
        controlPanel.innerHTML = `
            <h3 style="margin: 0 0 10px;">Set Up Whatnot Chat</h3>
            <p id="instruction">Click ${selectorTypes[selectorIndex].prompt}</p>
            <div id="status" style="color: green; margin-bottom: 10px;"></div>
            <div id="error" style="color: red; margin-bottom: 10px;"></div>
            <button id="nextButton" style="padding: 8px; background: #007bff; color: white; border: none; cursor: pointer;">Next</button>
            <button id="doneButton" style="padding: 8px; margin-left: 10px; background: #28a745; color: white; border: none; cursor: pointer;">Done</button>
            <button id="cancelButton" style="padding: 8px; margin-left: 10px; background: #dc3545; color: white; border: none; cursor: pointer;">Cancel</button>
        `;
        document.body.appendChild(controlPanel);
        console.log('Control panel created for:', selectorTypes[selectorIndex].id);
        sendDebugLog(`Control panel created for: ${selectorTypes[selectorIndex].id}`);

        document.getElementById('nextButton').addEventListener('click', () => {
            if (selectors[selectorTypes[selectorIndex].id]) {
                selectorIndex++;
                if (selectorIndex < selectorTypes.length) {
                    currentSelectorType = selectorTypes[selectorIndex].id;
                    document.getElementById('instruction').textContent = `Click ${selectorTypes[selectorIndex].prompt}`;
                    document.getElementById('status').textContent = '';
                    sendDebugLog(`Advanced to next selector: ${selectorTypes[selectorIndex].id}`);
                } else {
                    document.getElementById('instruction').textContent = 'All set! Click Done to finish';
                    document.getElementById('nextButton').disabled = true;
                    sendDebugLog('All selectors set, prompting to finish');
                }
            } else {
                document.getElementById('error').textContent = 'Please click an element first';
                sendDebugLog('Next button clicked but no element selected');
            }
        });

        document.getElementById('doneButton').addEventListener('click', () => {
            saveSelectors();
            cleanup();
            sendDebugLog('Done button clicked, selectors saved');
        });

        document.getElementById('cancelButton').addEventListener('click', () => {
            cleanup();
            sendDebugLog('Cancel button clicked, setup aborted');
        });
    }

    function saveSelectors() {
        const settings = {
            chatContainerSelector: selectors.chatContainer,
            messageSelector: selectors.message,
            userSelector: selectors.user,
            textSelector: selectors.text,
            setupMode: false
        };
        chrome.storage.local.set(settings, () => {
            console.log('Selectors saved:', settings);
            sendDebugLog(`Selectors saved: ${JSON.stringify(settings)}`);
            chatContainerSelector = settings.chatContainerSelector;
            messageItemSelector = settings.messageSelector;
            usernameSelector = settings.userSelector;
            messageTextSelector = settings.textSelector;
            setupMutationObserver();
            chrome.runtime.sendMessage({ type: 'update_settings', payload: settings });
        });
    }

    function cleanup() {
        if (controlPanel) controlPanel.remove();
        document.querySelectorAll('.fosbot-overlay, .fosbot-highlight').forEach(el => el.remove());
        if (handleMouseMove) document.removeEventListener('mousemove', handleMouseMove);
        if (handleClick) document.removeEventListener('click', handleClick);
        controlPanel = null;
        currentSelectorType = null;
        selectorIndex = 0;
        handleMouseMove = null;
        handleClick = null;
        chrome.storage.local.set({ setupMode: false });
        console.log('Selector cleanup completed');
        sendDebugLog('Selector cleanup completed');
    }

    function startSetup() {
        console.log('Starting setup');
        sendDebugLog('Starting setup process');
        document.querySelectorAll('.fosbot-overlay, .fosbot-highlight').forEach(el => el.remove());

        const overlay = document.createElement('div');
        overlay.className = 'fosbot-overlay';
        overlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:99998;';
        document.body.appendChild(overlay);
        console.log('Overlay added');
        sendDebugLog('Overlay added');

        const highlight = document.createElement('div');
        highlight.className = 'fosbot-highlight';
        highlight.style.cssText = 'position:absolute; border:2px dashed #fff; z-index:99999; pointer-events:none;';
        document.body.appendChild(highlight);
        console.log('Highlight added');
        sendDebugLog('Highlight added');

        const getElementAtPoint = (x, y) => {
            overlay.style.pointerEvents = 'none';
            const el = document.elementFromPoint(x, y);
            overlay.style.pointerEvents = 'auto';
            return el;
        };

        handleMouseMove = (e) => {
            const el = getElementAtPoint(e.clientX, e.clientY);
            if (el) {
                console.log('Mouse over element:', el.tagName, el.className);
                sendDebugLog(`Mouse over element: ${el.tagName}, class=${el.className}`);
                const rect = el.getBoundingClientRect();
                highlight.style.left = `${rect.left}px`;
                highlight.style.top = `${rect.top}px`;
                highlight.style.width = `${rect.width}px`;
                highlight.style.height = `${rect.height}px`;
            }
        };

        handleClick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const el = getElementAtPoint(e.clientX, e.clientY);
            if (el) {
                const selector = generateRobustSelector(el);
                console.log('Element clicked, selector:', selector);
                sendDebugLog(`Element clicked, selector: ${selector}`);
                selectors[currentSelectorType] = selector;
                document.getElementById('status').textContent = `Set: ${selectorTypes[selectorIndex].prompt}`;
                document.getElementById('error').textContent = '';
            }
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('click', handleClick);
    }

    // Selector generation
    function generateRobustSelector(el) {
        if (el.id) return `#${el.id}`;
        let path = [];
        let current = el;
        while (current && current.nodeType === Node.ELEMENT_NODE && current !== document.body) {
            let selector = current.nodeName.toLowerCase();
            if (current.className && typeof current.className === 'string') {
                const classes = current.className.trim().split(/\s+/).join('.');
                if (classes) selector += `.${classes}`;
            }
            path.unshift(selector);
            current = current.parentNode;
        }
        return path.join(' > ');
    }

    // Handle messages
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        console.log('Content script received message:', message);
        sendDebugLog(`Content script received message: ${JSON.stringify(message)}`);
        if (message.type === 'toggle_setup_mode') {
            console.log('Toggle setup mode:', message.payload.setupMode);
            sendDebugLog(`Toggle setup mode: ${message.payload.setupMode}`);
            if (message.payload.setupMode) {
                selectorIndex = 0;
                currentSelectorType = selectorTypes[0].id;
                createControlPanel();
                startSetup();
            } else {
                cleanup();
            }
            sendResponse({ success: true });
        } else if (message.type === 'query_status') {
            sendResponse({
                wsConnected: ws && ws.readyState === WebSocket.OPEN,
                selectorsValid: !!chatContainerSelector && !!messageItemSelector && !!usernameSelector && !!messageTextSelector
            });
            sendDebugLog(`Query status response: wsConnected=${ws && ws.readyState === WebSocket.OPEN}, selectorsValid=${!!chatContainerSelector && !!messageItemSelector && !!usernameSelector && !!messageTextSelector}`);
        } else if (message.type === 'update_settings') {
            console.log('Updating selectors:', message.payload);
            sendDebugLog(`Updating selectors: ${JSON.stringify(message.payload)}`);
            chatInputSelector = message.payload.chatInputSelector || '';
            chatContainerSelector = message.payload.chatContainerSelector || '';
            messageItemSelector = message.payload.messageSelector || '';
            usernameSelector = message.payload.userSelector || '';
            messageTextSelector = message.payload.textSelector || '';
            setupChatInput();
            if (chatContainerSelector) {
                setupMutationObserver();
            }
            captureChatMessages();
            sendResponse({ success: true });
        } else if (message.type === 'test_settings') {
            const success = captureChatMessages();
            sendResponse({ success });
            sendDebugLog(`Test settings result: ${success}`);
        }
        return true; // Keep channel open for async response
    });

    // Initialize on page load
    window.addEventListener('load', () => {
        console.log('Whatnot Chat Consolidator loaded');
        sendDebugLog('Whatnot Chat Consolidator loaded');
        setInterval(captureChatMessages, 2000);
    });
})();

================================================================================
File: data/oauth_states.json
================================================================================

{}

================================================================================
File: data/settings.json
================================================================================

{
  "COMMAND_PREFIX": "!",
  "WS_HOST": "localhost",
  "WS_PORT": 8000,
  "LOG_LEVEL": "DEBUG",
  "DATA_DIR": "data",
  "TWITCH_CHANNELS": "",
  "twitch_access_token": "xrnbea03umspwjv8vjaozppjqpp50l",
  "youtube_api_key": "",
  "x_api_key": "",
  "x_api_secret": "",
  "x_access_token": "1697187583137062912-s4LxBbGtD3zLlb7AFWZVebfQolmezO",
  "x_access_token_secret": "",
  "youtube_access_token": "ya29.a0AZYkNZgLdVy7dDQX2hb5GDc8pRWTgAae0qEsuAflU5tWd1oMAFFk_kbFmuwfXuScUcpLCZXGUruHBMTUE_5z67Q4JQWvoo5QdCzu1hEs7aYcsy2j9aUDLZ5SFoR0xuqVtLM-Cy_3KEwIIPKSAtv9RHDHyQtH2oLzbNgW-tcOaCgYKAf4SARUSFQHGX2MibtkoujvPJsEOS8jmETup0Q0175",
  "youtube_refresh_token": "1//01mPD926ZnoarCgYIARAAGAESNwF-L9IrXJ5W_P-kZDNT2KyaGBlHqnZvcl63qXvRwC2EvuGLeSAIldsU7ZdhtTUbqqk4B91X9rA",
  "youtube_expires_at": 1744855451.690141,
  "youtube_scopes": [
    "https://www.googleapis.com/auth/youtube.readonly",
    "https://www.googleapis.com/auth/youtube.force-ssl"
  ],
  "youtube_user_id": "UCNZ9jPWZue4RoC_DBh9AoIg",
  "youtube_user_login": "FoSGamers",
  "twitch_refresh_token": "o6jv5hop8j2ihhws765y933psumpq528ctru6hstkeai7h0nzj",
  "twitch_expires_at": 1744866792.662477,
  "twitch_scopes": [
    "channel:read:subscriptions",
    "chat:edit",
    "chat:read"
  ],
  "twitch_user_id": "1154208505",
  "twitch_user_login": "fos_gamers",
  "x_user_id": "1697187583137062912",
  "x_user_login": "FoSGamers"
}

================================================================================
File: data/commands.json
================================================================================

{
    "test": "this is just a test",
    "ween": "Ask Mystic"
}

================================================================================
File: data/tokens.json
================================================================================



