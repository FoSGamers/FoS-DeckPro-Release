# deckforge_gui_app.py

import json
import random
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from typing import List, Dict
import subprocess
import os
from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton

# === CORE MODULE ===
def load_inventory(json_path: str) -> List[Dict]:
    with open(json_path, 'r', encoding='utf-8') as file:
        inventory = json.load(file)
    return inventory

def filter_legal_cards(cards: List[Dict], format_key: str = 'legal_pauper') -> List[Dict]:
    return [card for card in cards if card.get(format_key) == 'legal']

def analyze_synergy(cards: List[Dict]) -> Dict[str, float]:
    synergy_scores = {}
    for card in cards:
        keywords = card.get('oracle_text', '').lower()
        if 'draw' in keywords:
            synergy_scores[card['Name']] = synergy_scores.get(card['Name'], 0) + 1.5
        if 'damage' in keywords or 'counter' in keywords:
            synergy_scores[card['Name']] = synergy_scores.get(card['Name'], 0) + 1.0
        if 'mana' in keywords or 'add' in keywords:
            synergy_scores[card['Name']] = synergy_scores.get(card['Name'], 0) + 0.5
    return synergy_scores

def generate_pauper_deck(cards: List[Dict], synergy_scores: Dict[str, float]) -> List[Dict]:
    sorted_cards = sorted(cards, key=lambda c: synergy_scores.get(c['Name'], 0), reverse=True)
    deck = []
    deck += [card for card in sorted_cards if 'Creature' in card['type_line']][:24]
    deck += [card for card in sorted_cards if 'Instant' in card['type_line'] or 'Sorcery' in card['type_line']][:12]
    deck += [card for card in sorted_cards if 'Land' in card['type_line']][:20]
    if len(deck) < 60:
        remaining = [c for c in sorted_cards if c not in deck]
        deck += random.sample(remaining, min(60 - len(deck), len(remaining)))
    return deck[:60]

def export_to_forge(deck: List[Dict], path: str):
    with open(path, 'w') as f:
        f.write("[metadata]\nName=AutoGenerated Pauper Deck\n\n[main]\n")
        for card in deck:
            f.write(f"1 {card['Name']}\n")

def simulate_with_forge(deck_path: str, forge_path: str):
    try:
        subprocess.run([forge_path, "sim", deck_path], check=True)
    except Exception as e:
        messagebox.showerror("Forge Simulation Error", str(e))

# === GUI MODULE ===
class DeckForgeApp:
    def __init__(self, root):
        self.root = root
        self.root.title("DeckForge AI â€“ Pauper Deck Builder")

        self.inventory = []
        self.deck = []

        self.setup_ui()

    def setup_ui(self):
        frame = ttk.Frame(self.root, padding=10)
        frame.pack(fill=tk.BOTH, expand=True)

        self.load_btn = ttk.Button(frame, text="Load Inventory", command=self.load_inventory_file)
        self.load_btn.grid(row=0, column=0, pady=5)

        self.build_btn = ttk.Button(frame, text="Build Deck", command=self.build_deck)
        self.build_btn.grid(row=0, column=1, pady=5)

        self.export_btn = ttk.Button(frame, text="Export for Forge", command=self.export_deck)
        self.export_btn.grid(row=0, column=2, pady=5)

        self.sim_btn = ttk.Button(frame, text="Simulate in Forge", command=self.simulate)
        self.sim_btn.grid(row=0, column=3, pady=5)

        self.output = tk.Text(frame, height=25, width=100)
        self.output.grid(row=1, column=0, columnspan=4, pady=10)

    def load_inventory_file(self):
        path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])
        if not path:
            return
        self.inventory = load_inventory(path)
        messagebox.showinfo("Success", f"Loaded {len(self.inventory)} cards.")

    def build_deck(self):
        pauper_cards = filter_legal_cards(self.inventory)
        synergy_scores = analyze_synergy(pauper_cards)
        self.deck = generate_pauper_deck(pauper_cards, synergy_scores)
        self.output.delete('1.0', tk.END)
        for card in self.deck:
            self.output.insert(tk.END, f"{card['Name']} | {card['type_line']} | CMC: {card['cmc']}\n")

    def export_deck(self):
        if not self.deck:
            messagebox.showerror("Error", "No deck to export.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".dck", filetypes=[("Forge Deck", "*.dck")])
        if path:
            export_to_forge(self.deck, path)
            messagebox.showinfo("Exported", f"Deck saved to {path}")

    def simulate(self):
        forge_path = filedialog.askopenfilename(title="Select Forge Executable or Script")
        deck_path = filedialog.askopenfilename(title="Select Exported .dck Deck File")
        if forge_path and deck_path:
            simulate_with_forge(deck_path, forge_path)

# === MAIN ENTRY ===
if __name__ == '__main__':
    root = tk.Tk()
    app = DeckForgeApp(root)
    root.mainloop()

def launch_deckforge_ai(inventory, parent=None):
    """
    Entry point for launching DeckForge AI from FoS-DeckPro.
    inventory: list of dicts (enriched card data)
    parent: parent widget (optional)
    """
    dlg = QDialog(parent)
    dlg.setWindowTitle("DeckForge AI Deck Builder (Preview)")
    layout = QVBoxLayout(dlg)
    layout.addWidget(QLabel(f"DeckForge AI is integrated!\nInventory size: {len(inventory)} cards."))
    close_btn = QPushButton("Close")
    close_btn.clicked.connect(dlg.accept)
    layout.addWidget(close_btn)
    dlg.exec()
