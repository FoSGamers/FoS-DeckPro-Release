// FoSBot Whatnot Helper Content Script v0.4 (Webapp Config)
let selectors = {}; const STORAGE_KEY = 'whatnotSelectors'; let WS_URL = 'ws://localhost:8000/ws/whatnot'; let socket = null; let reconnectTimer = null; let reconnectAttempts = 0; const MAX_RECONNECT_ATTEMPTS = 15; const RECONNECT_DELAY_BASE = 3000; let observer = null; let isInspectorMode = false; let inspectorStep = 0;
const inspectorSteps = [ { key: 'chatContainer', prompt: 'Click MAIN chat message area' }, { key: 'messageItem', prompt: 'Click ANY single chat message row' }, { key: 'username', prompt: 'Click USERNAME in that message' }, { key: 'messageText', prompt: 'Click MESSAGE TEXT in that message' }, { key: 'chatInput', prompt: 'Click the text INPUT field' }, { key: 'sendButton', prompt: 'Click the SEND button/icon' } ];
let inspectorOverlay = null; let lastClickedElementForStep = {};
function initialize() { console.log("FoSBot WN Helper: Init"); loadSelectors().then(loaded => { connectWebSocket(); }); setupMessageListener(); }
function connectWebSocket() { clearTimeout(reconnectTimer); if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return; console.log(`WN Ext: Connecting WS: ${WS_URL}`); try { socket = new WebSocket(WS_URL); } catch (e) { console.error(`WN Ext: WS connect failed: ${e}`); scheduleReconnect(); return; }
    socket.onopen = () => { console.log('WN Ext: WS Connected'); reconnectAttempts = 0; startObserver(); };
    socket.onmessage = (event) => { console.debug('WN Ext: Msg from server:', event.data); try { const data = JSON.parse(event.data); if (data.action === 'postToWhatnot') { handlePostToWhatnot(data.message); } } catch (e) { console.error("WN Ext: Error parsing server msg", e); } };
    socket.onclose = (event) => { console.log(`WN Ext: WS closed (Code: ${event.code})`); stopObserver(); socket = null; scheduleReconnect(); };
    socket.onerror = (error) => { console.error('WN Ext: WS Error:', error); };
}
function scheduleReconnect() { if (isInspectorMode) return; reconnectAttempts++; if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) { const delay = Math.min(RECONNECT_DELAY_BASE * Math.pow(1.5, reconnectAttempts -1), 60000); console.log(`WN Ext: Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000}s...`); clearTimeout(reconnectTimer); reconnectTimer = setTimeout(connectWebSocket, delay); } else { console.error("WN Ext: Max WS reconnect attempts."); } }
function handlePostToWhatnot(message) { console.log(`WN Ext: Attempt post: "${message}"`); if (!validateSelectors(['chatInput', 'sendButton'])) { console.error("Cannot post: Selectors invalid."); return false; } const chatInput = document.querySelector(selectors.chatInput); const sendButton = document.querySelector(selectors.sendButton); if (!chatInput || !sendButton) { console.error(`Cannot find Input/Button: ${selectors.chatInput} / ${selectors.sendButton}`); return false; }
    try { chatInput.focus(); const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set; setter.call(chatInput, message); chatInput.dispatchEvent(new Event('input', { bubbles: true, composed: true })); chatInput.dispatchEvent(new Event('change', { bubbles: true, composed: true }));
        setTimeout(() => { if (!sendButton.disabled) sendButton.click(); else console.warn("WN Send disabled."); }, 150); return true;
    } catch (e) { console.error("Error posting to WN:", e); return false; }
}
async function loadSelectors() { try { const result = await chrome.storage.local.get([STORAGE_KEY]); if (result[STORAGE_KEY] && typeof result[STORAGE_KEY] === 'object') { const keys = Object.keys(selectors); if (keys.every(k => Object.keys(result[STORAGE_KEY]).includes(k))) { selectors = result[STORAGE_KEY]; console.log('WN Ext: Loaded selectors:', selectors); return validateSelectors(keys); } } console.warn('WN Ext: No valid selectors.'); return false; } catch (e) { console.error("WN Ext: Error loading selectors:", e); return false; } }
function validateSelectors(keysToCheck) { return keysToCheck.every(key => selectors[key] && typeof selectors[key] === 'string' && selectors[key].trim() !== ''); }
async function saveSelectors() { try { await chrome.storage.local.set({ [STORAGE_KEY]: selectors }); console.log('WN Ext: Selectors saved:', selectors); if (inspectorOverlay) updateInspectorStatus('Saved! Restarting observer...'); stopObserver(); startObserver(); } catch (e) { console.error("WN Ext: Error saving selectors:", e); if (inspectorOverlay) updateInspectorStatus('ERROR saving!'); } }
function startObserver() { stopObserver(); if (!socket || socket.readyState !== WebSocket.OPEN) return; if (!validateSelectors(['chatContainer', 'messageItem', 'username', 'messageText'])) { console.warn('Observer not started: Read selectors invalid.'); return; } const container = document.querySelector(selectors.chatContainer); if (!container) { console.error(`Observer failed: Cannot find container: ${selectors.chatContainer}`); return; } console.log(`WN Ext: Starting Observer on: ${selectors.chatContainer}`);
    observer = new MutationObserver((mutations) => { for (const m of mutations) { if (m.addedNodes.length) { m.addedNodes.forEach(node => { if (node.nodeType === 1) { if (node.matches(selectors.messageItem)) { parseAndSend(node); } else { node.querySelectorAll(selectors.messageItem).forEach(parseAndSend); } } }); } } });
    observer.observe(container, { childList: true, subtree: true }); console.log("WN Ext: Observer active.");
}
function parseAndSend(el) { const userEl = el.querySelector(selectors.username); const textEl = el.querySelector(selectors.messageText); const user = userEl?.textContent?.trim(); const text = textEl?.textContent?.trim(); if (user && text && text !== user && socket && socket.readyState === WebSocket.OPEN) { console.debug(`WN Ext: Sending: [${user}] ${text}`); socket.send(JSON.stringify({ platform: 'whatnot', user: user, text: text })); } }
function stopObserver() { if (observer) { observer.disconnect(); observer = null; console.log("WN Ext: Observer stopped."); } }
function startInspectorMode() { if (isInspectorMode) return; isInspectorMode = true; inspectorStep = 0; lastClickedElementForStep = {}; console.log("WN Ext: Starting Inspector"); createInspectorOverlay(); updateInspectorPrompt(); document.body.style.cursor = 'crosshair'; document.addEventListener('click', inspectorClickListener, { capture: true }); }
function stopInspectorMode(save = false) { if (!isInspectorMode) return; isInspectorMode = false; document.body.style.cursor = 'default'; document.removeEventListener('click', inspectorClickListener, { capture: true }); removeInspectorOverlay(); console.log("WN Ext: Inspector Stopped."); if (save) { saveSelectors(); } }
function createInspectorOverlay() { removeInspectorOverlay(); inspectorOverlay = document.createElement('div'); inspectorOverlay.style.cssText = `all: initial; position: fixed; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.85); color: white; padding: 15px; border: 3px solid gold; border-radius: 5px; z-index: 2147483647; font-family: sans-serif; font-size: 14px; line-height: 1.4; max-width: 350px; box-shadow: 0 0 15px rgba(0,0,0,0.5);`; inspectorOverlay.innerHTML = `<h4 style="all: revert; margin: 0 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid gold;">Configure Selectors</h4><p id="inspectorPrompt" style="all: revert; margin: 5px 0; font-weight: bold;"></p><p id="inspectorStatus" style="all: revert; margin: 10px 0 0 0; font-style: italic; color: #ddd;"></p><button id="cancelInspector" style="all: revert; margin-top: 15px; padding: 5px 8px; background-color: #cc5555; color: white; border: 1px solid #aa4444; cursor: pointer; border-radius: 3px; font-size: 12px;">Cancel</button>`; document.body.appendChild(inspectorOverlay); inspectorOverlay.querySelector('#cancelInspector').addEventListener('click', (e) => { e.stopPropagation(); stopInspectorMode(false); }); }
function removeInspectorOverlay() { if (inspectorOverlay) { inspectorOverlay.remove(); inspectorOverlay = null; } }
function updateInspectorPrompt() { if (!inspectorOverlay) return; const promptEl = inspectorOverlay.querySelector('#inspectorPrompt'); const cancelBtn = inspectorOverlay.querySelector('#cancelInspector'); if (inspectorStep < inspectorSteps.length) { promptEl.textContent = `Step ${inspectorStep + 1}/${inspectorSteps.length}: ${inspectorSteps[inspectorStep].prompt}`; } else { promptEl.textContent = 'All steps done! Review selectors.'; updateInspectorStatus('Click Save to apply.'); const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save Selectors'; saveBtn.style.cssText = 'all: revert; margin-left: 10px; padding: 5px 8px; background-color: #4CAF50; color: white; border: 1px solid #388E3C; cursor: pointer; border-radius: 3px; font-size: 12px;'; saveBtn.onclick = (e) => { e.stopPropagation(); stopInspectorMode(true); }; cancelBtn.insertAdjacentElement('afterend', saveBtn); } }
function updateInspectorStatus(text) { if (!inspectorOverlay) return; inspectorOverlay.querySelector('#inspectorStatus').textContent = text; }
function generateRobustSelector(el) { if (!el || typeof el.getAttribute !== 'function') return null; try { if (el.id) { const idSel = `#${CSS.escape(el.id)}`; if (document.querySelectorAll(idSel).length === 1) return idSel; } const dataAttrs = Array.from(el.attributes).filter(a => a.name.startsWith('data-test') && a.value); for (const a of dataAttrs) { const s = `${el.tagName.toLowerCase()}[${a.name}="${CSS.escape(a.value)}"]`; if (document.querySelectorAll(s).length === 1) return s; } const role = el.getAttribute('role'); if (role) { const s = `${el.tagName.toLowerCase()}[role="${CSS.escape(role)}"]`; if (document.querySelectorAll(s).length === 1) return s; } if (el.classList.length > 0) { const classes = Array.from(el.classList).filter(c => !/^(?:js-|is-|has-|active|focus|hover|animating)/.test(c) && !/\d/.test(c) && c.length > 3); if (classes.length > 0) { return `${el.tagName.toLowerCase()}.${classes.map(c => CSS.escape(c)).join('.')}`; } } return el.tagName.toLowerCase(); } catch (e) { console.error("Error generating selector:", e, el); return null; } }
function generateRelativeSelector(target, base) { if (!base || !target || !base.contains(target)) { return generateRobustSelector(target); } try { if (target.id && base.querySelectorAll(`#${CSS.escape(target.id)}`).length === 1) return `#${CSS.escape(target.id)}`; const dataAttrs = Array.from(target.attributes).filter(a => a.name.startsWith('data-test') && a.value); for (const a of dataAttrs) { const s = `[${a.name}="${CSS.escape(a.value)}"]`; if (base.querySelectorAll(s).length === 1 && base.querySelector(s) === target) return s; } if (target.classList.length > 0) { const classes = Array.from(target.classList).filter(c => !/^(?:js-|is-|has-|active|focus|hover|animating)/.test(c) && !/\d/.test(c) && c.length > 3); if (classes.length > 0) { const s = `.${classes.map(c => CSS.escape(c)).join('.')}`; if (base.querySelectorAll(s).length === 1 && base.querySelector(s) === target) return s; } } return generateRobustSelector(target); } catch (e) { console.error("Error generating relative selector:", e); return generateRobustSelector(target); } }
function inspectorClickListener(event) { if (!isInspectorMode) return; event.preventDefault(); event.stopPropagation(); const targetElement = event.target; const currentStep = inspectorSteps[inspectorStep]; let selector; targetElement.style.outline = '3px dashed gold'; setTimeout(() => { targetElement.style.outline = ''; }, 750); if (currentStep.key === 'username' || currentStep.key === 'messageText') { const baseElement = lastClickedElementForStep['messageItem']; selector = generateRelativeSelector(targetElement, baseElement); } else { selector = generateRobustSelector(targetElement); lastClickedElementForStep[currentStep.key] = targetElement; } selectors[currentStep.key] = selector; updateInspectorStatus(`Selected ${currentStep.key}: ${selector}`); inspectorStep++; updateInspectorPrompt(); }
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { console.log("WN Ext: Received message:", request); if (request.action === "start_inspector") { if (isInspectorMode) { sendResponse({ status: "already_active" }); if(inspectorOverlay) inspectorOverlay.style.zIndex = '2147483647'; } else { startInspectorMode(); sendResponse({ status: "started" }); } return true; } else if (request.action === "query_status") { sendResponse({ ws_status: socket ? ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][socket.readyState] : "Not Init", selectors_ok: validateSelectors(Object.keys(selectors)) }); return false; } });
initialize(); // Start
