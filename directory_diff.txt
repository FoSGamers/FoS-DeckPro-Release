Only in FoS_DeckPro: .DS_Store
Only in FoS-DeckPro: .cursor
diff -r FoS-DeckPro/CHANGELOG.md FoS_DeckPro/CHANGELOG.md
0a1,155
> # Changelog
> 
> ## [v1.5.0] - 2024-05-30
> 
> ### Major Enhancements
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
> - **Whatnot Packing Slip Processing (in progress):**
>   - Scan a folder of Whatnot packing slip PDFs and update inventory automatically (requires `pdfplumber`).
>   - Buyer analytics and robust error handling.
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> - **Full test coverage and CI integration.**
> - **Requirements and Documentation:**
>   - All dependencies are now listed in `requirements.txt` for easy setup on any computer.
>   - README updated with clear Quick Start, usage, and requirements.
> 
> ### Status
> - This is a stable, working release on branch `v1.5.0-working` and tag `v1.5.0`.
> - The Whatnot packing slip PDF feature is under active development.
> 
> ## [v1.4.0] - 2024-05-20
> 
> ### Major Enhancements
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
> - **Whatnot Packing Slip Processing (in progress):**
>   - Scan a folder of Whatnot packing slip PDFs and update inventory automatically (requires `pdfplumber`).
>   - Buyer analytics and robust error handling.
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> - **Full test coverage and CI integration.**
> - **Requirements and Documentation:**
>   - All dependencies are now listed in `requirements.txt` for easy setup on any computer.
>   - README updated with clear Quick Start, usage, and requirements.
> 
> ### Status
> - This is a stable, working release on branch `v1.4.0-working` and tag `v1.4.0`.
> - The Whatnot packing slip PDF feature is under active development.
> 
> ## [v1.3.0] - 2024-05-10
> 
> ### Major Enhancements
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
> - **Whatnot Packing Slip Processing (in progress):**
>   - Scan a folder of Whatnot packing slip PDFs and update inventory automatically (requires `pdfplumber`).
>   - Buyer analytics and robust error handling.
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> - **Full test coverage and CI integration.**
> - **Requirements and Documentation:**
>   - All dependencies are now listed in `requirements.txt` for easy setup on any computer.
>   - README updated with clear Quick Start, usage, and requirements.
> 
> ### Status
> - This is a stable, working release on branch `v1.3.0-working` and tag `v1.3.0`.
> - The Whatnot packing slip PDF feature is under active development.
> 
> ## [v1.2.0] - 2024-04-30
> 
> ### Major Enhancements
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
> - **Whatnot Packing Slip Processing (in progress):**
>   - Scan a folder of Whatnot packing slip PDFs and update inventory automatically (requires `pdfplumber`).
>   - Buyer analytics and robust error handling.
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> - **Full test coverage and CI integration.**
> - **Requirements and Documentation:**
>   - All dependencies are now listed in `requirements.txt` for easy setup on any computer.
>   - README updated with clear Quick Start, usage, and requirements.
> 
> ### Status
> - This is a stable, working release on branch `v1.2.0-working` and tag `v1.2.0`.
> - The Whatnot packing slip PDF feature is under active development.
> 
> ## [v1.1.0] - 2024-04-20
> 
> ### Major Enhancements
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
> - **Whatnot Packing Slip Processing (in progress):**
>   - Scan a folder of Whatnot packing slip PDFs and update inventory automatically (requires `pdfplumber`).
>   - Buyer analytics and robust error handling.
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> - **Full test coverage and CI integration.**
> - **Requirements and Documentation:**
>   - All dependencies are now listed in `requirements.txt` for easy setup on any computer.
>   - README updated with clear Quick Start, usage, and requirements.
> 
> ### Status
> - This is a stable, working release on branch `v1.1.0-working` and tag `v1.1.0`.
> - The Whatnot packing slip PDF feature is under active development.
> 
> ## [v1.0.0] - 2024-04-10
> 
> ### Major Enhancements
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
> - **Whatnot Packing Slip Processing (in progress):**
>   - Scan a folder of Whatnot packing slip PDFs and update inventory automatically (requires `pdfplumber`).
>   - Buyer analytics and robust error handling.
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> - **Full test coverage and CI integration.**
> - **Requirements and Documentation:**
>   - All dependencies are now listed in `requirements.txt` for easy setup on any computer.
>   - README updated with clear Quick Start, usage, and requirements.
> 
> ### Status
> - This is a stable, working release on branch `v1.0.0-working` and tag `v1.0.0`.
> - The Whatnot packing slip PDF feature is under active development.
> 
> ## [v1.5.1] - 2024-06-XX
> 
> ### Major Enhancements
> - **Robust Sale Parsing:**
>   - Card name and foil/normal status are now always split and normalized, even if the status is in the name (e.g., "Bribery normal").
>   - Parsing logic is fully regression-tested for all known edge cases.
> - **Improved Matching Logic:**
>   - Cards are matched using name, set code, collector number, foil/normal, and language.
>   - Fuzzy matching and set code aliases are used for best results.
>   - Collector number is always compared as an exact string.
> - **Ambiguity Handling:**
>   - If multiple inventory cards match except for language, the user is prompted to resolve the ambiguity.
> - **Undo/Restore:**
>   - Every packing slip removal can be undone from the File menu.
> - **No Auto-Remove:**
>   - Cards are not removed from inventory or files moved until the user confirms.
> - **Debugging:**
>   - All not-found cards are logged with detailed debug output for troubleshooting.
> - **Full Test Coverage:**
>   - All core logic is covered by regression and edge-case tests.
>   - Sale parsing and matching logic are tested for all known edge cases.
> - **Documentation:**
>   - README.md and this changelog are fully updated for all changes, with clear instructions for users and AI contributors.
> 
> ### Status
> - This is a stable, working release on branch `v1.5.1-working` and tag `v1.5.1`.
> - All features are fully documented and regression-tested.
diff -r FoS-DeckPro/CONTRIBUTING.md FoS_DeckPro/CONTRIBUTING.md
1,11d0
< ## Branching and Release Workflow (Best Practices)
< 
< - The `main` branch always contains the best working, stable, and production-ready code.
< - All new features, bugfixes, or experimental work should be done in separate branches (e.g., `feature/xyz`, `experiment/v1.4.0-semi-working`).
< - Only merge a feature or experiment branch into `main` after it is fully tested and confirmed to work as intended.
< - Use tags (e.g., `v1.4.0`) to mark stable releases on the `main` branch.
< - Avoid tagging experimental or semi-working versions as official releases unless needed for reference.
< - Never push untested or unstable code directly to `main`.
< - Always ensure `main` is deployable and represents the best working state.
< 
< This workflow ensures stability, traceability, and safe collaboration for all contributors.
Only in FoS-DeckPro: Deck Build test.csv
Only in FoS-DeckPro: Deck Build test.json
Only in FoS-DeckPro: Deck_Building.csv
Only in FoS-DeckPro: Deck_Building.json
Only in FoS-DeckPro: FoS_DeckPro
Only in FoS-DeckPro: New_For_Sale.csv
Only in FoS-DeckPro: New_For_Sale.json
diff -r FoS-DeckPro/README.md FoS_DeckPro/README.md
1c1
< # ManaBox Enhancer
---
> # ðŸš€ FoS-DeckPro
2a3,97
> **Release: v1.6.0 (2024-06-05) â€” Working, Stable, and Fully Modular**
> 
> > This release is a fully working, stable, and modular version of FoS-DeckPro. All core workflows (break builder, Whatnot packing slip processing, inventory management, buyers database, and analytics) are robust, tested, and documented. All break templates and configuration files are present and correctly referenced. Legacy and backup files are isolated in a private folder and are not included in the public release. See below for usage, features, and details.
> 
> ## Quick Start
> 
> 1. **Install requirements:**
>    ```sh
>    pip install -r FoS_DeckPro/requirements.txt
>    ```
> 2. **Launch the app:**
>    ```sh
>    python3 FoS_DeckPro/main.py
>    ```
> 3. **Access the Break/Autobox Builder:**
>    - In the running app, go to the **Tools** menu.
>    - Select **Open Break/Autobox Builder**.
>    - Use the tabs to filter inventory, curate must-haves, set rules, and generate/export your break list.
> 
> ## Features & Workflow
> 
> - **Advanced Break/Autobox Builder:**
>   - Modular, rule-based, and curated break list generation.
>   - Dynamic filtering, live preview, cost calculation, and export.
>   - Save/load rule sets, batch inventory operations, and undo support.
>   - **Filler Cards:** If your rules/curation do not fill the break, remaining slots are filled with available cards ("filler"), and their Whatnot price is shown and used in calculations.
>   - **Whatnot Price Minimum Rule:**
>     - For all break cost and average calculations, any card with a Whatnot price of 0 is treated as 1 (display still shows the original value).
>     - This ensures compliance with Whatnot's minimum price policy and accurate break math.
>   - **Break Preview:**
>     - All cards (including filler) show their Whatnot price in the preview.
>     - Rule-based cards also show the fields that matched the rule.
>     - Curated, rule-based, and filler cards are clearly separated in the preview.
>   - **Cost/Average Calculation:**
>     - The total and average Whatnot price is shown at the bottom of the break builder.
>     - All cards (including filler) are included, and 0 prices are counted as 1 for math.
> 
> - **Whatnot Packing Slip Processing:**
>   - Robust PDF parsing with `pdfplumber`.
>   - **Sale Parsing:** Card name and foil/normal status are always split and normalized, even if the status is in the name (e.g., "Bribery normal").
>   - **Matching:** Cards are matched if at least three fields match, with collector number, foil/normal, and set code prioritized after name. Fuzzy matching and set code aliases are used for best results.
>   - **Ambiguity Handling:** If multiple inventory cards match except for language, and language is not specified, the user is prompted to resolve the ambiguity.
>   - **Undo/Restore:** Every packing slip removal can be undone from the File menu.
>   - **No Auto-Remove:** Cards are not removed from inventory or files moved until the user confirms.
>   - **Debugging:** All not-found cards are logged with detailed debug output for troubleshooting.
> 
> - **Buyers Database & Analytics:**
>   - Tracks buyers, purchase history, and analytics for future CRM features.
> 
> - **Full test coverage and CI integration.**
>   - All core logic is covered by regression and edge-case tests.
>   - Sale parsing and matching logic are tested for all known edge cases.
> 
> ## Requirements
> 
> - All dependencies are listed in `FoS_DeckPro/requirements.txt`.
> - Key packages:
>   - `PySide6` (GUI)
>   - `pandas`, `requests`, `tqdm`, `pillow`, `pdfplumber`
>   - See the requirements file for the full list.
> 
> ## Testing
> 
> - To run tests:
>   ```sh
>   PYTHONPATH=$PYTHONPATH:$(pwd) pytest FoS_DeckPro/tests --maxfail=3 --disable-warnings -v
>   ```
> - For GUI tests in headless environments, use Xvfb:
>   ```sh
>   xvfb-run -a pytest FoS_DeckPro/tests --maxfail=3 --disable-warnings -v
>   ```
> 
> ## Versioning & GitHub Best Practices
> 
> - Each stable, working version is tagged (e.g., `v1.6.0`) and has a dedicated branch (e.g., `v1.6.0-working`).
> - All changes are documented in the `CHANGELOG.md` and committed with clear messages.
> - Releases are created on GitHub for easy download, rollback, and reproducibility.
> - Always use the provided `requirements.txt` and follow the Quick Start for setup on new machines.
> 
> ## AI Contributor & Developer Guide
> 
> - **Modular Design:** All features are implemented as encapsulated modules/classes with clear interfaces.
> - **No Cross-Module Manipulation:** Use only public methods/events for communication between modules.
> - **Backward Compatibility:** Never break or remove a working feature without a migration plan and tests.
> - **Incremental Refactoring:** Refactor in small, testable steps. Run all tests after each change.
> - **Unit Testing:** Every module has unit tests for its core logic. All tests must pass before merging.
> - **Documentation:** Every class and function has a docstring explaining its purpose and usage.
> - **Centralized Configuration:** All config/constants are in a config file or module.
> - **Consistent UI/UX:** All UI components follow a consistent style and interaction pattern.
> - **Safe Fallbacks and Error Handling:** All features provide safe fallbacks and user-friendly error messages.
> - **Feature Isolation:** New features must be independently enable/disable-able and not affect unrelated features.
> - **Full-Data Operations:** All filtering/exporting/analytics operate on the full filtered dataset, not just the current GUI page.
> - **Extensibility:** The codebase is structured so new features/modules can be added without modifying or risking existing features.
> - **Process Documentation:** The process for adding new features/modules is documented for future enhancements.
> 
5,7c100,102
< - This project is now tracked with Git for full version control and history.
< - **README.md will be updated for every change, feature, or fix.**
< - All contributors must document what was changed, why, and how it was tested in this file.
---
> - This project is tracked with Git for full version control and history.
> - **README.md and CHANGELOG.md are updated for every change, feature, or fix.**
> - All contributors must document what was changed, why, and how it was tested in these files.
9a105,122
> ---
> 
> ## Project Overview
> 
> FoS-DeckPro is a modular, extensible tool for managing and enhancing card inventory workflows. All modules, features, and changes are documented below.
> 
> ---
> 
> ## Change Log
> 
> See `CHANGELOG.md` for a full history of all changes and releases.
> 
> ## Notes
> 
> - This is the advanced, modular PySide6 version described in the documentation and changelog.
> - The Whatnot packing slip PDF feature is under active development.
> - For any issues, ensure all requirements are installed and you are running the app from the correct entry point (`main.py`).
> 
18c131
< ManaBox Enhancer is a modular, extensible tool for managing and enhancing card inventory workflows. All modules, features, and changes are documented below.
---
> FoS-DeckPro is a modular, extensible tool for managing and enhancing card inventory workflows. All modules, features, and changes are documented below.
Only in FoS-DeckPro: Singles_for_sale.csv
Only in FoS-DeckPro: Sinlges_for_Sale.json
Only in FoS-DeckPro: Whatnot Card Inventory - Template (3).csv
Only in FoS_DeckPro: __pycache__
Only in FoS-DeckPro: break_export_templates.json
Only in FoS-DeckPro: column_config.json
diff -r FoS-DeckPro/column_prefs.json FoS_DeckPro/column_prefs.json
2a3
>     "Name",
5d5
<     "Name",
12c12,29
<     "Whatnot price"
---
>     "Whatnot price",
>     "Altered",
>     "ManaBox ID",
>     "Misprint",
>     "Purchase price currency",
>     "Quantity",
>     "Scryfall ID",
>     "color_identity",
>     "colors",
>     "image_url",
>     "legal_commander",
>     "legal_pauper",
>     "mana_cost",
>     "oracle_text",
>     "type_line",
>     "_original_order",
>     "cmc",
>     "quantity"
14a32
>     "Name",
17d34
<     "Name",
24c41,58
<     "Whatnot price"
---
>     "Whatnot price",
>     "Altered",
>     "ManaBox ID",
>     "Misprint",
>     "Purchase price currency",
>     "Quantity",
>     "Scryfall ID",
>     "color_identity",
>     "colors",
>     "image_url",
>     "legal_commander",
>     "legal_pauper",
>     "mana_cost",
>     "oracle_text",
>     "type_line",
>     "_original_order",
>     "cmc",
>     "quantity"
26,37c60
<   "column_widths": {
<     "Set name": 100,
<     "Set code": 100,
<     "Name": 174,
<     "Collector number": 100,
<     "Rarity": 100,
<     "Condition": 100,
<     "Foil": 100,
<     "Language": 100,
<     "Purchase price": 100,
<     "Whatnot price": 100
<   }
---
>   "column_widths": {}
Only in FoS-DeckPro: deckforge_ai
Only in FoS_DeckPro/docs: GETTING_STARTED.md
Only in FoS_DeckPro/docs: ROADMAP.md
Only in FoS_DeckPro/docs: TUTORIALS.md
diff -r FoS-DeckPro/docs/architecture.md FoS_DeckPro/docs/architecture.md
1c1
< ## Branching and Release Workflow (Best Practices)
---
> # FoS-DeckPro Architecture (v1.5.1)
3,9c3
< - The `main` branch always contains the best working, stable, and production-ready code.
< - All new features, bugfixes, or experimental work should be done in separate branches (e.g., `feature/xyz`, `experiment/v1.4.0-semi-working`).
< - Only merge a feature or experiment branch into `main` after it is fully tested and confirmed to work as intended.
< - Use tags (e.g., `v1.4.0`) to mark stable releases on the `main` branch.
< - Avoid tagging experimental or semi-working versions as official releases unless needed for reference.
< - Never push untested or unstable code directly to `main`.
< - Always ensure `main` is deployable and represents the best working state.
---
> ## Overview
11c5,38
< This workflow ensures stability, traceability, and safe collaboration for all contributors.
---
> FoS-DeckPro v1.5.1 is a modular, extensible application for managing card inventory, building Whatnot breaks, and processing packing slips. The codebase is organized for maintainability, testability, and future extensibility.
> 
> ## Structure
> 
> - **ManaBox_Enhancer/**
>   - `main.py`: Main entry point (PySide6 GUI)
>   - `logic/`: Core business logic (inventory, buyers, PDF parsing, etc.)
>   - `models/`: Data models (Card, Inventory, Filters, Scryfall API)
>   - `ui/`: Modular UI components (main window, dialogs, overlays)
>   - `utils/`: Utility modules (config, logging, file management)
>   - `tests/`: Full test suite for all modules and workflows
>   - `resources/`: (Reserved for future static assets)
>   - `docs/`: Documentation and style guides
>   - `requirements.txt`: All dependencies
>   - `README.md`: User and contributor documentation
>   - `CHANGELOG.md`: Release notes and change history
>   - **Break templates/configs**: (e.g., `50-30-15-5.json`, `500 spot break.json`) are in the project root for use by the break builder and export tools.
> 
> ## Legacy & Backups
> - All legacy scripts, backup data, and non-essential files are now isolated in a private folder and are not included in the public release.
> 
> ## Main Workflows
> - **Break Builder:** Modular, rule-based, and curated break list generation with dynamic filtering, preview, and export.
> - **Whatnot Packing Slip Processing:** Robust PDF parsing, best-match logic (at least three fields must match, prioritizing collector number, foil/normal, set code after name), ambiguity handling (user intervention for language ambiguity), and undo/restore.
> - **Buyers Database:** Modular buyers DB with analytics, updated on every slip processed.
> - **Testing:** All logic and workflows are covered by unit and integration tests.
> 
> ## Extensibility
> - All modules are designed for easy extension and future features (packs, bundles, accessories, etc.).
> - Configuration and constants are centralized for maintainability.
> 
> ## Notes
> - See `README.md` for usage and workflow details.
> - See `CHANGELOG.md` for release history and rationale.
Only in FoS_DeckPro/docs: tutorial_building_first_break.md
Only in FoS_DeckPro/docs: tutorial_processing_packing_slip.md
Only in FoS_DeckPro/docs: tutorial_undo_removal.md
diff -r FoS-DeckPro/docs/ui-style-guide.md FoS_DeckPro/docs/ui-style-guide.md
0a1,28
> # FoS-DeckPro UI Style Guide (v1.5.1)
> 
> ## Overview
> 
> FoS-DeckPro v1.5.1 uses a modern, modular, and consistent UI/UX throughout the application. All components are designed for clarity, accessibility, and ease of use.
> 
> ## UI/UX Principles
> - **Consistency:** All dialogs, overlays, and main windows use a unified style and layout.
> - **Accessibility:** Font sizes, colors, and controls are chosen for readability and accessibility.
> - **Responsiveness:** All main windows and dialogs are resizable and adapt to different screen sizes.
> - **Feedback:** Progress bars, status labels, and confirmation dialogs provide clear feedback for all actions.
> - **Error Handling:** All errors are shown with user-friendly messages and safe fallbacks.
> - **Separation of Concerns:** Each UI component (main window, dialogs, overlays) is implemented as a separate, reusable module.
> 
> ## Main Components
> - **Main Window:** Central hub for inventory, break builder, and tools.
> - **Break/Autobox Builder:** Tabbed interface for filtering, curation, rule-based selection, and preview/export.
> - **Dialogs:** Modular dialogs for file selection, ambiguity resolution, and summary/confirmation.
> - **Overlays:** Filter overlays and image previews are implemented as reusable widgets.
> 
> ## Best Practices
> - Use only public methods/events for UI communication.
> - All new UI features must follow the established style and interaction patterns.
> - Document any new UI component or pattern in this guide.
> 
> ## Notes
> - For details on workflows and features, see `README.md`.
> - For technical architecture, see `architecture.md`.
Only in FoS-DeckPro: enrichment_backups
Only in FoS_DeckPro/logic: .DS_Store
Only in FoS_DeckPro/logic: __pycache__
Only in FoS_DeckPro/logic: whatnot_buyer_db.py
Only in FoS_DeckPro/logic: whatnot_inventory_removal.py
Only in FoS_DeckPro/logic: whatnot_packing_slip_parser.py
Only in FoS-DeckPro: manabox_enhancer_gui.py
Only in FoS_DeckPro/models: .DS_Store
Only in FoS_DeckPro/models: __pycache__
diff -r FoS-DeckPro/models/card.py FoS_DeckPro/models/card.py
8,12c8
<     "Whatnot price",
<     # Scryfall price fields
<     "price_usd", "price_usd_foil", "price_usd_etched", "price_eur", "price_eur_foil", "price_eur_etched", "price_tix",
<     # Scryfall purchase URIs
<     "buy_tcgplayer", "buy_cardmarket", "buy_cardhoarder", "buy_mtgo", "buy_cardkingdom", "buy_cardkingdom_foil"
---
>     "Whatnot price"
diff -r FoS-DeckPro/models/scryfall_api.py FoS_DeckPro/models/scryfall_api.py
4c4
<     """Fetch card data from Scryfall API, including all available price fields and purchase URIs."""
---
>     """Fetch card data from Scryfall API"""
17,20d16
<         # Get price fields
<         prices = data.get("prices", {})
<         # Get purchase URIs
<         purchase_uris = data.get("purchase_uris", {})
29,44c25
<             "image_url": image_url,
<             # Scryfall price fields
<             "price_usd": prices.get("usd"),
<             "price_usd_foil": prices.get("usd_foil"),
<             "price_usd_etched": prices.get("usd_etched"),
<             "price_eur": prices.get("eur"),
<             "price_eur_foil": prices.get("eur_foil"),
<             "price_eur_etched": prices.get("eur_etched"),
<             "price_tix": prices.get("tix"),
<             # Scryfall purchase URIs
<             "buy_tcgplayer": purchase_uris.get("tcgplayer"),
<             "buy_cardmarket": purchase_uris.get("cardmarket"),
<             "buy_cardhoarder": purchase_uris.get("cardhoarder"),
<             "buy_mtgo": purchase_uris.get("mtgo"),
<             "buy_cardkingdom": purchase_uris.get("cardkingdom"),
<             "buy_cardkingdom_foil": purchase_uris.get("cardkingdom_foil"),
---
>             "image_url": image_url
56,69c37
<             "image_url": "",
<             "price_usd": None,
<             "price_usd_foil": None,
<             "price_usd_etched": None,
<             "price_eur": None,
<             "price_eur_foil": None,
<             "price_eur_etched": None,
<             "price_tix": None,
<             "buy_tcgplayer": None,
<             "buy_cardmarket": None,
<             "buy_cardhoarder": None,
<             "buy_mtgo": None,
<             "buy_cardkingdom": None,
<             "buy_cardkingdom_foil": None,
---
>             "image_url": ""
diff -r FoS-DeckPro/requirements.txt FoS_DeckPro/requirements.txt
1,4c1,114
< PyQt6
< PySide6
< pandas
< pyperclip 
\ No newline at end of file
---
> aiohttp==3.9.5
> aiosignal==1.3.1
> altgraph==0.17.4
> annotated-types==0.6.0
> anyio==4.3.0
> attrs==23.2.0
> Babel==2.15.0
> beautifulsoup4==4.12.3
> certifi==2024.2.2
> cffi==1.17.1
> charset-normalizer==3.3.2
> click==8.1.7
> colorama==0.4.6
> cryptography==45.0.3
> decorator==4.4.2
> distro==1.9.0
> flake8==7.0.0
> frozenlist==1.4.1
> ghp-import==2.1.0
> h11==0.14.0
> httpcore==1.0.5
> httpx==0.27.0
> idna==3.7
> imageio==2.34.1
> imageio-ffmpeg==0.4.9
> iniconfig==2.0.0
> Jinja2==3.1.4
> joblib==1.4.2
> jsonschema==4.23.0
> jsonschema-specifications==2025.4.1
> line_profiler==4.1.3
> lxml==5.2.2
> macholib==1.16.3
> Markdown==3.6
> MarkupSafe==2.1.5
> mccabe==0.7.0
> memory-profiler==0.61.0
> mergedeep==1.3.4
> mkdocs==1.6.0
> mkdocs-get-deps==0.2.0
> mkdocs-material==9.5.26
> mkdocs-material-extensions==1.3.1
> moviepy==1.0.3
> multidict==6.0.5
> nltk==3.8.1
> numpy==1.26.4
> openai==0.28.0
> opencv-python-headless==4.9.0.80
> outcome==1.3.0.post0
> packaging==24.0
> paginate==0.5.6
> pandas==2.2.3
> pathspec==0.12.1
> pdfminer.six==20250327
> pdfplumber==0.11.6
> pillow==10.3.0
> platformdirs==4.2.2
> pluggy==1.5.0
> proglog==0.1.10
> prompt_generator @ file:///Users/jgleason/FoSGamers/Development/Development-Main/PromptMaker_v1.1
> psutil==5.9.8
> pycodestyle==2.11.1
> pycparser==2.22
> pydantic==2.7.1
> pydantic_core==2.18.2
> pyflakes==3.2.0
> Pygments==2.18.0
> pyinstaller==6.13.0
> pyinstaller-hooks-contrib==2025.4
> pymdown-extensions==10.8.1
> PyPDF2==3.0.1
> pypdfium2==4.30.1
> pyperclip==1.9.0
> PyQt5==5.15.10
> PyQt5-Qt5==5.15.13
> PyQt5-sip==12.13.0
> PyQtWebEngine==5.15.6
> PyQtWebEngine-Qt5==5.15.13
> PySide6==6.6.0
> PySide6-Addons==6.6.0
> PySide6-Essentials==6.6.0
> PySocks==1.7.1
> pytest==8.2.2
> pytest-qt==4.4.0
> python-dateutil==2.9.0.post0
> python-docx==1.1.2
> python-dotenv==1.0.1
> pytz==2025.2
> PyYAML==6.0.1
> pyyaml_env_tag==0.1
> referencing==0.36.2
> regex==2024.5.15
> requests==2.31.0
> rpds-py==0.25.1
> schedule==1.2.2
> selenium==4.20.0
> setuptools==69.5.1
> shiboken6==6.6.0
> six==1.16.0
> sniffio==1.3.1
> sortedcontainers==2.4.0
> soupsieve==2.5
> tk==0.1.0
> tqdm==4.66.4
> trio==0.25.0
> trio-websocket==0.11.1
> typing_extensions==4.11.0
> tzdata==2025.2
> urllib3==2.2.1
> watchdog==4.0.1
> webdriver-manager==4.0.1
> wheel==0.43.0
> wsproto==1.2.0
> yarl==1.9.4
Only in FoS_DeckPro: resources
Only in FoS-DeckPro: run_fos_deckpro.py
Only in FoS-DeckPro: setup_project_structure.sh
Only in FoS-DeckPro: test.csv
Only in FoS_DeckPro/tests: .DS_Store
Only in FoS_DeckPro/tests: __pycache__
Only in FoS_DeckPro/tests: test_break_builder.py
Only in FoS_DeckPro/tests: test_packing_slip_file_manager.py
Only in FoS_DeckPro/tests: test_whatnot_buyer_db.py
Only in FoS_DeckPro/tests: test_whatnot_inventory_removal.py
Only in FoS_DeckPro/tests: test_whatnot_packing_slip_parser.py
Only in FoS_DeckPro/ui: .DS_Store
Binary files FoS-DeckPro/ui/__pycache__/__init__.cpython-312.pyc and FoS_DeckPro/ui/__pycache__/__init__.cpython-312.pyc differ
Only in FoS_DeckPro/ui/__pycache__: card_details.cpython-312.pyc
Only in FoS_DeckPro/ui/__pycache__: card_table.cpython-312.pyc
Only in FoS_DeckPro/ui/__pycache__: columns_config.cpython-312.pyc
Only in FoS_DeckPro/ui/__pycache__: filter_overlay.cpython-312.pyc
Only in FoS_DeckPro/ui/__pycache__: filter_row.cpython-312.pyc
Only in FoS_DeckPro/ui/__pycache__: image_preview.cpython-312.pyc
Only in FoS_DeckPro/ui/__pycache__: main_window.cpython-312.pyc
diff -r FoS-DeckPro/ui/card_details.py FoS_DeckPro/ui/card_details.py
1c1
< from PySide6.QtWidgets import QWidget, QVBoxLayout, QGridLayout, QLabel, QGroupBox, QTextEdit, QHBoxLayout, QScrollArea
---
> from PySide6.QtWidgets import QWidget, QVBoxLayout, QGridLayout, QLabel, QGroupBox, QTextEdit, QHBoxLayout, QScrollArea, QFormLayout, QSizePolicy, QFrame
31,43d30
<     "price_usd": "TCGplayer Market (USD)",
<     "price_usd_foil": "TCGplayer Foil (USD)",
<     "price_usd_etched": "TCGplayer Etched (USD)",
<     "price_eur": "Cardmarket (EUR)",
<     "price_eur_foil": "Cardmarket Foil (EUR)",
<     "price_eur_etched": "Cardmarket Etched (EUR)",
<     "price_tix": "MTGO Tix",
<     "buy_tcgplayer": "Buy on TCGplayer",
<     "buy_cardmarket": "Buy on Cardmarket",
<     "buy_cardhoarder": "Buy on Cardhoarder",
<     "buy_mtgo": "Buy on MTGO",
<     "buy_cardkingdom": "Buy on Card Kingdom",
<     "buy_cardkingdom_foil": "Buy Foil on Card Kingdom",
50a38,40
>     """
>     Widget to display all key card info in a readable, modern, scrollable layout.
>     """
53,57c43,69
<         self.vlayout = QVBoxLayout()
<         self.setLayout(self.vlayout)
<         self.grid_layout = None
<         self.oracle_group = None
<         self.oracle_text = None
---
>         self.setStyleSheet("background: #f8fafd; border: 1.5px solid #b3c6e0; border-radius: 10px; padding: 10px 10px 10px 10px;")
>         self.scroll = QScrollArea(self)
>         self.scroll.setWidgetResizable(True)
>         self.scroll.setFrameShape(QFrame.NoFrame)
>         self.inner = QWidget()
>         self.form = QFormLayout(self.inner)
>         self.form.setLabelAlignment(Qt.AlignRight | Qt.AlignVCenter)
>         self.form.setFormAlignment(Qt.AlignTop)
>         self.form.setSpacing(8)
>         self.labels = {}
>         for key in [
>             "Name", "Set name", "Set code", "Collector number", "Rarity", "Condition", "Foil", "Language", "Purchase price", "Whatnot price", "type_line", "mana_cost", "colors", "oracle_text"
>         ]:
>             l = QLabel()
>             l.setWordWrap(True)
>             l.setStyleSheet("font-size: 15px; color: #222; padding: 2px 0;")
>             self.labels[key] = l
>             label_widget = QLabel(f"<b>{key.replace('_', ' ').title()}:</b>")
>             label_widget.setStyleSheet("font-size: 15px; color: #1976d2; padding: 2px 0;")
>             self.form.addRow(label_widget, l)
>         self.inner.setLayout(self.form)
>         self.scroll.setWidget(self.inner)
>         layout = QVBoxLayout(self)
>         layout.setContentsMargins(0, 0, 0, 0)
>         layout.addWidget(self.scroll)
>         self.setMinimumHeight(180)
>         self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
59,71d70
<         # Add a scroll area for the details content
<         self.scroll_area = QScrollArea(self)
<         self.scroll_area.setWidgetResizable(True)
<         self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
<         self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
<         self.vlayout.addWidget(self.scroll_area)
< 
<         # The widget that will actually hold the details
<         self.details_widget = QWidget()
<         self.details_layout = QVBoxLayout()
<         self.details_widget.setLayout(self.details_layout)
<         self.scroll_area.setWidget(self.details_widget)
< 
73,117c72,83
<         # DEBUG: Print the full card dict
<         print("DEBUG: Card details for preview:", card)
<         # Clear previous widgets and layouts from the details layout
<         while self.details_layout.count():
<             item = self.details_layout.takeAt(0)
<             if item.widget() is not None:
<                 item.widget().deleteLater()
<             elif item.layout() is not None:
<                 self._delete_layout(item.layout())
<         # Prepare fields (excluding oracle_text and hidden fields)
<         fields = [(k, v) for k, v in card.items() if k != "oracle_text" and k not in HIDE_FIELDS and v not in (None, "")]
<         # Use a single QGridLayout with two columns of fields (label/value, label/value per row)
<         grid = QGridLayout()
<         num_fields = len(fields)
<         for i in range(0, num_fields, 2):
<             # Left column
<             key1, value1 = fields[i]
<             label1 = QLabel(FRIENDLY_NAMES.get(key1, key1) + ":")
<             label1.setFont(QFont("Arial", weight=QFont.Bold))
<             label1.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
<             val_label1 = QLabel(str(value1))
<             val_label1.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
<             grid.addWidget(label1, i // 2, 0)
<             grid.addWidget(val_label1, i // 2, 1)
<             # Right column (if exists)
<             if i + 1 < num_fields:
<                 key2, value2 = fields[i + 1]
<                 label2 = QLabel(FRIENDLY_NAMES.get(key2, key2) + ":")
<                 label2.setFont(QFont("Arial", weight=QFont.Bold))
<                 label2.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
<                 val_label2 = QLabel(str(value2))
<                 val_label2.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
<                 grid.addWidget(label2, i // 2, 2)
<                 grid.addWidget(val_label2, i // 2, 3)
<         self.details_layout.addLayout(grid)
<         # Show oracle_text in a QTextEdit at the end if present
<         if "oracle_text" in card and card["oracle_text"]:
<             group = QGroupBox("Oracle Text")
<             vbox = QVBoxLayout()
<             self.oracle_text = QTextEdit()
<             self.oracle_text.setReadOnly(True)
<             self.oracle_text.setPlainText(card["oracle_text"])
<             vbox.addWidget(self.oracle_text)
<             group.setLayout(vbox)
<             self.details_layout.addWidget(group)
---
>         """
>         Update the details area with all key info from the card dict.
>         """
>         for key, label in self.labels.items():
>             val = card.get(key, "")
>             if key == "colors" and isinstance(val, (list, tuple)):
>                 val = ", ".join(val)
>             if key == "oracle_text":
>                 val = val.replace("\n", "<br>")
>                 label.setText(f'<span style="font-size:14px; color:#444;">{val}</span>')
>             else:
>                 label.setText(str(val))
diff -r FoS-DeckPro/ui/columns_config.py FoS_DeckPro/ui/columns_config.py
0a1,3
> # Centralized default columns for card tables in FoS-DeckPro
> # Used by both main_window.py and break_builder.py
> 
3,5c6
<     "Condition", "Foil", "Language", "Purchase price", "Whatnot price",
<     "price_usd", "price_usd_foil", "price_usd_etched", "price_eur", "price_eur_foil", "price_eur_etched", "price_tix",
<     "buy_tcgplayer", "buy_cardmarket", "buy_cardhoarder", "buy_mtgo", "buy_cardkingdom", "buy_cardkingdom_foil"
---
>     "Condition", "Foil", "Language", "Purchase price", "Whatnot price"
Only in FoS_DeckPro/ui/dialogs: .DS_Store
Only in FoS_DeckPro/ui/dialogs: __pycache__
diff -r FoS-DeckPro/ui/dialogs/break_builder.py FoS_DeckPro/ui/dialogs/break_builder.py
1,2c1,2
< from PySide6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QLineEdit, QListWidget, QListWidgetItem, QTabWidget, QTableWidget, QTableWidgetItem, QComboBox, QMessageBox, QCheckBox, QFileDialog, QInputDialog, QWidget, QFormLayout, QGroupBox, QGridLayout, QSplitter, QScrollArea, QTextEdit, QDialogButtonBox
< from PySide6.QtCore import Qt
---
> from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QLineEdit, QListWidget, QListWidgetItem, QTabWidget, QTableWidget, QTableWidgetItem, QComboBox, QMessageBox, QCheckBox, QFileDialog, QInputDialog, QWidget, QFormLayout, QScrollArea, QSizePolicy, QFrame, QSpinBox, QDoubleSpinBox, QGroupBox, QAbstractItemView, QSplitter, QTextEdit, QStyle)
> from PySide6.QtCore import Qt, QPropertyAnimation, QEasingCurve, QRect
4d3
< from models.card import CARD_FIELDS
5a5,9
> import json
> from ui.card_table import CardTableView
> from ui.filter_overlay import FilterOverlay
> from ui.image_preview import ImagePreview
> from ui.card_details import CardDetails
6a11
> import csv
8,9c13,14
< import json
< import copy
---
> from ui.columns_config import DEFAULT_COLUMNS
> from models.card import CARD_FIELDS
10a16,196
> # Centralized config/constants for break builder
> BREAK_BUILDER_CONFIG = {
>     'rule_fields': [
>         {'name': 'Price', 'type': 'float', 'label': 'Price ($)', 'min': 0, 'max': 10000, 'step': 0.01},
>         {'name': 'Whatnot price', 'type': 'float', 'label': 'Whatnot Price', 'min': 0, 'max': 10000, 'step': 0.01},
>         {'name': 'Purchase price', 'type': 'float', 'label': 'Purchase Price', 'min': 0, 'max': 10000, 'step': 0.01},
>         {'name': 'Rarity', 'type': 'str', 'label': 'Rarity', 'choices': ['common', 'uncommon', 'rare', 'mythic']},
>         {'name': 'Set name', 'type': 'str', 'label': 'Set Name'},
>         # Add more fields as needed
>     ],
>     'max_rules': 10,
>     'template_file': 'break_templates.json',
> }
> 
> class BreakRuleWidget(QWidget):
>     """
>     Widget for a single rule in the break builder.
>     Supports AND logic: user can add multiple field criteria per rule.
>     """
>     def __init__(self, parent=None, inventory_fields=None, inventory=None):
>         super().__init__(parent)
>         self.inventory = inventory
>         self.inventory_fields = inventory_fields or []
>         layout = QVBoxLayout(self)
>         # Top row: count/percent
>         count_row = QHBoxLayout()
>         self.count_type = QComboBox()
>         self.count_type.addItems(["Count", "% of available"])
>         self.count_type.setToolTip("Choose whether to select a fixed number or a percentage of cards matching this rule.")
>         self.count_value = QSpinBox()
>         self.count_value.setMinimum(1)
>         self.count_value.setMaximum(1000)
>         self.percent_value = QDoubleSpinBox()
>         self.percent_value.setMinimum(1)
>         self.percent_value.setMaximum(100)
>         self.percent_value.setSuffix("%")
>         self.percent_value.setVisible(False)
>         self.count_type.currentIndexChanged.connect(self._toggle_count_type)
>         count_row.addWidget(QLabel("Select:"))
>         count_row.addWidget(self.count_type)
>         count_row.addWidget(self.count_value)
>         count_row.addWidget(self.percent_value)
>         count_row.addStretch(1)
>         layout.addLayout(count_row)
>         # Criteria area
>         self.criteria_area = QVBoxLayout()
>         self.criteria_widgets = []  # List of (field_dropdown, input_widget, remove_btn)
>         layout.addLayout(self.criteria_area)
>         # Add Field button
>         add_field_btn = QPushButton("+ Add Field")
>         add_field_btn.setStyleSheet("background: #e3eaf7; color: #1976d2; font-weight: bold; border-radius: 6px; padding: 4px 12px;")
>         add_field_btn.clicked.connect(self.add_criterion_row)
>         layout.addWidget(add_field_btn)
>         # Remove rule button
>         self.remove_btn = QPushButton("Remove Rule")
>         self.remove_btn.setStyleSheet("color: red;")
>         layout.addWidget(self.remove_btn)
>         layout.addStretch(1)
>         # Add initial criterion row
>         self.add_criterion_row()
>     def add_criterion_row(self, field=None):
>         row = QHBoxLayout()
>         field_dropdown = QComboBox()
>         field_dropdown.addItems([f for f in self.inventory_fields])
>         if field:
>             idx = field_dropdown.findText(field)
>             if idx >= 0:
>                 field_dropdown.setCurrentIndex(idx)
>         input_widget = QWidget()
>         input_layout = QHBoxLayout(input_widget)
>         input_layout.setContentsMargins(0, 0, 0, 0)
>         # Build input for selected field
>         self._build_field_input(field_dropdown.currentText(), input_layout, input_widget)
>         field_dropdown.currentTextChanged.connect(lambda f, l=input_layout, w=input_widget: self._on_field_changed(f, l, w))
>         remove_btn = QPushButton("âœ•")
>         remove_btn.setFixedSize(24, 24)
>         remove_btn.setStyleSheet("color: #e53935; font-weight: bold; border: none; background: transparent;")
>         remove_btn.clicked.connect(lambda: self._remove_criterion_row(row, (field_dropdown, input_widget, remove_btn)))
>         row.addWidget(field_dropdown)
>         row.addWidget(input_widget)
>         row.addWidget(remove_btn)
>         self.criteria_area.addLayout(row)
>         self.criteria_widgets.append((field_dropdown, input_widget, remove_btn))
>     def _remove_criterion_row(self, row_layout, widget_tuple):
>         for i in reversed(range(row_layout.count())):
>             item = row_layout.takeAt(i)
>             if item.widget():
>                 item.widget().deleteLater()
>         self.criteria_area.removeItem(row_layout)
>         if widget_tuple in self.criteria_widgets:
>             self.criteria_widgets.remove(widget_tuple)
>     def _on_field_changed(self, field, input_layout, input_widget):
>         # Clear old input
>         for i in reversed(range(input_layout.count())):
>             item = input_layout.takeAt(i)
>             if item.widget():
>                 item.widget().deleteLater()
>         self._build_field_input(field, input_layout, input_widget)
>     def _build_field_input(self, field, input_layout, input_widget):
>         values = [c.get(field, "") for c in self.inventory.get_all_cards()] if self.inventory else []
>         try:
>             nums = [float(str(v).replace("$", "").strip()) for v in values if str(v).replace("$", "").strip() != ""]
>         except Exception:
>             nums = []
>         if len(nums) >= len(values) * 0.8 and len(nums) > 0:
>             min_box = QDoubleSpinBox()
>             min_box.setMinimum(-100000)
>             min_box.setMaximum(100000)
>             min_box.setSingleStep(0.01)
>             min_box.setPrefix(">= ")
>             max_box = QDoubleSpinBox()
>             max_box.setMinimum(-100000)
>             max_box.setMaximum(100000)
>             max_box.setSingleStep(0.01)
>             max_box.setPrefix("<= ")
>             input_layout.addWidget(min_box)
>             input_layout.addWidget(max_box)
>             input_widget._field_input = (min_box, max_box)
>         elif 1 < len(set(values)) <= 12:
>             combo = QComboBox()
>             combo.addItem("")
>             combo.addItems(sorted(set(str(v) for v in values if v != "")))
>             input_layout.addWidget(combo)
>             input_widget._field_input = combo
>         else:
>             edit = QLineEdit()
>             edit.setPlaceholderText(f"Filter {field}")
>             input_layout.addWidget(edit)
>             input_widget._field_input = edit
>     def get_rule(self):
>         rule = {}
>         rule['count_type'] = self.count_type.currentText()
>         rule['count'] = self.count_value.value() if self.count_type.currentIndex() == 0 else self.percent_value.value()
>         rule['criteria'] = []
>         for field_dropdown, input_widget, _ in self.criteria_widgets:
>             field = field_dropdown.currentText()
>             inp = getattr(input_widget, '_field_input', None)
>             if isinstance(inp, tuple):
>                 min_val = inp[0].value()
>                 max_val = inp[1].value()
>                 rule['criteria'].append((field, (min_val, max_val)))
>             elif isinstance(inp, QComboBox):
>                 rule['criteria'].append((field, inp.currentText()))
>             elif isinstance(inp, QLineEdit):
>                 rule['criteria'].append((field, inp.text().strip()))
>         return rule
>     def set_rule(self, rule):
>         self.count_type.setCurrentIndex(0 if rule.get('count_type') == 'Count' else 1)
>         if rule.get('count_type') == 'Count':
>             self.count_value.setValue(int(rule.get('count', 1)))
>         else:
>             self.percent_value.setValue(float(rule.get('count', 1)))
>         # Remove all but one criterion row
>         while len(self.criteria_widgets) > 1:
>             self._remove_criterion_row(self.criteria_area.itemAt(0), self.criteria_widgets[0])
>         # Set criteria
>         for i, (field, val) in enumerate(rule.get('criteria', [])):
>             if i >= len(self.criteria_widgets):
>                 self.add_criterion_row(field)
>             field_dropdown, input_widget, _ = self.criteria_widgets[i]
>             idx = field_dropdown.findText(field)
>             if idx >= 0:
>                 field_dropdown.setCurrentIndex(idx)
>             inp = getattr(input_widget, '_field_input', None)
>             if isinstance(inp, tuple):
>                 inp[0].setValue(val[0])
>                 inp[1].setValue(val[1])
>             elif isinstance(inp, QComboBox):
>                 idx2 = inp.findText(val)
>                 if idx2 >= 0:
>                     inp.setCurrentIndex(idx2)
>             elif isinstance(inp, QLineEdit):
>                 inp.setText(val)
>     def _toggle_count_type(self, idx):
>         if idx == 0:
>             self.count_value.setVisible(True)
>             self.percent_value.setVisible(False)
>         else:
>             self.count_value.setVisible(False)
>             self.percent_value.setVisible(True)
> 
13a200,203
>     Modernized for resizable, sidebar-based UI and advanced curation.
>     Now includes a powerful rule-based break builder for advanced users.
>     Allows user to specify the total number of cards needed for the break.
>     Curated card selection uses a full-featured CardTableView with filtering, images, and details.
17,21c207,210
<         # Initialize template-related attributes first
<         self.export_template = None  # Current template (dict with title_fields, desc_fields)
<         self.templates = self.load_templates()
<         self.setWindowTitle("FoS-DeckPro: Break/Autobox Builder")
<         self.resize(900, 600)
---
>         self.setWindowTitle("Break/Autobox Builder")
>         self.resize(1200, 800)
>         self.setMinimumSize(900, 600)
>         self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
22a212,220
>         # --- Total cards input (must be initialized before any method uses it) ---
>         self.total_cards_input = QSpinBox()
>         self.total_cards_input.setMinimum(1)
>         self.total_cards_input.setMaximum(10000)
>         self.total_cards_input.setValue(30)
>         self.total_cards_input.setToolTip("Specify the total number of cards needed for the break.")
>         self.total_cards_input.valueChanged.connect(self.generate_break_list)  # Always trigger full break list regeneration
>         # All required attributes must be initialized before any method that uses them (regression rule)
>         self.filtered_inventory = self.inventory.get_all_cards()
24,26c222,228
<         self.removed_from_inventory = []
<         self._undo_inventory = None
<         layout = QVBoxLayout(self)
---
>         self.curated_cards = []  # List of curated card dicts
>         self.rules = []  # List of rule dicts
>         self.rule_widgets = []  # List of BreakRuleWidget
>         self.current_break_list = []  # Flat list of cards in break (for export)
>         self.current_break_list_details = []  # [(section_type, section_info, [cards])]
>         self.filler_max_price = None  # Store user-set max filler price
>         # --- Tabbed workflow ---
28,36c230,245
<         layout.addWidget(self.tabs)
<         # Tab 1: Inventory Search/Select
<         self.inv_tab = QWidget()
<         inv_layout = QVBoxLayout(self.inv_tab)
<         inv_layout.addWidget(QLabel("Filter and select cards from inventory:"))
<         # --- Advanced Filter Grid ---
<         filter_group = QGroupBox("Card Filters (All Fields)")
<         filter_grid = QGridLayout()
<         self.filter_inputs = {}
---
>         self.tabs.setTabPosition(QTabWidget.North)
>         self.tabs.setMovable(False)
>         self.tabs.setStyleSheet("QTabBar::tab { min-width: 180px; font-size: 15px; font-weight: bold; padding: 8px 18px; } QTabBar::tab:selected { background: #1976d2; color: white; border-radius: 8px; }")
>         main_layout = QVBoxLayout(self)
>         main_layout.addWidget(self.tabs)
>         # --- Step 1: Filter Inventory Tab ---
>         filter_tab = QWidget()
>         filter_layout = QVBoxLayout(filter_tab)
>         # --- Inventory Section ---
>         inventory_group = QGroupBox("1. Inventory (Filter & Select)")
>         inventory_group.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #bbb; margin-top: 8px; padding: 12px 8px 18px 8px; background: #f7f7fa; } ")
>         inv_group_layout = QVBoxLayout(inventory_group)
>         inv_group_layout.setSpacing(10)
>         # Inventory area: table (left) + preview (right)
>         inv_hbox = QHBoxLayout()
>         # --- Dynamically get all fields from inventory for filtering ---
39,90c248,407
<         numeric_fields = {f for f in CARD_FIELDS if any(x in f.lower() for x in ["price", "quantity", "number", "count", "cmc"])}
<         for idx, field in enumerate(CARD_FIELDS):
<             row = idx // 3
<             col = (idx % 3) * 3
<             label = QLabel(field+":")
<             filter_grid.addWidget(label, row, col)
<             if field in numeric_fields:
<                 min_entry = QLineEdit()
<                 min_entry.setPlaceholderText("Min")
<                 max_entry = QLineEdit()
<                 max_entry.setPlaceholderText("Max")
<                 filter_grid.addWidget(min_entry, row, col+1)
<                 filter_grid.addWidget(max_entry, row, col+2)
<                 min_entry.textChanged.connect(self.update_inventory_list)
<                 max_entry.textChanged.connect(self.update_inventory_list)
<                 self.filter_inputs[field] = (min_entry, max_entry)
<             else:
<                 entry = QLineEdit()
<                 entry.setPlaceholderText("Value(s), comma for OR")
<                 filter_grid.addWidget(entry, row, col+1, 1, 2)
<                 entry.textChanged.connect(self.update_inventory_list)
<                 self.filter_inputs[field] = entry
<         filter_group.setLayout(filter_grid)
<         inv_layout.addWidget(filter_group)
<         # --- End Advanced Filter Grid ---
<         self.inv_list = QListWidget()
<         inv_layout.addWidget(self.inv_list)
<         self.add_selected_btn = QPushButton("Add Selected to Break List")
<         self.add_selected_btn.clicked.connect(self.add_selected_to_break)
<         inv_layout.addWidget(self.add_selected_btn)
<         # New: Random selection controls
<         rand_row = QHBoxLayout()
<         self.rand_count_input = QLineEdit()
<         self.rand_count_input.setPlaceholderText("Number to randomly select")
<         self.rand_select_btn = QPushButton("Randomly Select from Filtered")
<         self.rand_select_btn.clicked.connect(self.randomly_select_from_filtered)
<         rand_row.addWidget(self.rand_count_input)
<         rand_row.addWidget(self.rand_select_btn)
<         inv_layout.addLayout(rand_row)
<         self.tabs.addTab(self.inv_tab, "Inventory")
<         # Tab 2: Break List
<         self.break_tab = QWidget()
<         break_layout = QVBoxLayout(self.break_tab)
<         break_layout.addWidget(QLabel("Break/Autobox Items (drag to reorder, double-click to edit):"))
<         self.break_list = QListWidget()
<         self.break_list.setDragDropMode(QListWidget.InternalMove)
<         self.break_list.itemDoubleClicked.connect(self.edit_break_item)
<         break_layout.addWidget(self.break_list)
<         # --- Summary Section ---
<         self.summary_label = QLabel()
<         break_layout.addWidget(self.summary_label)
<         # --- End Summary Section ---
---
>         self.card_table = CardTableView(self.inventory, self.columns)
>         self.card_table.setSelectionMode(QAbstractItemView.MultiSelection)
>         self.card_table.setMinimumHeight(220)
>         self.card_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
>         # Add FilterOverlay above the table
>         self.filter_overlay = FilterOverlay(self.card_table, self.columns)
>         self.filter_overlay.show()
>         for col, filt in self.filter_overlay.filters.items():
>             filt.textChanged.connect(self.update_table_filter)
>         # --- Add Clear All Filters button above overlay ---
>         clear_filters_btn = QPushButton("Clear All Filters")
>         clear_filters_btn.setStyleSheet("padding: 4px 16px; border-radius: 8px; background: #e0e0e0; font-weight: bold;")
>         clear_filters_btn.clicked.connect(lambda: [f.clear() for f in self.filter_overlay.filters.values()])
>         clear_filters_btn.clicked.connect(self.update_table_filter)
>         self.clear_filters_btn = clear_filters_btn
>         # --- Group filter controls in a styled QFrame above the table ---
>         filter_controls_frame = QFrame()
>         filter_controls_frame.setFrameShape(QFrame.StyledPanel)
>         filter_controls_frame.setStyleSheet("background: #f5f7fa; border: 1.5px solid #b3c6e0; border-radius: 10px; padding: 2px 18px 2px 18px; margin-bottom: 2px;")
>         filter_controls_hbox = QHBoxLayout(filter_controls_frame)
>         filter_controls_hbox.setContentsMargins(0, 0, 0, 0)
>         filter_controls_hbox.setSpacing(10)
>         filter_controls_hbox.addWidget(self.filter_overlay, 1)
>         filter_controls_hbox.addWidget(clear_filters_btn, 0, Qt.AlignRight)
>         # --- Style the filter overlay for clarity ---
>         self.filter_overlay.setStyleSheet("background: #eaf1fb; border: 1px solid #b3c6e0; border-radius: 6px; padding: 2px 0 2px 0;")
>         # --- Table and preview layout ---
>         preview_frame = QFrame()
>         preview_frame.setFrameShape(QFrame.StyledPanel)
>         preview_frame.setStyleSheet("background: #f8fafd; border: 1.5px solid #b3c6e0; border-radius: 10px; padding: 10px 10px 10px 10px;")
>         preview_vbox = QVBoxLayout(preview_frame)
>         preview_vbox.setContentsMargins(0, 0, 0, 0)
>         preview_vbox.setSpacing(8)
>         self.image_preview = ImagePreview()
>         self.image_preview.setMinimumHeight(100)
>         self.image_preview.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
>         self.card_details = CardDetails()
>         self.card_details.setMinimumHeight(100)
>         self.card_details.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
>         preview_vbox.addWidget(self.image_preview)
>         preview_vbox.addWidget(self.card_details)
>         # --- Use QSplitter for table/preview, but add spacing and frame ---
>         table_preview_splitter = QSplitter()
>         table_preview_splitter.setOrientation(Qt.Horizontal)
>         table_preview_splitter.addWidget(self.card_table)
>         table_preview_splitter.addWidget(preview_frame)
>         table_preview_splitter.setSizes([700, 300])
>         table_preview_splitter.setChildrenCollapsible(False)
>         table_preview_splitter.setHandleWidth(8)
>         table_preview_splitter.setMinimumWidth(200)
>         table_preview_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
>         # --- Main inventory area layout ---
>         table_vbox = QVBoxLayout()
>         table_vbox.setContentsMargins(12, 12, 12, 12)
>         table_vbox.setSpacing(10)
>         table_vbox.addWidget(filter_controls_frame)
>         table_vbox.addWidget(table_preview_splitter)
>         table_vbox.addWidget(self.card_table.pagination_widget)
>         self.inventory_placeholder = QLabel("No cards in inventory.")
>         self.inventory_placeholder.setStyleSheet("color: #888; font-style: italic; padding: 6px;")
>         if not self.inventory.get_all_cards():
>             table_vbox.addWidget(self.inventory_placeholder)
>         inv_hbox.addLayout(table_vbox, 1)
>         inv_group_layout.addLayout(inv_hbox)
>         filter_layout.insertWidget(0, inventory_group)
>         # --- Ensure inventory table is populated on launch ---
>         self.card_table.update_cards(self.inventory.get_all_cards())
>         # --- Connect card_selected signal to preview widgets ---
>         def _debug_card_selected(card):
>             print(f"DEBUG: BreakBuilderDialog received card_selected: {card}")
>             self.image_preview.show_card_image(card)
>             self.card_details.show_card_details(card)
>         self.card_table.card_selected.connect(_debug_card_selected)
>         # --- Step 2: Curate Must-Haves Tab ---
>         curate_tab = QWidget()
>         curate_layout = QVBoxLayout(curate_tab)
>         curated_group = QGroupBox("2. Curated Cards (Guaranteed in Break)")
>         curated_group.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #bbb; margin-top: 8px; padding: 12px 8px 18px 8px; background: #f7f7fa; } ")
>         curated_layout = QVBoxLayout(curated_group)
>         curated_layout.setSpacing(10)
>         curated_layout.addWidget(QLabel("Drag to reorder. Remove to exclude from break."))
>         # Add/Remove buttons for curated list (modern, with icons)
>         curated_btn_row = QHBoxLayout()
>         self.add_to_curated_btn = QPushButton(" Add Selected to Curated")
>         self.add_to_curated_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DialogYesButton))
>         self.add_to_curated_btn.setStyleSheet("padding: 6px 18px; border-radius: 8px; background: #1976d2; color: white; font-weight: bold; font-size: 13px;")
>         self.add_to_curated_btn.setToolTip("Add selected cards from inventory to curated list.")
>         self.add_to_curated_btn.clicked.connect(self.add_selected_to_curated)
>         self.remove_from_curated_btn = QPushButton(" Remove Selected from Curated")
>         self.remove_from_curated_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DialogNoButton))
>         self.remove_from_curated_btn.setStyleSheet("padding: 6px 18px; border-radius: 8px; background: #e53935; color: white; font-weight: bold; font-size: 13px;")
>         self.remove_from_curated_btn.setToolTip("Remove selected cards from curated list.")
>         self.remove_from_curated_btn.clicked.connect(self.remove_selected_from_curated)
>         curated_btn_row.addWidget(self.add_to_curated_btn)
>         curated_btn_row.addWidget(self.remove_from_curated_btn)
>         curated_btn_row.addStretch(1)
>         curated_layout.addLayout(curated_btn_row)
>         self.curated_table = CardTableView(self, self.columns)
>         self.curated_table.setSelectionMode(QAbstractItemView.MultiSelection)
>         self.curated_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
>         self.curated_table.setMinimumHeight(140)
>         curated_layout.addWidget(self.curated_table)
>         # Placeholder for empty curated table
>         self.curated_placeholder = QLabel("No curated cards yet.")
>         self.curated_placeholder.setStyleSheet("color: #888; font-style: italic; padding: 6px;")
>         if not self.curated_cards:
>             curated_layout.addWidget(self.curated_placeholder)
>         self._curated_layout = curated_layout  # Save for dynamic placeholder
>         curate_layout.insertWidget(0, curated_group)
>         # --- Step 3: Set Rules Tab ---
>         rules_tab = QWidget()
>         rules_layout = QVBoxLayout(rules_tab)
>         # --- Save/Load Rule Set buttons (move to top of rules tab) ---
>         self._add_rule_set_buttons(rules_layout)
>         # --- Break List Controls/Preview Section ---
>         break_group = QGroupBox("3. Break List Controls  Preview")
>         break_group.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #bbb; margin-top: 8px; padding: 12px 8px 18px 8px; background: #f7f7fa; } ")
>         break_layout = QVBoxLayout(break_group)
>         break_layout.setSpacing(10)
>         # Collapsible rule builder area (expanded by default)
>         self.rules_collapsed = False
>         self.toggle_rules_btn = QPushButton("â–¼ Rules")
>         self.toggle_rules_btn.setCheckable(True)
>         self.toggle_rules_btn.setChecked(True)
>         self.toggle_rules_btn.setStyleSheet("font-weight: bold; font-size: 14px; background: #f5f5f5; border: none; text-align: left; padding: 4px 8px;")
>         self.toggle_rules_btn.setToolTip("Show/hide the rule builder area.")
>         self.toggle_rules_btn.toggled.connect(self._toggle_rules_area)
>         break_layout.addWidget(self.toggle_rules_btn)
>         # Rule widgets area (as a QWidget for animation)
>         self.rules_area_scroll = QScrollArea()
>         self.rules_area_scroll.setWidgetResizable(True)
>         self.rules_area_widget = QWidget()
>         self.rules_area_layout = QVBoxLayout(self.rules_area_widget)
>         self.rules_area_layout.setContentsMargins(0, 0, 0, 0)
>         self.rules_area_layout.setSpacing(8)
>         self.rules_area_scroll.setWidget(self.rules_area_widget)
>         self.rules_area_scroll.setMinimumHeight(120)
>         self.rules_area_scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
>         break_layout.addWidget(self.rules_area_scroll)
>         # Add Rule button (modern, with icon)
>         self.add_rule_btn = QPushButton(" Add Rule")
>         self.add_rule_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_FileDialogNewFolder))
>         self.add_rule_btn.setStyleSheet("padding: 6px 18px; border-radius: 8px; background: #43a047; color: white; font-weight: bold; font-size: 13px;")
>         self.add_rule_btn.setToolTip("Add a new rule for break composition.")
>         self.add_rule_btn.clicked.connect(self.add_rule)
>         break_layout.addWidget(self.add_rule_btn)
>         rules_layout.insertWidget(1, break_group)
>         # --- Step 4: Generate Break Tab ---
>         generate_tab = QWidget()
>         generate_layout = QVBoxLayout(generate_tab)
>         generate_layout.setContentsMargins(18, 18, 18, 18)
>         generate_layout.setSpacing(16)
>         # Add total cards input at the top of the Generate tab
>         total_row = QHBoxLayout()
>         total_label = QLabel("Total cards needed for break:")
>         total_label.setStyleSheet("font-weight: bold; font-size: 15px; margin-right: 12px;")
>         total_row.addWidget(total_label)
>         total_row.addWidget(self.total_cards_input)
>         generate_layout.addLayout(total_row)
>         # --- Modern, clean button row ---
92,121c409,432
<         self.remove_btn = QPushButton("Remove Selected")
<         self.remove_btn.clicked.connect(self.remove_selected_from_break)
<         self.duplicate_btn = QPushButton("Duplicate Selected")
<         self.duplicate_btn.clicked.connect(self.duplicate_selected_in_break)
<         self.add_custom_btn = QPushButton("Add by Scryfall ID")
<         self.add_custom_btn.clicked.connect(self.add_by_scryfall_id)
<         btn_row.addWidget(self.remove_btn)
<         btn_row.addWidget(self.duplicate_btn)
<         btn_row.addWidget(self.add_custom_btn)
<         break_layout.addLayout(btn_row)
<         self.tabs.addTab(self.break_tab, "Break List")
<         # Tab 3: Preview/Export
<         self.preview_tab = QWidget()
<         preview_layout = QVBoxLayout(self.preview_tab)
<         preview_layout.addWidget(QLabel("Preview Export (Title/Description):"))
<         self.preview_box = QTextEdit()
<         self.preview_box.setReadOnly(True)
<         self.preview_box.setMinimumHeight(200)
<         preview_layout.addWidget(self.preview_box)
<         self.remove_from_inv_chk = QCheckBox("Remove exported cards from inventory")
<         preview_layout.addWidget(self.remove_from_inv_chk)
<         # --- Action Buttons Row ---
<         btn_row = QHBoxLayout()
<         self.export_btn = QPushButton("Export/Copy for Whatnot")
<         self.export_btn.clicked.connect(self.export_break_list)
<         self.undo_btn = QPushButton("Undo Remove")
<         self.undo_btn.setEnabled(False)
<         self.undo_btn.clicked.connect(self.undo_last_removal)
<         self.template_btn = QPushButton("Manage Export Templates")
<         self.template_btn.clicked.connect(self.manage_templates)
---
>         btn_row.setSpacing(18)
>         self.generate_btn = QPushButton(" Generate Break List")
>         self.generate_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
>         self.generate_btn.setStyleSheet("padding: 8px 24px; border-radius: 10px; background: #1976d2; color: white; font-weight: bold; font-size: 15px;")
>         self.generate_btn.setToolTip("Generate the break list using curated cards and rules, from the currently filtered inventory.")
>         self.generate_btn.clicked.connect(self.prompt_and_generate_break_list)
>         self.export_btn = QPushButton(" Export Break List")
>         self.export_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DialogSaveButton))
>         self.export_btn.setStyleSheet("padding: 8px 24px; border-radius: 10px; background: #388e3c; color: white; font-weight: bold; font-size: 15px;")
>         self.export_btn.setToolTip("Export the break list in Title/Description format (CSV)")
>         self.export_btn.clicked.connect(self.export_break_list_item_listing)
>         self.remove_from_inventory_btn = QPushButton(" Remove from Inventory")
>         self.remove_from_inventory_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon))
>         self.remove_from_inventory_btn.setStyleSheet("padding: 8px 24px; border-radius: 10px; background: #e53935; color: white; font-weight: bold; font-size: 15px;")
>         self.remove_from_inventory_btn.setToolTip("Remove all cards in the current break list from inventory (with confirmation)")
>         self.remove_from_inventory_btn.clicked.connect(self.remove_break_cards_from_inventory)
>         self.undo_remove_btn = QPushButton(" Undo Remove")
>         self.undo_remove_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_ArrowBack))
>         self.undo_remove_btn.setStyleSheet("padding: 8px 24px; border-radius: 10px; background: #1976d2; color: white; font-weight: bold; font-size: 15px;")
>         self.undo_remove_btn.setToolTip("Undo the last removal of break cards from inventory")
>         self.undo_remove_btn.clicked.connect(self.undo_remove_from_inventory)
>         self.undo_remove_btn.setEnabled(False)
>         self.last_removed_cards = []
>         btn_row.addWidget(self.generate_btn)
123,150c434,529
<         btn_row.addWidget(self.undo_btn)
<         btn_row.addWidget(self.template_btn)
<         btn_row.addStretch()
<         preview_layout.addLayout(btn_row)
<         self.tabs.addTab(self.preview_tab, "Preview/Export")
<         # Tab 4: Help/Settings
<         self.help_tab = QWidget()
<         help_layout = QVBoxLayout(self.help_tab)
<         help_layout.addWidget(QLabel("How to use the Break/Autobox Builder:"))
<         help_layout.addWidget(QLabel("1. Filter and select cards from your inventory.\n2. Add them to the break list.\n3. Optionally add by Scryfall ID.\n4. Reorder, edit, or duplicate items.\n5. Preview and export the list for Whatnot.\n6. Optionally remove exported cards from inventory.\n7. You can re-import unused cards later."))
<         self.tabs.addTab(self.help_tab, "Help/Settings")
<         # Populate inventory list
<         self.update_inventory_list()
<         self.update_break_list()
<         self.update_preview()
<     def update_inventory_list(self):
<         self.inv_list.clear()
<         filters = {}
<         for field, widget in self.filter_inputs.items():
<             if isinstance(widget, tuple):
<                 min_val = widget[0].text().strip()
<                 max_val = widget[1].text().strip()
<                 if min_val and max_val:
<                     filters[field] = f"{min_val}-{max_val}"
<                 elif min_val:
<                     filters[field] = f">={min_val}"
<                 elif max_val:
<                     filters[field] = f"<={max_val}"
---
>         btn_row.addWidget(self.remove_from_inventory_btn)
>         btn_row.addWidget(self.undo_remove_btn)
>         generate_layout.addLayout(btn_row)
>         # --- Total and average cost labels ---
>         self.total_cost_label = QLabel()
>         self.avg_cost_label = QLabel()
>         cost_row = QHBoxLayout()
>         cost_row.setSpacing(24)
>         cost_row.addWidget(self.total_cost_label)
>         cost_row.addWidget(self.avg_cost_label)
>         cost_row.addStretch(1)
>         generate_layout.addLayout(cost_row)
>         # --- Modern, scrollable break preview box ---
>         preview_group = QFrame()
>         preview_group.setFrameShape(QFrame.StyledPanel)
>         preview_group.setStyleSheet("background: #f8fafd; border: 1.5px solid #b3c6e0; border-radius: 10px; padding: 10px 10px 10px 10px;")
>         preview_layout = QVBoxLayout(preview_group)
>         preview_layout.setContentsMargins(0, 0, 0, 0)
>         preview_layout.setSpacing(6)
>         self.break_preview_label = QLabel("Break List Preview:")
>         self.break_preview_box = QTextEdit()
>         self.break_preview_box.setReadOnly(True)
>         self.break_preview_box.setStyleSheet("background: #fafafa; border: 1px solid #bbb; border-radius: 6px; font-family: monospace; font-size: 13px; padding: 6px;")
>         self.break_preview_box.setMinimumHeight(180)
>         preview_layout.addWidget(self.break_preview_label)
>         preview_layout.addWidget(self.break_preview_box)
>         generate_layout.addWidget(preview_group)
>         self.filter_hint_label = QLabel("Rules will only select from cards currently visible in the inventory table.")
>         self.filter_hint_label.setStyleSheet("color: #888; font-style: italic; margin-top: 8px;")
>         generate_layout.addWidget(self.filter_hint_label)
>         # --- Add tabs ---
>         self.tabs.addTab(filter_tab, "1. Filter Inventory")
>         self.tabs.addTab(curate_tab, "2. Curate Must-Haves")
>         self.tabs.addTab(rules_tab, "3. Set Rules")
>         self.tabs.addTab(generate_tab, "4. Generate Break")
>         # --- Floating help button (add to main_layout) ---
>         self.help_btn = QPushButton()
>         self.help_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MessageBoxQuestion))
>         self.help_btn.setToolTip("Show quick tips and workflow guidance.")
>         self.help_btn.setFixedSize(44, 44)
>         self.help_btn.setStyleSheet("border-radius: 22px; background: #1976d2; color: white; position: absolute; bottom: 24px; right: 24px; font-size: 22px; box-shadow: 0 2px 8px rgba(0,0,0,0.18);")
>         self.help_btn.clicked.connect(self.show_help_dialog)
>         self.help_btn.setAccessibleName("Help")
>         main_layout.addWidget(self.help_btn, 0, Qt.AlignBottom | Qt.AlignRight)
>         # Add initial rule widget if none exist
>         if not self.rule_widgets:
>             self.add_rule()
>     def _get_all_inventory_fields(self):
>         # Get all unique fields from inventory
>         fields = set()
>         for card in self.inventory.get_all_cards():
>             fields.update(card.keys())
>         return sorted(fields)
>     def add_selected_to_curated(self):
>         """
>         Add selected cards from the inventory table to the curated list, avoiding duplicates, and update the curated table and break preview.
>         """
>         selected_rows = self.card_table.selectionModel().selectedRows()
>         for idx in selected_rows:
>             card = self.card_table.cards[idx.row() - 1]
>             if card not in self.curated_cards:
>                 self.curated_cards.append(card)
>         self.update_curated_table()
>         self.generate_break_list()  # Always update preview
>     def remove_selected_from_curated(self):
>         """
>         Remove selected cards from the curated list and update the curated table and break preview.
>         """
>         selected_rows = self.curated_table.selectionModel().selectedRows()
>         for idx in sorted(selected_rows, reverse=True):
>             if 0 <= idx.row() - 1 < len(self.curated_cards):
>                 self.curated_cards.pop(idx.row() - 1)
>         self.update_curated_table()
>         self.generate_break_list()  # Always update preview
>     def update_curated_table(self):
>         """
>         Update the curated table to reflect the current curated_cards list.
>         Animate added/removed rows for visual feedback.
>         Show/hide the empty placeholder dynamically.
>         """
>         # Store previous set for animation
>         prev_set = set(id(card) for card in getattr(self, '_last_curated_cards', []))
>         new_set = set(id(card) for card in self.curated_cards)
>         self.curated_table.update_cards(self.curated_cards)
>         self.curated_table.repaint()
>         # Animate added rows
>         for row, card in enumerate(self.curated_cards):
>             if id(card) not in prev_set:
>                 self._animate_table_row(self.curated_table, row, added=True)
>         # Animate removed rows (optional, not shown since row is gone)
>         self._last_curated_cards = list(self.curated_cards)
>         # --- Dynamic placeholder logic ---
>         if hasattr(self, 'curated_placeholder') and hasattr(self, '_curated_layout'):
>             if not self.curated_cards:
>                 if self._curated_layout.indexOf(self.curated_placeholder) == -1:
>                     self._curated_layout.addWidget(self.curated_placeholder)
152,172c531,539
<                 val = widget.text().strip()
<                 if val:
<                     filters[field] = val
<         # Use inventory's filter_cards method for robust filtering
<         filtered_cards = self.inventory.filter_cards(filters)
<         self.filtered_cards = filtered_cards
<         for card in filtered_cards:
<             item = QListWidgetItem(f"{card.get('Name', '')} [{card.get('Set name', '')}]")
<             item.setData(Qt.UserRole, card)
<             self.inv_list.addItem(item)
<     def add_selected_to_break(self):
<         for item in self.inv_list.selectedItems():
<             card = item.data(Qt.UserRole)
<             self.break_items.append(card.copy())
<         self.update_break_list()
<         self.update_preview()
<     def randomly_select_from_filtered(self):
<         try:
<             n = int(self.rand_count_input.text())
<         except Exception:
<             QMessageBox.warning(self, "Invalid Input", "Please enter a valid number to select.")
---
>                 self.curated_placeholder.setParent(None)
>     def _animate_table_row(self, table, row, added=True, test_mode=False):
>         """
>         Animate a table row background color for add/remove feedback.
>         If test_mode is True, always create the overlay for test detection.
>         """
>         # Get the rect for the row (fix: do not offset by +1)
>         rect = table.visualRect(table.model.index(row, 0))
>         if (not rect.isValid() or rect.height() == 0) and not test_mode:
174,194c541,788
<         if n <= 0 or n > len(self.filtered_cards):
<             QMessageBox.warning(self, "Invalid Input", f"Number must be between 1 and {len(self.filtered_cards)}.")
<             return
<         selected = random.sample(self.filtered_cards, n)
<         self.break_items.extend([card.copy() for card in selected])
<         # Show the selected cards to the user in a scrollable dialog
<         names = [f"{c.get('Name', '')} [{c.get('Set name', '')}]" for c in selected]
<         dlg = ScrollableListDialog("Randomly Selected", names, self)
<         dlg.exec()
<         self.update_break_list()
<         self.update_preview()
<     def update_break_list(self):
<         self.break_list.clear()
<         for card in self.break_items:
<             item = QListWidgetItem(f"{card.get('Name', '')} [{card.get('Set name', '')}]" )
<             item.setData(Qt.UserRole, card)
<             self.break_list.addItem(item)
<         # --- Update Summary ---
<         purchase_prices = []
<         whatnot_prices = []
<         for card in self.break_items:
---
>         # If in test mode and rect is invalid, create a default rect
>         if test_mode and (not rect.isValid() or rect.height() == 0):
>             rect = QRect(0, 0, 120, 32)
>         # Create a QWidget overlay for animation
>         overlay = QWidget(table.viewport())
>         overlay.setGeometry(rect)
>         color_start = "#c8e6c9" if added else "#ffcdd2"
>         color_end = "#ffffff"
>         overlay.setStyleSheet(f"background: {color_start}; border-radius: 4px;")
>         overlay.show()
>         anim = QPropertyAnimation(overlay, b"windowOpacity")
>         anim.setDuration(600)
>         anim.setStartValue(1.0)
>         anim.setEndValue(0.0)
>         anim.setEasingCurve(QEasingCurve.InOutQuad)
>         anim.finished.connect(overlay.deleteLater)
>         overlay._row_anim = anim  # Prevent GC until finished
>         anim.start()
>     def _rule_to_str(self, rule):
>         """Return a human-readable string for a rule's criteria."""
>         parts = []
>         for field, val in rule.get('criteria', []):
>             if isinstance(val, tuple):
>                 min_val, max_val = val
>                 parts.append(f"{field} >= {min_val}, <= {max_val}")
>             elif isinstance(val, str) and val:
>                 parts.append(f"{field}: {val}")
>         count_type = rule.get('count_type', '')
>         count = rule.get('count', '')
>         if count_type == '% of available':
>             return f"{count}% of filtered ({', '.join(parts)})"
>         else:
>             return f"{count} cards ({', '.join(parts)})"
>     def prompt_and_generate_break_list(self):
>         # Only prompt when button is pressed
>         max_rule_price = self._get_max_rule_price()
>         if max_rule_price is None:
>             max_rule_price = 99999
>         user_max, ok = QInputDialog.getDouble(self, "Max Filler Card Price", "Set the maximum Whatnot price for filler cards:", max_rule_price, 0, max_rule_price, 2)
>         if not ok:
>             user_max = max_rule_price
>         self.filler_max_price = min(user_max, max_rule_price)
>         self.generate_break_list()
>     def _get_max_rule_price(self):
>         # Helper to get max price among all rule-selected cards
>         max_rule_price = None
>         all_cards = self.filtered_inventory
>         used_ids = set(id(c) for c in self.curated_cards)
>         for i in range(self.rules_area_layout.count()):
>             item = self.rules_area_layout.itemAt(i)
>             if not item or not item.widget():
>                 continue
>             group = item.widget()
>             rule_widget = getattr(group, '_rule_widget', None)
>             enable_checkbox = getattr(group, '_enable_checkbox', None)
>             if not rule_widget or not enable_checkbox or not enable_checkbox.isChecked():
>                 continue
>             rule = rule_widget.get_rule()
>             filtered = []
>             for card in all_cards:
>                 if id(card) in used_ids:
>                     continue
>                 match = True
>                 for field, val in rule.get('criteria', []):
>                     if isinstance(val, tuple):
>                         min_val, max_val = val
>                         try:
>                             card_val = card.get(field, 0)
>                             if isinstance(card_val, str):
>                                 card_val = card_val.replace("$", "").strip()
>                             card_val = float(card_val)
>                         except Exception:
>                             card_val = 0
>                         if not (min_val <= card_val <= max_val):
>                             match = False
>                             break
>                     elif isinstance(val, str) and val:
>                         if str(card.get(field, "")).lower() != val.lower():
>                             match = False
>                             break
>                 if match:
>                     filtered.append(card)
>             for card in filtered:
>                 price = card.get('Whatnot price')
>                 try:
>                     if isinstance(price, str):
>                         price = price.replace("$", "").strip()
>                     price = float(price)
>                 except Exception:
>                     continue
>                 if max_rule_price is None or price > max_rule_price:
>                     max_rule_price = price
>         return max_rule_price
>     def generate_break_list(self):
>         """
>         Combine curated and rule-based selections, deduplicate, and match total.
>         Store both a flat list and a detailed breakdown for preview/export sync.
>         Show preview with sections for curated, each rule-based group (with rule info), and filler.
>         """
>         total_needed = self.total_cards_input.value()
>         curated = list(self.curated_cards)
>         all_cards = self.filtered_inventory
>         used_ids = set(id(c) for c in curated)
>         rule_cards_by_rule = []
>         allocations = []  # (rule, filtered, n)
>         enabled_rules = []
>         max_rule_price = None
>         for i in range(self.rules_area_layout.count()):
>             item = self.rules_area_layout.itemAt(i)
>             if not item or not item.widget():
>                 continue
>             group = item.widget()
>             rule_widget = getattr(group, '_rule_widget', None)
>             enable_checkbox = getattr(group, '_enable_checkbox', None)
>             if not rule_widget or not enable_checkbox or not enable_checkbox.isChecked():
>                 continue
>             rule = rule_widget.get_rule()
>             filtered = []
>             for card in all_cards:
>                 if id(card) in used_ids:
>                     continue
>                 match = True
>                 for field, val in rule.get('criteria', []):
>                     if isinstance(val, tuple):
>                         min_val, max_val = val
>                         try:
>                             card_val = card.get(field, 0)
>                             if isinstance(card_val, str):
>                                 card_val = card_val.replace("$", "").strip()
>                             card_val = float(card_val)
>                         except Exception:
>                             card_val = 0
>                         if not (min_val <= card_val <= max_val):
>                             match = False
>                             break
>                     elif isinstance(val, str) and val:
>                         if str(card.get(field, "")).lower() != val.lower():
>                             match = False
>                             break
>                 if match:
>                     filtered.append(card)
>             n = 0
>             if rule.get("count_type") == "Count":
>                 n = int(rule.get("count", 1))
>             else:
>                 percent = float(rule.get("count", 1))
>                 n = int(total_needed * percent / 100)
>             n = min(n, len(filtered))
>             allocations.append((rule, filtered, n))
>             enabled_rules.append((rule, filtered))
>             # Track max price among all rule-selected cards
>             for card in filtered:
>                 price = card.get('Whatnot price')
>                 try:
>                     if isinstance(price, str):
>                         price = price.replace("$", "").strip()
>                     price = float(price)
>                 except Exception:
>                     continue
>                 if max_rule_price is None or price > max_rule_price:
>                     max_rule_price = price
>         # Use stored filler_max_price if set, else default to max_rule_price
>         if self.filler_max_price is not None:
>             filler_max_price = self.filler_max_price
>         else:
>             if max_rule_price is None:
>                 max_rule_price = 99999
>             filler_max_price = max_rule_price
>         # Adjust allocations if sum exceeds total_needed
>         total_alloc = sum(n for _, _, n in allocations)
>         if total_alloc > total_needed:
>             over = total_alloc - total_needed
>             for i in reversed(range(len(allocations))):
>                 rule, filtered, n = allocations[i]
>                 reduce_by = min(over, n-1 if n>1 else over)
>                 allocations[i] = (rule, filtered, n - reduce_by)
>                 over -= reduce_by
>                 if over <= 0:
>                     break
>         # Second pass: select cards for each rule
>         rule_cards_by_rule = []
>         for rule, filtered, n in allocations:
>             selected = random.sample(filtered, n) if n > 0 else []
>             for card in selected:
>                 used_ids.add(id(card))
>             rule_cards_by_rule.append((rule, selected))
>         final_list = list(curated)
>         break_details = []
>         if curated:
>             break_details.append(("Curated", None, curated))
>         for i, (rule, cards) in enumerate(rule_cards_by_rule):
>             break_details.append(("Rule", rule, cards))
>             final_list.extend(cards)
>         filler = []
>         if len(final_list) < total_needed:
>             for card in all_cards:
>                 if id(card) not in used_ids:
>                     # Only allow filler if Whatnot price <= filler_max_price
>                     price = card.get('Whatnot price')
>                     try:
>                         if isinstance(price, str):
>                             price = price.replace("$", "").strip()
>                         price = float(price)
>                     except Exception:
>                         continue
>                     if price > filler_max_price:
>                         continue
>                     filler.append(card)
>                     final_list.append(card)
>                     used_ids.add(id(card))
>                     if len(final_list) >= total_needed:
>                         break
>         if filler:
>             break_details.append(("Filler", None, filler))
>         # Store for export
>         self.current_break_list = final_list[:total_needed]
>         self.current_break_list_details = break_details
>         # Show preview with sections and rule info
>         lines = []
>         for section in break_details:
>             section_type, rule, cards = section
>             if not cards:
>                 continue
>             if section_type == "Curated":
>                 lines.append("Curated Cards:")
>             elif section_type == "Rule":
>                 lines.append(f"Rule ({self._rule_to_str(rule)}):")
>             elif section_type == "Filler":
>                 lines.append("Filler Cards:")
>             for c in cards:
>                 # For rules and filler, show Whatnot price next to the card name
>                 whatnot_price = c.get('Whatnot price', None)
>                 price_str = f" (Whatnot price: {whatnot_price})" if whatnot_price is not None else ""
>                 crit_str = ""
>                 if section_type == "Rule" and rule:
>                     crit_fields = [field for field, _ in rule.get('criteria', [])]
>                     crit_values = []
>                     for field in crit_fields:
>                         val = c.get(field, None)
>                         if val is not None and val != '':
>                             crit_values.append(f"{field}: {val}")
>                     crit_str = f" ({', '.join(crit_values)})" if crit_values else ""
>                 lines.append(f"  {c.get('Name', '')} [{c.get('Set name', '')}]{crit_str}{price_str}")
>         self.break_preview_box.setText("\n".join(lines[:total_needed + 10]))
>         # --- Compute and display total and average cost ---
>         prices = []
>         for card in self.current_break_list:
>             price = card.get('Whatnot price')
196,197c790,798
<                 price = float(str(card.get('Purchase price', '')).replace('$','').replace(',',''))
<                 purchase_prices.append(price)
---
>                 if price is None or price == '' or (isinstance(price, str) and price.strip() == ''):
>                     price = 1.0
>                 else:
>                     if isinstance(price, str):
>                         price = price.replace("$", "").strip()
>                     price = float(price)
>                     if price == 0:
>                         price = 1.0
>                 prices.append(price)
199,239c800,832
<                 pass
<             try:
<                 wprice = float(str(card.get('Whatnot price', '')).replace('$','').replace(',',''))
<                 whatnot_prices.append(wprice)
<             except Exception:
<                 pass
<         total_purchase = sum(purchase_prices)
<         avg_purchase = (sum(purchase_prices)/len(purchase_prices)) if purchase_prices else 0
<         total_whatnot = sum(whatnot_prices)
<         avg_whatnot = (sum(whatnot_prices)/len(whatnot_prices)) if whatnot_prices else 0
<         self.summary_label.setText(
<             f"<b>Totals:</b> Purchase price: ${total_purchase:.2f} (avg: ${avg_purchase:.2f}) | "
<             f"Whatnot price: ${total_whatnot:.2f} (avg: ${avg_whatnot:.2f})"
<         )
<         # --- End Update Summary ---
<     def remove_selected_from_break(self):
<         for item in self.break_list.selectedItems():
<             idx = self.break_list.row(item)
<             if idx >= 0:
<                 self.break_items.pop(idx)
<         self.update_break_list()
<         self.update_preview()
<     def duplicate_selected_in_break(self):
<         for item in self.break_list.selectedItems():
<             card = item.data(Qt.UserRole)
<             self.break_items.append(card.copy())
<         self.update_break_list()
<         self.update_preview()
<     def edit_break_item(self, item):
<         card = item.data(Qt.UserRole)
<         from ui.dialogs.edit_card import EditCardDialog
<         dlg = EditCardDialog(card, all_fields=list(card.keys()), parent=self)
<         if dlg.exec():
<             updated = dlg.get_card()
<             idx = self.break_list.row(item)
<             self.break_items[idx] = updated
<             self.update_break_list()
<             self.update_preview()
<     def add_by_scryfall_id(self):
<         scry_id, ok = QInputDialog.getText(self, "Add by Scryfall ID", "Enter Scryfall ID:")
<         if not ok or not scry_id.strip():
---
>                 prices.append(1.0)
>         total_cost = sum(prices)
>         avg_cost = (total_cost / len(prices)) if prices else 0.0
>         self.total_cost_label.setText(f"<b>Total Whatnot Price:</b> ${total_cost:,.2f}")
>         self.avg_cost_label.setText(f"<b>Average Whatnot Price:</b> ${avg_cost:,.2f}")
>     def update_table_filter(self):
>         """
>         Update the inventory table based on the FilterOverlay fields.
>         This method is now unified with the main GUI's filtering logic for modularity.
>         """
>         filters = {col: self.filter_overlay.filters[col].text() for col in self.columns}
>         filtered = self.inventory.filter_cards(filters)
>         self.filtered_inventory = filtered  # Store the filtered pool
>         self.card_table.update_cards(filtered)
>         self.card_table.repaint()
>         # Inventory placeholder logic
>         if hasattr(self, 'inventory_placeholder'):
>             if not filtered:
>                 parent = self.card_table.parentWidget()
>                 if parent and parent.layout() and self.inventory_placeholder.parent() != parent:
>                     parent.layout().addWidget(self.inventory_placeholder)
>                 self.inventory_placeholder.show()
>             else:
>                 self.inventory_placeholder.hide()
>     def export_break_list_item_listing(self):
>         """
>         Export the generated break list (from preview) in Title/Description format (CSV), using the same logic and templates as the main export_item_listings.
>         Only export the cards in self.current_break_list, in order.
>         """
>         from PySide6.QtWidgets import QFileDialog, QMessageBox
>         final_list = self.current_break_list
>         if not final_list:
>             QMessageBox.warning(self, "Export Error", "No break list generated. Please generate the break list first.")
241,296d833
<         data = fetch_scryfall_data(scry_id.strip())
<         if not data:
<             QMessageBox.warning(self, "Not Found", "No card found for that Scryfall ID.")
<             return
<         self.break_items.append(data)
<         self.update_break_list()
<         self.update_preview()
<     def update_preview(self):
<         # Show preview using current template if set, else fallback to Name/Set name
<         if self.export_template:
<             title_fields = self.export_template.get('title_fields', [])
<             desc_fields = self.export_template.get('desc_fields', [])
<         else:
<             title_fields = ["Name"]
<             desc_fields = ["Set name"]
<         # Build preview rows: each row is [title, description]
<         rows = []
<         for card in self.break_items:
<             title_parts = []
<             for f in title_fields:
<                 val = card.get(f, "")
<                 if (not val or str(val).strip() == "") and card.get("Scryfall ID", ""):
<                     scry_data = fetch_scryfall_data(card["Scryfall ID"])
<                     if scry_data and f in scry_data:
<                         val = scry_data[f]
<                 if not val or str(val).strip() == "":
<                     val = "(none)"
<                 title_parts.append(str(val).title())
<             title = " - ".join(title_parts).replace('\n', ' ').replace('\t', ' ').strip()
<             desc_lines = []
<             for f in desc_fields:
<                 val = card.get(f, "")
<                 # If field is empty, try to fetch from Scryfall
<                 if (not val or str(val).strip() == "") and card.get("Scryfall ID", ""):
<                     scry_data = fetch_scryfall_data(card["Scryfall ID"])
<                     if scry_data and f in scry_data:
<                         val = scry_data[f]
<                 # For oracle_text, flatten newlines
<                 if f == "oracle_text" and val:
<                     val = str(val).replace("\n", " ").replace("\r", " ")
<                 if not val or str(val).strip() == "":
<                     val = "(none)"
<                 desc_lines.append(f"â€¢ {f.replace('_', ' ').title()}: {val}")
<             desc = "\n".join(desc_lines)
<             rows.append([title, desc])
<         # Format as a table-like preview
<         preview_lines = [f"{'Title':<40} | Description"]
<         preview_lines.append("-"*80)
<         for title, desc in rows:
<             desc_lines = desc.split("\n")
<             preview_lines.append(f"{title[:40]:<40} | {desc_lines[0] if desc_lines else ''}")
<             for line in desc_lines[1:]:
<                 preview_lines.append(f"{'':<40} | {line}")
<         self.preview_box.setPlainText("\n".join(preview_lines))
<     def export_break_list(self):
<         # Use ExportItemListingFieldsDialog for title/description selection
298c835
<         for card in self.break_items:
---
>         for card in final_list:
301,348c838,849
<         # If a template is set, use it; else prompt
<         if self.export_template:
<             title_fields = self.export_template.get('title_fields', [])
<             desc_fields = self.export_template.get('desc_fields', [])
<         else:
<             dlg = ExportItemListingFieldsDialog(all_fields, self)
<             if not dlg.exec():
<                 return
<             title_fields, desc_fields = dlg.get_fields()
<             # Optionally save as template
<             save = QMessageBox.question(self, "Save Template?", "Save these fields as a new export template?", QMessageBox.Yes | QMessageBox.No)
<             if save == QMessageBox.Yes:
<                 name, ok = QInputDialog.getText(self, "Template Name", "Enter a name for this template:")
<                 if ok and name.strip():
<                     self.templates[name.strip()] = {'title_fields': title_fields, 'desc_fields': desc_fields}
<                     self.save_templates()
<                     self.export_template = self.templates[name.strip()]
<             # Always update preview to reflect the latest selection
<             self.export_template = {'title_fields': title_fields, 'desc_fields': desc_fields}
<             self.update_preview()
<         # Build export rows: each row is [title, description] (no tabs/newlines inside cells)
<         rows = []
<         for card in self.break_items:
<             title_parts = []
<             for f in title_fields:
<                 val = card.get(f, "")
<                 if (not val or str(val).strip() == "") and card.get("Scryfall ID", ""):
<                     scry_data = fetch_scryfall_data(card["Scryfall ID"])
<                     if scry_data and f in scry_data:
<                         val = scry_data[f]
<                 if not val or str(val).strip() == "":
<                     val = "(none)"
<                 title_parts.append(str(val).title())
<             title = " - ".join(title_parts).replace('\n', ' ').replace('\t', ' ').strip()
<             desc_lines = []
<             for f in desc_fields:
<                 val = card.get(f, "")
<                 # If field is empty, try to fetch from Scryfall
<                 if (not val or str(val).strip() == "") and card.get("Scryfall ID", ""):
<                     scry_data = fetch_scryfall_data(card["Scryfall ID"])
<                     if scry_data and f in scry_data:
<                         val = scry_data[f]
<                 # For oracle_text, flatten newlines
<                 if f == "oracle_text" and val:
<                     val = str(val).replace("\n", " ").replace("\r", " ")
<                 if not val or str(val).strip() == "":
<                     val = "(none)"
<                 desc_lines.append(f"â€¢ {f.replace('_', ' ').title()}: {val}")
---
>         dlg = ExportItemListingFieldsDialog(all_fields, self)
>         if not dlg.exec():
>             return
>         title_fields, desc_fields = dlg.get_fields()
>         if not title_fields:
>             title_fields = ["Name", "Foil"] if "Name" in all_fields else all_fields[:1]
>         if not desc_fields:
>             desc_fields = [f for f in all_fields if f not in ("Name", "Foil", "Purchase price")]
>         listings = []
>         for card in final_list:
>             title = " ".join(str(card.get(f, "")) for f in title_fields if f in card)
>             desc_lines = [f"{f}: {card.get(f, '')}" for f in desc_fields if f in card]
350,387c851,853
<             rows.append([title, desc])
<         # Copy to clipboard as CSV
<         import pyperclip
<         import csv
<         import io
<         output = io.StringIO()
<         writer = csv.writer(output)
<         writer.writerow(["Title", "Description"])
<         for row in rows:
<             writer.writerow(row)
<         csv_text = output.getvalue()
<         pyperclip.copy(csv_text)
<         # Optionally save as CSV
<         fname, _ = QFileDialog.getSaveFileName(self, "Export Break List", "break_list.csv", "CSV Files (*.csv)")
<         if fname:
<             with open(fname, 'w', encoding='utf-8', newline='') as f:
<                 f.write(csv_text)
<         # After export, ask if user wants to remove from inventory (if not already checked)
<         if not self.remove_from_inv_chk.isChecked():
<             remove = QMessageBox.question(self, "Remove from Inventory?", "Do you want to remove the exported cards from inventory?", QMessageBox.Yes | QMessageBox.No)
<             if remove == QMessageBox.Yes:
<                 self._undo_inventory = copy.deepcopy(self.inventory.get_all_cards())
<                 self.inventory.remove_cards(self.break_items)
<                 self.removed_from_inventory = self.break_items.copy()
<                 self.undo_btn.setEnabled(True)
<                 QMessageBox.information(self, "Removed", f"{len(self.break_items)} cards removed from inventory. You can undo this action.")
<         else:
<             self._undo_inventory = copy.deepcopy(self.inventory.get_all_cards())
<             self.inventory.remove_cards(self.break_items)
<             self.removed_from_inventory = self.break_items.copy()
<             self.undo_btn.setEnabled(True)
<             QMessageBox.information(self, "Removed", f"{len(self.break_items)} cards removed from inventory. You can undo this action.")
<         QMessageBox.information(self, "Exported", "Break list exported and copied to clipboard.")
<     def manage_templates(self):
<         # Dialog to select, delete, or set a template
<         names = list(self.templates.keys())
<         if not names:
<             QMessageBox.information(self, "No Templates", "No export templates saved yet.")
---
>             listings.append((title.strip(), desc))
>         fname, _ = QFileDialog.getSaveFileName(self, "Export Break List (Item Listing)", "break_list.csv", "CSV Files (*.csv)")
>         if not fname:
389,412c855,992
<         name, ok = QInputDialog.getItem(self, "Select Template", "Choose a template to use: (or delete)", names, editable=False)
<         if ok and name:
<             action, ok2 = QInputDialog.getItem(self, "Action", f"Use or delete template '{name}'?", ["Use", "Delete"], editable=False)
<             if ok2 and action == "Use":
<                 self.export_template = self.templates[name]
<                 QMessageBox.information(self, "Template Set", f"Template '{name}' will be used for export.")
<                 self.update_preview()
<             elif ok2 and action == "Delete":
<                 del self.templates[name]
<                 self.save_templates()
<                 if self.export_template and self.export_template == self.templates.get(name):
<                     self.export_template = None
<                 QMessageBox.information(self, "Deleted", f"Template '{name}' deleted.")
<     def load_templates(self):
<         path = os.path.join(os.path.dirname(__file__), '../../break_export_templates.json')
<         if os.path.exists(path):
<             try:
<                 with open(path, 'r', encoding='utf-8') as f:
<                     return json.load(f)
<             except Exception:
<                 pass
<         return {}
<     def save_templates(self):
<         path = os.path.join(os.path.dirname(__file__), '../../break_export_templates.json')
---
>         with open(fname, "w", newline='', encoding="utf-8") as f:
>             writer = csv.writer(f)
>             writer.writerow(["Title", "Description"])
>             for title, desc in listings:
>                 writer.writerow([title, desc])
>         QMessageBox.information(self, "Exported", f"Break list exported as item listing CSV with {len(listings)} cards.")
>     def clear_all_filters(self):
>         for le in self.filter_overlay.filters.values():
>             le.clear()
>         self.update_table_filter()
>     def _toggle_rules_area(self, checked):
>         self.rules_area_widget.setVisible(checked)
>         self.toggle_rules_btn.setText("â–¼ Rules" if checked else "â–º Rules")
>     def _enforce_percent_rule_limits(self):
>         """Ensure the sum of all enabled percent-based rules does not exceed 100%. If exceeded, adjust the last changed rule."""
>         percent_rules = []
>         for i in range(self.rules_area_layout.count()):
>             item = self.rules_area_layout.itemAt(i)
>             if not item or not item.widget():
>                 continue
>             group = item.widget()
>             rule_widget = getattr(group, '_rule_widget', None)
>             enable_checkbox = getattr(group, '_enable_checkbox', None)
>             if not rule_widget or not enable_checkbox or not enable_checkbox.isChecked():
>                 continue
>             rule = rule_widget.get_rule()
>             if rule.get('count_type') == '% of available':
>                 percent_rules.append((rule_widget, rule))
>         total_percent = sum(float(r['count']) for _, r in percent_rules)
>         if total_percent > 100 and percent_rules:
>             # Reduce the last changed rule to fit
>             excess = total_percent - 100
>             last_widget, last_rule = percent_rules[-1]
>             new_val = float(last_rule['count']) - excess
>             if new_val < 0:
>                 new_val = 0
>             last_widget.percent_value.blockSignals(True)
>             last_widget.percent_value.setValue(new_val)
>             last_widget.percent_value.blockSignals(False)
>             from PySide6.QtWidgets import QMessageBox
>             QMessageBox.warning(self, "Percent Rule Limit", "Total percent for all enabled percent-based rules cannot exceed 100%. The last rule was adjusted to fit.")
>     def add_rule(self, rule_data=None):
>         rule_widget = BreakRuleWidget(self, inventory_fields=self.filter_fields, inventory=self.inventory)
>         if rule_data:
>             rule_widget.set_rule(rule_data)
>         group = QGroupBox(f"Rule {len(self.rule_widgets)+1}")
>         group.setCheckable(True)
>         group.setChecked(True)
>         group.setStyleSheet("QGroupBox { background: #f8fafd; border: 1.5px solid #b3c6e0; border-radius: 10px; margin: 6px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.04); font-weight: bold; } QGroupBox::indicator { width: 24px; height: 24px; }")
>         vbox = QVBoxLayout(group)
>         vbox.setContentsMargins(8, 4, 8, 4)
>         enable_row = QHBoxLayout()
>         enable_checkbox = QCheckBox("Enable Rule")
>         enable_checkbox.setChecked(True)
>         enable_checkbox.setToolTip("Enable or disable this rule without deleting it.")
>         enable_checkbox.stateChanged.connect(self.generate_break_list)
>         enable_checkbox.stateChanged.connect(self._enforce_percent_rule_limits)
>         vbox.addLayout(enable_row)
>         vbox.addWidget(rule_widget)
>         # Remove forced collapse logic: allow multiple rules to be expanded at once
>         def on_toggle(checked):
>             rule_widget.setVisible(checked)
>         group.toggled.connect(on_toggle)
>         remove_btn = QPushButton()
>         remove_btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DialogCloseButton))
>         remove_btn.setToolTip("Remove this rule")
>         remove_btn.setFixedSize(28, 28)
>         remove_btn.setStyleSheet("border: none; background: transparent;")
>         remove_btn.clicked.connect(lambda: self.remove_rule_card(group, rule_widget))
>         hbox = QHBoxLayout()
>         hbox.addStretch(1)
>         hbox.addWidget(remove_btn)
>         vbox.addLayout(hbox)
>         group._rule_widget = rule_widget
>         group._enable_checkbox = enable_checkbox
>         self.rules_area_layout.addWidget(group)
>         self.rule_widgets.append(rule_widget)
>         # Connect percent_value change to enforcement
>         rule_widget.percent_value.valueChanged.connect(self._enforce_percent_rule_limits)
>         self.generate_break_list()
>         group.setChecked(True)  # Expand the new rule by default
>     def remove_rule_card(self, group, rule_widget):
>         # Animate rule removal (optional, can use QPropertyAnimation for fade-out)
>         group.setVisible(False)
>         self.rules_area_layout.removeWidget(group)
>         group.deleteLater()
>         if rule_widget in self.rule_widgets:
>             self.rule_widgets.remove(rule_widget)
>         self.generate_break_list()
>     def show_help_dialog(self):
>         msg = (
>             "<b>Break/Autobox Builder Quick Tips</b><br><br>"
>             "<b>Step 1:</b> <b>Filter Inventory</b> â€” Use the sidebar to filter your cards. Only visible cards are used for rules.<br>"
>             "<b>Step 2:</b> <b>Curate Must-Haves</b> â€” Select cards you want guaranteed in the break and add them to the curated list.<br>"
>             "<b>Step 3:</b> <b>Set Rules</b> â€” Add rules to select cards by price, rarity, set, etc. Rules only use filtered cards.<br>"
>             "<b>Step 4:</b> <b>Generate Break</b> â€” Click 'Generate Break List' to preview and export your break.<br><br>"
>             "<b>Tips:</b><ul>"
>             "<li>Click filter chips to remove individual filters.</li>"
>             "<li>Use the 'Clear All Filters' button to reset filters.</li>"
>             "<li>Collapse the rule builder for a simpler view.</li>"
>             "<li>All actions are keyboard accessible and have tooltips.</li>"
>             "<li>Use the 'Simple/Advanced' toggle (coming soon) for more/less options.</li>"
>             "</ul>"
>         )
>         QMessageBox.information(self, "Break Builder Help", msg)
>     # --- Save/Load Rule Set ---
>     def save_rule_set(self):
>         """Save the current set of rules (enabled and disabled) to a template file."""
>         from PySide6.QtWidgets import QFileDialog, QMessageBox
>         rules = []
>         for i in range(self.rules_area_layout.count()):
>             item = self.rules_area_layout.itemAt(i)
>             if not item or not item.widget():
>                 continue
>             group = item.widget()
>             rule_widget = getattr(group, '_rule_widget', None)
>             enable_checkbox = getattr(group, '_enable_checkbox', None)
>             if not rule_widget or not enable_checkbox:
>                 continue
>             rule = rule_widget.get_rule()
>             rule['enabled'] = enable_checkbox.isChecked()
>             rules.append(rule)
>         if not rules:
>             QMessageBox.warning(self, "Save Rule Set", "No rules to save.")
>             return
>         fname, _ = QFileDialog.getSaveFileName(self, "Save Rule Set", "break_rule_set.json", "JSON Files (*.json)")
>         if not fname:
>             return
>         with open(fname, 'w', encoding='utf-8') as f:
>             json.dump(rules, f, indent=2)
>         QMessageBox.information(self, "Saved", f"Rule set saved to {fname}.")
> 
>     def load_rule_set(self):
>         """Load a rule set from a template file, replacing current rules."""
>         from PySide6.QtWidgets import QFileDialog, QMessageBox
>         fname, _ = QFileDialog.getOpenFileName(self, "Load Rule Set", "", "JSON Files (*.json)")
>         if not fname:
>             return
414,432c994,1018
<             with open(path, 'w', encoding='utf-8') as f:
<                 json.dump(self.templates, f, ensure_ascii=False, indent=2)
<         except Exception:
<             pass
<     def reimport_removed(self):
<         # Optionally re-import removed cards
<         for card in self.removed_from_inventory:
<             self.inventory.add_card(card)
<         self.removed_from_inventory = []
<         QMessageBox.information(self, "Re-imported", "Removed cards re-imported to inventory.")
<     def undo_last_removal(self):
<         if self._undo_inventory is not None:
<             self.inventory.load_cards(self._undo_inventory)
<             self._undo_inventory = None
<             self.undo_btn.setEnabled(False)
<             QMessageBox.information(self, "Undo", "Inventory restored to before last removal.")
<             self.update_inventory_list()
<             self.update_break_list()
<             self.update_preview()
---
>             with open(fname, 'r', encoding='utf-8') as f:
>                 rules = json.load(f)
>         except Exception as e:
>             QMessageBox.warning(self, "Load Rule Set", f"Failed to load rule set: {e}")
>             return
>         # Remove all current rules
>         for i in reversed(range(self.rules_area_layout.count())):
>             item = self.rules_area_layout.itemAt(i)
>             if item and item.widget():
>                 group = item.widget()
>                 rule_widget = getattr(group, '_rule_widget', None)
>                 self.rules_area_layout.removeWidget(group)
>                 group.deleteLater()
>                 if rule_widget in self.rule_widgets:
>                     self.rule_widgets.remove(rule_widget)
>         # Add loaded rules (restore enabled/disabled state)
>         for rule_data in rules:
>             rule = dict(rule_data)
>             enabled = rule.pop('enabled', True)
>             self.add_rule(rule)
>             group = self.rules_area_layout.itemAt(self.rules_area_layout.count()-1).widget()
>             enable_checkbox = getattr(group, '_enable_checkbox', None)
>             if enable_checkbox:
>                 enable_checkbox.setChecked(enabled)
>         self.generate_break_list()
434,450c1020,1095
< class ScrollableListDialog(QDialog):
<     def __init__(self, title, items, parent=None):
<         super().__init__(parent)
<         self.setWindowTitle(title)
<         self.setMinimumWidth(400)
<         self.setMaximumHeight(600)
<         layout = QVBoxLayout(self)
<         label = QLabel("Selected cards:")
<         layout.addWidget(label)
<         text = QTextEdit()
<         text.setReadOnly(True)
<         text.setPlainText("\n".join(items))
<         text.setMinimumHeight(300)
<         layout.addWidget(text)
<         buttons = QDialogButtonBox(QDialogButtonBox.Ok)
<         buttons.accepted.connect(self.accept)
<         layout.addWidget(buttons) 
\ No newline at end of file
---
>     # Add Save/Load Rule Set buttons to the rules area
>     def _add_rule_set_buttons(self, parent_layout):
>         btn_row = QHBoxLayout()
>         save_btn = QPushButton("ðŸ’¾ Save Rule Set")
>         save_btn.setStyleSheet("padding: 6px 18px; border-radius: 8px; background: #1976d2; color: white; font-weight: bold; font-size: 13px;")
>         save_btn.setToolTip("Save the current set of rules as a template.")
>         save_btn.clicked.connect(self.save_rule_set)
>         load_btn = QPushButton("ðŸ“‚ Load Rule Set")
>         load_btn.setStyleSheet("padding: 6px 18px; border-radius: 8px; background: #388e3c; color: white; font-weight: bold; font-size: 13px;")
>         load_btn.setToolTip("Load a saved rule set template, replacing current rules.")
>         load_btn.clicked.connect(self.load_rule_set)
>         btn_row.addWidget(save_btn)
>         btn_row.addWidget(load_btn)
>         btn_row.addStretch(1)
>         parent_layout.addLayout(btn_row)
>     def remove_break_cards_from_inventory(self):
>         """Remove all cards in the current break list from the inventory, with confirmation."""
>         from PySide6.QtWidgets import QMessageBox
>         if not self.current_break_list:
>             QMessageBox.warning(self, "Remove from Inventory", "No break list generated. Please generate the break list first.")
>             return
>         card_count = len(self.current_break_list)
>         reply = QMessageBox.question(
>             self,
>             "Confirm Remove from Inventory",
>             f"Are you sure you want to remove all {card_count} cards in the current break list from inventory? This cannot be undone.",
>             QMessageBox.Yes | QMessageBox.No,
>             QMessageBox.No
>         )
>         if reply != QMessageBox.Yes:
>             return
>         self.last_removed_cards = list(self.current_break_list)
>         # Use batch removal for robustness
>         if hasattr(self.inventory, 'remove_cards'):
>             self.inventory.remove_cards(self.current_break_list)
>             removed = len(self.last_removed_cards)
>         else:
>             removed = 0
>             for card in self.current_break_list:
>                 try:
>                     self.inventory.remove_card(card)
>                     removed += 1
>                 except Exception:
>                     pass
>         self.filtered_inventory = self.inventory.get_all_cards()
>         self.card_table.update_cards(self.filtered_inventory)
>         self.card_table.repaint()
>         self.generate_break_list()
>         self.undo_remove_btn.setEnabled(bool(self.last_removed_cards))
>         QMessageBox.information(self, "Removed from Inventory", f"Removed {removed} cards from inventory.")
> 
>     def undo_remove_from_inventory(self):
>         """Restore the last removed set of cards to inventory."""
>         from PySide6.QtWidgets import QMessageBox
>         if not self.last_removed_cards:
>             QMessageBox.information(self, "Undo Remove", "No removal to undo.")
>             return
>         # Use batch add if available, else loop
>         if hasattr(self.inventory, 'add_cards'):
>             self.inventory.add_cards(self.last_removed_cards)
>             restored = len(self.last_removed_cards)
>         else:
>             restored = 0
>             for card in self.last_removed_cards:
>                 try:
>                     self.inventory.add_card(card)
>                     restored += 1
>                 except Exception:
>                     pass
>         self.filtered_inventory = self.inventory.get_all_cards()
>         self.card_table.update_cards(self.filtered_inventory)
>         self.card_table.repaint()
>         self.generate_break_list()
>         self.last_removed_cards = []
>         self.undo_remove_btn.setEnabled(False)
>         QMessageBox.information(self, "Undo Remove", f"Restored {restored} cards to inventory.") 
\ No newline at end of file
Only in FoS_DeckPro/ui/dialogs: packing_slip_summary.py
diff -r FoS-DeckPro/ui/image_preview.py FoS_DeckPro/ui/image_preview.py
2c2
< from PySide6.QtCore import Qt
---
> from PySide6.QtCore import Qt, QUrl, QByteArray, QObject
4c4,5
< import requests
---
> from PySide6.QtNetwork import QNetworkAccessManager, QNetworkRequest, QNetworkReply
> import os
9a11,12
>     Now supports async network image loading via QNetworkAccessManager.
>     Handles reply deletion and race conditions robustly.
13c16
<         self.setText("Image Preview (to be implemented)")
---
>         self.setText("No image available")
16c19
<         self.setStyleSheet("border: 1px solid #ccc;")
---
>         self.setStyleSheet("border: 1.5px solid #b3c6e0; background: #f5f7fa; color: #888; font-style: italic;")
17a21,23
>         self._manager = QNetworkAccessManager(self)
>         self._network_reply = None
>         self._current_request_id = 0
23a30
>         Supports both URLs and local file paths.
26,28c33,45
<         print(f"[ImagePreview] Loading image URL: {url}")  # Debug output
<         if url:
<             self.setText("Loading image...")
---
>         print(f"DEBUG: show_card_image called with url: {url}")
>         self._current_request_id += 1
>         request_id = self._current_request_id
>         # Clean up previous reply if needed
>         if self._network_reply is not None:
>             try:
>                 self._network_reply.finished.disconnect()
>             except Exception:
>                 pass
>             self._network_reply.deleteLater()
>             self._network_reply = None
>         if not url:
>             self.setText("No image available")
31,33c48,91
<             try:
<                 response = requests.get(url, timeout=10)
<                 response.raise_for_status()
---
>             return
>         # If it's a local file
>         if os.path.exists(url):
>             print(f"DEBUG: Loading local file image: {url}")
>             pixmap = QPixmap(url)
>             if not pixmap.isNull():
>                 self.setPixmap(pixmap.scaled(self.width(), self.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
>                 self._original_pixmap = pixmap
>                 self.setText("")
>             else:
>                 self.setText("Image failed to load")
>                 self.setPixmap(QPixmap())
>                 self._original_pixmap = None
>             return
>         # Otherwise, try to load from network
>         print(f"DEBUG: Loading network image: {url}")
>         request = QNetworkRequest(QUrl(url))
>         self.setText("Loading image...")
>         self.setPixmap(QPixmap())
>         self._original_pixmap = None
>         reply = self._manager.get(request)
>         self._network_reply = reply
>         def on_finished():
>             print(f"DEBUG: on_finished slot called for url: {url}")
>             # Only handle if this is the latest request
>             if request_id != self._current_request_id:
>                 print(f"DEBUG: Ignoring late reply for url: {url}")
>                 reply.deleteLater()
>                 return
>             print(f"DEBUG: _on_image_loaded called for url: {url}")
>             if reply.error() != QNetworkReply.NetworkError.NoError:
>                 print(f"DEBUG: Network reply error: {reply.error()} for URL: {url}")
>                 self.setText("Image failed to load")
>                 self.setPixmap(QPixmap())
>                 self._original_pixmap = None
>             else:
>                 print(f"DEBUG: Entering image load else block for url: {url}")
>                 data = reply.readAll()
>                 print(f"DEBUG: type(data)={type(data)}, data={data[:40]}...")
>                 data_bytes = bytes(data)
>                 print(f"DEBUG: type(data_bytes)={type(data_bytes)}, len(data_bytes)={len(data_bytes)}")
>                 if not data_bytes:
>                     print(f"WARNING: No image data received for url: {url}")
>                 print(f"DEBUG: Image data length: {len(data_bytes)} bytes")
35,36c93,96
<                 pixmap.loadFromData(response.content)
<                 if not pixmap.isNull():
---
>                 loaded = pixmap.loadFromData(data_bytes)
>                 print(f"DEBUG: QPixmap loaded: {loaded}, isNull: {pixmap.isNull()}")
>                 if loaded and not pixmap.isNull():
>                     self.setPixmap(pixmap.scaled(self.width(), self.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
38d97
<                     self._update_scaled_pixmap()
40c99
<                     print("[ImagePreview] Image loaded successfully.")
---
>                     print(f"DEBUG: Network image loaded and pixmap is valid")
42,43c101
<                     print("[ImagePreview] Invalid image data.")
<                     self.setText("Invalid image data")
---
>                     self.setText("Image failed to load")
45,54c103,106
<             except Exception as e:
<                 print(f"[ImagePreview] Failed to load image: {e}")
<                 self.setText(f"Failed to load image: {e}")
<                 self.setPixmap(QPixmap())
<                 self._original_pixmap = None
<         else:
<             print("[ImagePreview] No image URL available.")
<             self.setText("No image available")
<             self.setPixmap(QPixmap())
<             self._original_pixmap = None
---
>                     self._original_pixmap = None
>             reply.deleteLater()
>             self._network_reply = None
>         reply.finished.connect(on_finished)
61d112
<         self._update_scaled_pixmap()
62a114,115
>         if self._original_pixmap:
>             self.setPixmap(self._original_pixmap.scaled(self.width(), self.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation))
diff -r FoS-DeckPro/ui/main_window.py FoS_DeckPro/ui/main_window.py
28,30d27
< <<<<<<<< HEAD:FoS-DeckPro/ui/main_window.py
< from models.card import CARD_FIELDS
< ========
40d36
< >>>>>>>> admin-tool-dev:FoS_DeckPro/ui/main_window.py
48,60d43
< <<<<<<<< HEAD:FoS-DeckPro/ui/main_window.py
<         # Use all Scryfall/card fields as columns
<         self.default_columns = list(CARD_FIELDS)
<         try:
<             self.columns, self.visible_columns = self.load_column_prefs()
<             # Fallback: if columns are missing or misaligned, reset to all fields
<             if not self.columns or len(self.columns) != len(self.default_columns):
<                 self.columns = self.default_columns.copy()
<                 self.visible_columns = self.default_columns.copy()
<         except Exception:
<             self.columns = self.default_columns.copy()
<             self.visible_columns = self.default_columns.copy()
< ========
64d46
< >>>>>>>> admin-tool-dev:FoS_DeckPro/ui/main_window.py
Only in FoS_DeckPro/utils: .DS_Store
Only in FoS_DeckPro/utils: __pycache__
diff -r FoS-DeckPro/utils/config.py FoS_DeckPro/utils/config.py
4a5,12
> # --- Centralized Error Reporting Config ---
> # Set to True to enable anonymous error reporting (opt-in, privacy-respecting)
> ERROR_REPORTING_ENABLED = False
> # Endpoint for error reports (leave blank to disable)
> ERROR_REPORTING_ENDPOINT = ''
> # App version for error reporting and diagnostics
> APP_VERSION = '1.0.0'
> 
Only in FoS_DeckPro/utils: error_reporting.py
Only in FoS_DeckPro/utils: license.py
Only in FoS_DeckPro/utils: packing_slip_file_manager.py
