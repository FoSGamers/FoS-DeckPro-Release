async def x_logout():
    """Logs out from X by clearing local tokens (no standard revoke)."""
    logger.info("Processing X logout request.")
    # X OAuth 1.0a doesn't have a standard token revocation endpoint.
    # We just clear the stored tokens locally.
    cleared_local = await clear_tokens("x")
    asyncio.create_task(event_bus.publish(ServiceControl(service_name="x", command="restart")))

    if cleared_local:
        return {"message": "X logout processed. Local tokens cleared."}
    else:
        raise HTTPException(status_code=500, detail="Logout processed, but failed to save cleared token state.")

# --- File: app/apis/auth_api.py --- END ---
""",
        "app/apis/settings_api.py": r"""# Generated by install_fosbot.py
# --- File: app/apis/settings_api.py --- START ---
import logging
from fastapi import APIRouter, HTTPException, Body, status
from pydantic import BaseModel, Field, field_validator # Use field_validator
from typing import Dict, Any, List, Optional

# Use specific helpers from json_store
from app.core.json_store import load_settings, update_setting, load_tokens
from app.core.event_bus import event_bus
from app.events import SettingsUpdated, ServiceControl # PlatformStatusUpdate is handled by services

logger = logging.getLogger(__name__)
router = APIRouter() # Mounted under /api in main.py

# --- Pydantic Models for Settings ---
# Define allowed log levels
VALID_LOG_LEVELS = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]

class AppSettingsUpdateModel(BaseModel):
    """Model for updating non-sensitive, non-token application settings via the API."""
    COMMAND_PREFIX: Optional[str] = Field(None, min_length=1, max_length=5)
    LOG_LEVEL: Optional[str] = Field(None)
    TWITCH_CHANNELS: Optional[str] = None # Comma-separated string

    # Use Pydantic v2 validator
    @field_validator('LOG_LEVEL')
    @classmethod
    def check_log_level(cls, v: Optional[str]):
        if v is not None and v.upper() not in VALID_LOG_LEVELS:
            raise ValueError(f'LOG_LEVEL must be one of: {", ".join(VALID_LOG_LEVELS)}')
        return v.upper() if v is not None else None

    class Config:
        extra = 'forbid' # Prevent unexpected fields

# --- API Endpoints ---

@router.get("/settings", response_model=Dict[str, Any], summary="Get Current Non-Token Settings & Auth Status")
async def get_current_settings():
    """
    Retrieves non-sensitive settings (like prefix, log level, channels)
    and the login status for OAuth platforms. Secrets/tokens are NOT returned.
    """
    logger.debug("GET /api/settings request received")
    all_settings = await load_settings() # Loads the entire settings.json
    if not isinstance(all_settings, dict):
         logger.error("Failed to load settings or invalid format encountered.")
         all_settings = {} # Return empty if load failed

    # Filter out sensitive keys explicitly
    non_sensitive_keys = ["COMMAND_PREFIX", "LOG_LEVEL", "TWITCH_CHANNELS"] # Add other non-secrets here
    display_settings = {k: all_settings.get(k) for k in non_sensitive_keys if k in all_settings}

    # Add default values if missing from file
    display_settings.setdefault('COMMAND_PREFIX', '!')
    display_settings.setdefault('LOG_LEVEL', 'INFO')
    display_settings.setdefault('TWITCH_CHANNELS', '')

    # Add authentication status for each platform
    platforms = ["twitch", "youtube", "x"]
    for p in platforms:
        tokens = await load_tokens(p) # Checks for stored access token
        display_settings[f"{p}_auth_status"] = {
            "logged_in": bool(tokens), # True if tokens were loaded (i.e., access_token exists)
            "user_login": tokens.get("user_login") if tokens else None # Display username if available
        }

    # Add Whatnot status (placeholder, maybe bridge reports this?)
    # For now, assume if bridge service is running (task exists?), it's 'connected'
    # This isn't perfect as it doesn't guarantee the *extension* is connected
    from app.main import _service_tasks_map # थोड़ा चक्रवर्ती आयात
    whatnot_task = _service_tasks_map.get("whatnot")
    whatnot_running = bool(whatnot_task and not whatnot_task.done())
    display_settings["whatnot_auth_status"] = {
        "logged_in": whatnot_running, # Use task status as proxy
         "user_login": "Extension Connected" if whatnot_running else "Extension Disconnected/Off"
    }


    logger.debug(f"Returning non-token settings & auth status: {display_settings}")
    return display_settings

@router.post("/settings", status_code=status.HTTP_200_OK, summary="Update Non-Token Application Settings")
async def update_settings_endpoint(new_settings: AppSettingsUpdateModel = Body(...)):
    """
    Updates non-sensitive application settings like command prefix, log level,
    and Twitch channels. Does NOT handle API keys or tokens (use OAuth flow).
    """
    logger.info("POST /api/settings request received for non-auth settings.")
    # Get only the fields explicitly set in the request body
    update_data = new_settings.dict(exclude_unset=True)

    if not update_data:
        logger.info("Update settings request received with no data.")
        # Return 200 OK but indicate no changes were made
        return {"message": "No settings provided for update."}

    logger.info(f"Attempting to update non-auth keys: {list(update_data.keys())}")
    updated_keys: List[str] = []
    failed_keys: List[str] = []
    actually_changed_keys: List[str] = [] # Track keys whose values genuinely changed

    initial_settings = await load_settings() # Load current state before update

    # Iterate through provided fields and update using the json_store helper
    for key, value in update_data.items():
        initial_value = initial_settings.get(key)
        try:
            # update_setting handles loading current, checking diff, saving, and publishing event
            # It returns True if save was successful OR if value was unchanged
            # It returns False if save failed
            success = await update_setting(key, value) # update_setting now updates global `settings` too
            if success:
                 # Check if the value actually changed compared to initial state
                 if initial_value != value:
                      actually_changed_keys.append(key)
                 # Add to potential success list (even if unchanged)
                 if key not in failed_keys:
                     updated_keys.append(key)
            else:
                # update_setting returned False, meaning save failed
                failed_keys.append(key)
        except Exception as e:
            # Catch unexpected errors during the update process for a specific key
            logger.exception(f"Unexpected error updating setting '{key}': {e}")
            failed_keys.append(key)

    # Consolidate unique keys
    final_updated_keys = list(set(actually_changed_keys) - set(failed_keys)) # Only report genuinely changed & saved keys
    failed_keys = list(set(failed_keys))

    if failed_keys:
        # If any key failed, report a 500 error
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to save settings for keys: {', '.join(failed_keys)}."
        )

    if not final_updated_keys:
        # If no keys failed and no keys were actually updated
        return {"message": "No setting values were changed."}

    # If successful and changes were made
    # SettingsUpdated event is published by update_setting now
    return {"message": f"Settings updated successfully: {', '.join(final_updated_keys)}."}


@router.post("/control/{service_name}/{command}", status_code=status.HTTP_202_ACCEPTED, summary="Control Platform Services")
async def control_service(service_name: str, command: str):
    """Sends a command (start, stop, restart) to a specified platform service via the event bus."""
    allowed_services = ["twitch", "youtube", "x", "whatnot"]
    allowed_commands = ["start", "stop", "restart"]
    service_name_lower = service_name.lower()
    command_lower = command.lower()

    if service_name_lower not in allowed_services:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Service '{service_name}' not recognized. Allowed: {', '.join(allowed_services)}"
        )
    if command_lower not in allowed_commands:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid command '{command}'. Allowed: {', '.join(allowed_commands)}"
        )

    logger.info(f"Control command '{command_lower}' for service '{service_name_lower}' received via API.")
    # Publish the event for main.py's handler
    event_bus.publish(ServiceControl(service_name=service_name_lower, command=command_lower))

    # Return 202 Accepted: The request is accepted, but processing happens asynchronously.
    return {"message": f"'{command_lower}' command queued for '{service_name_lower}' service."}

# --- File: app/apis/settings_api.py --- END ---
""",
        "app/apis/ws_endpoints.py": r"""# Generated by install_fosbot.py
# --- File: app/apis/ws_endpoints.py --- START ---
import logging
import json
import asyncio
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
import datetime # For timestamping Whatnot messages if needed

# Service handlers for WebSocket logic
# dashboard_service handles the /dashboard endpoint
from app.services.dashboard_service import handle_dashboard_websocket
# whatnot_bridge now manages the connection state from this endpoint
from app.services.whatnot_bridge import set_whatnot_websocket, clear_whatnot_websocket

# Event Bus and Events for communication with backend
from app.core.event_bus import event_bus
from app.events import InternalChatMessage, ChatMessageReceived, LogMessage # Added LogMessage

# --- Setup ---
logger = logging.getLogger(__name__)
router = APIRouter()

# --- WebSocket Endpoints ---

@router.websocket("/dashboard")
async def websocket_dashboard_endpoint(websocket: WebSocket):
    """Handles WebSocket connections from the Streamer Dashboard UI."""
    # Ensure dashboard_service exists and has this function
    try:
        await handle_dashboard_websocket(websocket) # Delegate to dashboard_service
    except NameError:
         logger.error("handle_dashboard_websocket function not found in dashboard_service.")
         await websocket.close(code=1011, reason="Dashboard service handler missing")
    except Exception as e:
        logger.exception(f"Error in dashboard websocket connection: {e}")
        # Attempt to close gracefully
        try: await websocket.close(code=1011)
        except: pass


@router.websocket("/whatnot")
async def websocket_whatnot_endpoint(websocket: WebSocket):
    """
    Handles WebSocket connections from the Whatnot Browser Extension.
    Accepts connection, registers it with whatnot_bridge, receives messages,
    parses them, and publishes ChatMessageReceived events.
    """
    client_host = websocket.client.host if websocket.client else "Unknown"
    client_port = websocket.client.port if websocket.client else "N/A"
    client_id = f"{client_host}:{client_port}"
    await websocket.accept()
    logger.info(f"Whatnot Extension client connected: {client_id}")
    # Register this active WebSocket with the bridge service
    try:
        set_whatnot_websocket(websocket)
    except NameError:
         logger.error("set_whatnot_websocket function not found in whatnot_bridge.")
         await websocket.close(code=1011, reason="Whatnot bridge handler missing")
         return
    except Exception as e:
        logger.exception(f"Error registering Whatnot websocket: {e}")
        await websocket.close(code=1011, reason="Backend registration error")
        return

    try:
        while True:
            data = await websocket.receive_text()
            logger.debug(f"Received raw data from Whatnot Ext {client_id}: {data}")

            try:
                message_data = json.loads(data)
                msg_type = message_data.get("type")

                if msg_type == "chat_message":
                    payload = message_data.get("payload", {})
                    user = payload.get("user")
                    text = payload.get("text")

                    if user and text: # Basic validation
                        # Create standardized internal message
                        msg = InternalChatMessage(
                            platform='whatnot',
                            user=user,
                            text=text,
                            channel=payload.get("channel", "whatnot_live"), # Add channel if available
                            user_id=payload.get("userId"), # Add user ID if available
                            timestamp=datetime.datetime.now(datetime.timezone.utc).isoformat(), # Use current UTC time
                            raw_data=payload # Store original payload
                        )
                        # Publish event for dashboard and chat processor
                        event_bus.publish(ChatMessageReceived(message=msg))
                    else:
                         logger.warning(f"Invalid Whatnot chat_message payload from {client_id}: Missing user or text. Payload: {payload}")

                elif msg_type == "ping":
                    # Respond to keepalives from extension
                    await websocket.send_json({"type": "pong"})
                    logger.debug(f"Sent pong to Whatnot Ext {client_id}")
                elif msg_type == "debug":
                     # Forward debug messages from extension to backend logs/dashboard
                     log_payload = message_data.get("payload", {})
                     log_level = log_payload.get("level", "DEBUG").upper()
                     log_msg = log_payload.get("message", "No message content.")
                     # Use standard logging levels
                     numeric_level = getattr(logging, log_level, logging.DEBUG)
                     logger.log(numeric_level, f"[WhatnotExt Debug] {log_msg}")
                     # Optionally publish to event bus for dashboard display
                     event_bus.publish(LogMessage(level=log_level, message=log_msg, module="WhatnotExtension"))
                else:
                    logger.warning(f"Received unknown message type '{msg_type}' from Whatnot Ext {client_id}: {data}")

            except json.JSONDecodeError:
                logger.warning(f"Received non-JSON message from Whatnot Ext {client_id}: {data}")
            except Exception as e:
                # Catch errors during message processing within the loop
                logger.exception(f"Error processing message from Whatnot Ext {client_id}: {e}")

    except WebSocketDisconnect as e:
        logger.info(f"Whatnot Extension client {client_id} disconnected (Code: {e.code}, Reason: {e.reason or 'N/A'}).")
    except Exception as e:
        # Catch other errors like connection closed unexpectedly
        logger.error(f"Unexpected error in Whatnot Extension WebSocket handler for {client_id}: {e}", exc_info=True)
    finally:
         # Crucial: Clear the WebSocket reference in the bridge service on disconnect/error
         logger.info(f"Cleaning up Whatnot Extension connection handler for {client_id}")
         try:
             clear_whatnot_websocket()
         except NameError:
              logger.error("clear_whatnot_websocket function not found in whatnot_bridge.")
         except Exception as e:
              logger.exception(f"Error clearing Whatnot websocket: {e}")


@router.websocket("/debug")
async def websocket_debug_endpoint(websocket: WebSocket):
    """Optional endpoint for receiving debug logs from extensions or other clients."""
    await websocket.accept()
    client_id = f"{websocket.client.host}:{websocket.client.port}" if websocket.client else "Unknown Debug Client"
    logger.info(f"Debug client connected: {client_id}")
    try:
        while True:
            data = await websocket.receive_text()
            try:
                debug_data = json.loads(data)
                if debug_data.get("type") == "debug":
                    message = debug_data.get("message", "No debug message content.")
                    source = debug_data.get("source", client_id) # Identify source if provided
                    level = debug_data.get("level", "DEBUG").upper()
                    log_level_int = getattr(logging, level, logging.DEBUG)
                    # Log clearly indicating the source
                    logger.log(log_level_int, f"[{source} DEBUG]: {message}")
                    # Optionally publish for dashboard display
                    # event_bus.publish(LogMessage(level=level, message=message, module=source)) # Maybe too noisy?
                else:
                    logger.warning(f"Received non-debug JSON via debug WS from {client_id}: {data}")
            except json.JSONDecodeError:
                logger.warning(f"Received non-JSON via debug WS from {client_id}: {data}")
            except Exception as e:
                logger.error(f"Error processing debug WS message from {client_id}: {e}")
    except WebSocketDisconnect:
        logger.info(f"Debug client {client_id} disconnected.")
    except Exception as e:
        logger.error(f"Unexpected error in debug WebSocket handler for {client_id}: {e}", exc_info=True)
    finally:
         logger.debug(f"Closing debug websocket connection for {client_id}")

# --- File: app/apis/ws_endpoints.py --- END ---
""",
        "app/apis/commands_api.py": r"""# Generated by install_fosbot.py
# --- File: app/apis/commands_api.py --- START ---
import logging
import csv
import io
from fastapi import APIRouter, HTTPException, UploadFile, File, status, Body # Added Status, Body
from pydantic import BaseModel, field_validator
from typing import Dict, List, Optional

# Use the json_store functions
from app.core.json_store import load_commands, save_commands

logger = logging.getLogger(__name__)
router = APIRouter() # Mounted under /api in main.py

# --- Pydantic Models ---
class CommandModel(BaseModel):
    command: str # Command name (without prefix)
    response: str

    # Add validation if needed, e.g., prevent empty command/response
    @field_validator('command')
    @classmethod
    def command_must_not_be_empty(cls, v: str):
        v = v.strip()
        if not v:
            raise ValueError('Command name cannot be empty.')
        # Ensure command doesn't include the prefix
        # Assuming prefix might be passed accidentally
        from app.core.config import settings # Local import to avoid circular dependency at module level
        prefix = settings.get('COMMAND_PREFIX', '!')
        if v.startswith(prefix):
            logger.warning(f"Command '{v}' submitted with prefix. Stripping prefix.")
            v = v[len(prefix):]
        # Basic sanitization - ensure lowercase
        return v.strip().lower()

    @field_validator('response')
    @classmethod
    def response_must_not_be_empty(cls, v: str):
        v = v.strip()
        if not v:
            raise ValueError('Command response cannot be empty.')
        return v

# --- API Endpoints ---

@router.get("/commands", response_model=Dict[str, str], summary="Get All Custom Commands")
async def get_commands_endpoint():
    """Fetches all currently defined custom commands."""
    logger.debug("GET /api/commands request received")
    commands = await load_commands()
    if not isinstance(commands, dict):
        logger.error("Failed to load commands or invalid format.")
        # Return empty dict instead of raising 500, allows UI to function
        return {}
    logger.debug(f"Returning {len(commands)} commands.")
    return commands

@router.post("/commands", response_model=CommandModel, status_code=status.HTTP_201_CREATED, summary="Add or Update a Custom Command")
async def add_or_update_command_endpoint(command_data: CommandModel = Body(...)):
    """Adds a new custom command or updates an existing one."""
    command_name = command_data.command # Already validated and cleaned by Pydantic
    response_text = command_data.response

    logger.info(f"POST /api/commands: Attempting to add/update command '!{command_name}'")
    commands = await load_commands()
    if not isinstance(commands, dict):
        logger.error("Failed to load commands before add/update.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to load existing commands.")

    is_update = command_name in commands
    action = "updated" if is_update else "added"

    commands[command_name] = response_text # Add or overwrite

    if await save_commands(commands):
        logger.info(f"Command '!{command_name}' successfully {action}.")
        # Reload commands in chat processor cache
        from app.services.chat_processor import load_and_cache_commands
        await load_and_cache_commands()
        # Return the saved command data
        return CommandModel(command=command_name, response=response_text)
    else:
        logger.error(f"Failed to save commands after attempting to {action} '!{command_name}'.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to save command '!{command_name}'.")

@router.delete("/commands/{command_name}", status_code=status.HTTP_200_OK, summary="Delete a Custom Command")
async def delete_command_endpoint(command_name: str):
    """Deletes a specific custom command."""
    # Clean the input command name same way as Pydantic model does
    cleaned_command_name = command_name.strip().lower()
    if not cleaned_command_name:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Command name cannot be empty.")

    logger.info(f"DELETE /api/commands/{cleaned_command_name}: Attempting to delete command.")
    commands = await load_commands()
    if not isinstance(commands, dict):
         logger.error("Failed to load commands before delete.")
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to load existing commands.")

    if cleaned_command_name in commands:
        del commands[cleaned_command_name]
        if await save_commands(commands):
            logger.info(f"Command '!{cleaned_command_name}' successfully deleted.")
            # Reload commands in chat processor cache
            from app.services.chat_processor import load_and_cache_commands
            await load_and_cache_commands()
            return {"message": f"Command '!{cleaned_command_name}' deleted successfully."}
        else:
            logger.error(f"Failed to save commands after deleting '!{cleaned_command_name}'.")
            # Add command back? Or just report error? Report error.
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to save changes after deleting command.")
    else:
        logger.warning(f"Attempted to delete non-existent command '!{cleaned_command_name}'.")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Command '!{cleaned_command_name}' not found.")

@router.post("/commands/upload", status_code=status.HTTP_201_CREATED, summary="Upload Commands via CSV")
async def upload_commands_endpoint(file: UploadFile = File(...)):
    """
    Uploads multiple commands from a CSV file.
    Expects CSV format: 'command_name,response_text' (optional header row).
    Overwrites existing commands with the same name.
    """
    logger.info(f"POST /api/commands/upload: Received file '{file.filename}' ({file.content_type})")
    if file.content_type != 'text/csv' and not file.filename.lower().endswith('.csv'):
        logger.warning(f"Invalid file type uploaded: {file.content_type} / {file.filename}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid file type. Please upload a CSV file.")

    commands = await load_commands()
    if not isinstance(commands, dict):
         logger.error("Failed to load commands before CSV upload.")
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to load existing commands.")

    added_count = 0
    updated_count = 0
    skipped_count = 0
    rows_processed = 0

    try:
        content = await file.read()
        # Use universal newlines mode for StringIO
        csv_file = io.StringIO(content.decode('utf-8-sig'), newline=None) # Handle BOM, standard newlines
        # Sniff for header presence
        try:
            has_header = csv.Sniffer().has_header(csv_file.read(1024))
        except csv.Error:
             has_header = False # Assume no header if sniffing fails
        csv_file.seek(0) # Rewind after sniffing
        reader = csv.reader(csv_file)

        if has_header:
            try:
                header = next(reader) # Skip header row
                rows_processed += 1
                logger.debug(f"Skipped CSV header: {header}")
            except StopIteration:
                 logger.warning("CSV file seems to contain only a header row.")
                 return {"message": "CSV processed. No command rows found.", "added": 0, "updated": 0, "skipped": 0}


        for i, row in enumerate(reader, start=rows_processed + 1):
            if not row or len(row) < 2:
                logger.warning(f"Skipping malformed CSV row {i}: {row}")
                skipped_count += 1
                continue

            command_raw = row[0].strip()
            response_raw = row[1].strip()

            # Basic validation
            if not command_raw or not response_raw:
                 logger.warning(f"Skipping row {i} due to empty command or response: {row}")
                 skipped_count += 1
                 continue

            # Clean command name (lowercase, no prefix)
            from app.core.config import settings # Local import
            prefix = settings.get('COMMAND_PREFIX', '!')
            if command_raw.startswith(prefix):
                command_name = command_raw[len(prefix):].strip().lower()
            else:
                command_name = command_raw.lower()

            if not command_name: # Check again after stripping prefix
                 logger.warning(f"Skipping row {i} due to effectively empty command after prefix strip: {row}")
                 skipped_count += 1
                 continue

            # Add/Update command
            if command_name in commands:
                 updated_count += 1
            else:
                 added_count += 1
            commands[command_name] = response_raw
            logger.debug(f"Processed row {i}: Adding/Updating command '!{command_name}'")

    except UnicodeDecodeError:
         logger.error("Failed to decode CSV file. Ensure it is UTF-8 encoded.")
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid file encoding. Please use UTF-8.")
    except csv.Error as e:
        logger.error(f"Error parsing CSV file: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Error parsing CSV: {e}")
    except Exception as e:
        logger.exception(f"Unexpected error processing CSV upload: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected error occurred during CSV processing.")
    finally:
        await file.close() # Ensure file handle is closed

    if added_count > 0 or updated_count > 0:
        if await save_commands(commands):
            logger.info(f"CSV upload successful: Added {added_count}, Updated {updated_count}, Skipped {skipped_count} commands.")
            # Reload commands in chat processor cache
            from app.services.chat_processor import load_and_cache_commands
            await load_and_cache_commands()
            return {
                "message": "Commands uploaded successfully.",
                "added": added_count,
                "updated": updated_count,
                "skipped": skipped_count
            }
        else:
            logger.error("Failed to save commands after CSV processing.")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to save commands after processing CSV.")
    else:
        logger.info(f"CSV processed. No new or updated commands found. Skipped {skipped_count} rows.")
        return {"message": "CSV processed. No new or updated commands found.", "added": 0, "updated": 0, "skipped": skipped_count}

# --- File: app/apis/commands_api.py --- END ---
""",

        # === app/services/ Files ===
        "app/services/__init__.py": r"""# Generated by install_fosbot.py
# Empty file to make services a package
""",
        "app/services/chat_processor.py": r"""# Generated by install_fosbot.py
# --- File: app/services/chat_processor.py (Derived from chat.py) --- START ---
import logging
import asyncio
import datetime
import random
import time # For cooldowns
from collections import defaultdict
from typing import Dict, List, Any, Optional, Awaitable, Callable # Added Callable, Awaitable

# Core imports
from app.core.event_bus import event_bus
from app.events import (
    ChatMessageReceived, CommandDetected, BotResponse, BotResponseToSend,
    StreamerInputReceived, BroadcastStreamerMessage, InternalChatMessage
)
from app.core.config import logger, settings # Use settings dict
# Use specific json_store functions
from app.core.json_store import load_checkins, save_checkins, load_commands, load_counters, save_counters, get_setting

# Command Handler Type Definition
CommandHandler = Callable[[CommandDetected], Awaitable[None]]
command_registry: Dict[str, CommandHandler] = {}
custom_commands: Dict[str, str] = {} # Cache for custom commands

# Cooldowns State
user_cooldowns: Dict[str, Dict[str, float]] = defaultdict(lambda: defaultdict(float)) # {cmd: {user_key: timestamp}}
global_cooldowns: Dict[str, float] = defaultdict(float) # {cmd: timestamp}

# Cooldown Durations (Defaults, can be overridden per command)
# Using more descriptive keys
COOLDOWN_CONFIG = {
    "default_user_cooldown": 5.0,
    "default_global_cooldown": 1.5,
    "cmd_checkin_user": 300.0, # 5 minutes for !checkin per user
    "cmd_seen_user": 10.0,
    "cmd_socials_user": 30.0,
    "cmd_commands_user": 20.0,
    "cmd_uptime_global": 10.0,
    "cmd_roll_user": 3.0,
    "cmd_roll_global": 1.0,
    # Add specific overrides here as needed
}

# Bot start time
bot_start_time = datetime.datetime.now(datetime.timezone.utc)

# --- Helper Functions ---

def send_reply(event: CommandDetected, text: str):
    """Helper to create and publish a BotResponseToSend event."""
    source_msg = event.source_message
    if not source_msg or not source_msg.platform:
        logger.error(f"Cannot send reply for command '{event.command}': Missing source message or platform.")
        return

    response = BotResponse(
        target_platform=source_msg.platform,
        target_channel=source_msg.channel, # Use the channel from the source message
        text=text,
        reply_to_user=source_msg.user # Pass user for potential @mentioning by platform service
        # reply_to_message_id=source_msg.message_id # Optional: Pass message ID if platform supports direct replies
    )
    event_bus.publish(BotResponseToSend(response=response))
    logger.debug(f"Published BotResponseToSend to {source_msg.platform}:{source_msg.channel or 'DM'}")


def format_timedelta_human(delta: datetime.timedelta) -> str:
    """Formats a timedelta into a human-readable string like '3d 4h' or '5m 10s'."""
    total_seconds = int(delta.total_seconds())
    if total_seconds < 1: return "just now"

    days, remainder = divmod(total_seconds, 86400)
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)

    parts = []
    if days > 0: parts.append(f"{days}d")
    if hours > 0: parts.append(f"{hours}h")
    if minutes > 0 and days == 0: parts.append(f"{minutes}m") # Only show mins if < 1 day
    if seconds > 0 and days == 0 and hours == 0: parts.append(f"{seconds}s") # Only show secs if < 1 hour

    return " ".join(parts[:2]) + " ago" if parts else "moments ago"

# --- Command Cooldown Check ---
def is_command_on_cooldown(command_name: str, user_platform: str, user_login: str) -> Optional[float]:
    """Checks user and global cooldowns. Returns remaining seconds if on cooldown, else None."""
    now = time.monotonic()
    is_admin = user_platform == 'dashboard' # Treat dashboard input as admin bypass
    if is_admin: return None

    user_key = f"{user_platform}:{user_login.lower()}" # Consistent key

    # Global Cooldown Check
    global_cd_key = f"cmd_{command_name}_global"
    global_duration = COOLDOWN_CONFIG.get(global_cd_key, COOLDOWN_CONFIG["default_global_cooldown"])
    last_global_use = global_cooldowns[command_name] # defaultdict defaults to 0.0
    if now < last_global_use + global_duration:
        remaining = (last_global_use + global_duration) - now
        logger.debug(f"Cmd '{command_name}' on global CD ({remaining:.1f}s left).")
        return remaining

    # User Cooldown Check
    user_cd_key = f"cmd_{command_name}_user"
    user_duration = COOLDOWN_CONFIG.get(user_cd_key, COOLDOWN_CONFIG["default_user_cooldown"])
    last_user_use = user_cooldowns[command_name][user_key] # defaultdict defaults to 0.0
    if now < last_user_use + user_duration:
        remaining = (last_user_use + user_duration) - now
        logger.debug(f"Cmd '{command_name}' on user CD for {user_key} ({remaining:.1f}s left).")
        return remaining

    return None # Not on cooldown

def update_cooldowns(command_name: str, user_platform: str, user_login: str):
    """Updates cooldown timestamps after successful execution."""
    now = time.monotonic()
    is_admin = user_platform == 'dashboard'
    if is_admin: return # Admins don't trigger cooldowns

    user_key = f"{user_platform}:{user_login.lower()}"
    global_cooldowns[command_name] = now
    user_cooldowns[command_name][user_key] = now
    logger.debug(f"Updated cooldowns for '{command_name}' (User: {user_key})")

# --- Built-in Command Handlers ---

async def handle_ping(event: CommandDetected):
    """Replies with Pong!"""
    send_reply(event, "Pong!")

async def handle_socials(event: CommandDetected):
    """Replies with social media links (loaded from config or hardcoded)."""
    # Example: Load from settings if available, otherwise use default
    social_text = await get_setting("SOCIALS_TEXT", "Follow me: twitch.tv/fos_gamers, youtube.com/@fos_gamers, x.com/fos_gamers")
    send_reply(event, social_text)

async def handle_lurk(event: CommandDetected):
    """Sends a thank you message for lurking."""
    send_reply(event, f"Thanks for the lurk, {event.source_message.user}! Enjoy the stream! o/")

async def handle_hype(event: CommandDetected):
    """Sends a hype message."""
    send_reply(event, "༼ つ ◕_◕ ༽つ HYPE! LET'S GOOOOO! ༼ つ ◕_◕ ༽つ")

async def handle_checkin(event: CommandDetected):
    """Records a user's check-in time."""
    user = event.source_message.user
    platform = event.source_message.platform
    user_id = str(event.source_message.user_id or user) # Prefer user_id if available
    checkin_key = f"{platform}:{user_id}"
    now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()

    checkins_data = await load_checkins() # Returns {} on failure/empty
    entry = checkins_data.get(checkin_key, {})

    entry['username'] = user # Always update username in case it changed
    entry['last_seen'] = now_iso
    entry['platform'] = platform # Store platform explicitly
    entry['channel'] = event.source_message.channel # Store channel

    checkin_count = entry.get('checkin_count', 0) + 1
    entry['checkin_count'] = checkin_count

    if 'first_seen' not in entry:
        entry['first_seen'] = now_iso
        reply_text = f"Welcome, {user}! You've checked in for the first time!"
        logger.info(f"First check-in for {user} ({checkin_key}).")
    else:
        reply_text = f"{user} checked in! (Total check-ins: {checkin_count})"
        logger.info(f"Check-in {checkin_count} for {user} ({checkin_key}).")

    checkins_data[checkin_key] = entry

    if await save_checkins(checkins_data):
        send_reply(event, reply_text)
    else:
        send_reply(event, "Sorry, there was an error saving your check-in.")
        logger.error(f"Failed to save checkin data for {checkin_key}")

async def handle_seen(event: CommandDetected):
    """Looks up when a user was last seen checked in."""
    if not event.args:
        send_reply(event, f"Usage: {settings.get('COMMAND_PREFIX', '!')}seen <username>")
        return

    target_user_lower = event.args[0].lstrip('@').lower()
    requesting_platform = event.source_message.platform
    found_record = None
    found_username = None

    checkins_data = await load_checkins()

    # Search for the user, prioritizing same platform, then others
    # Strategy: Find exact match on current platform first, then case-insensitive on current, then case-insensitive on others.
    search_order = [
        lambda k, r: r.get('platform') == requesting_platform and r.get('username', '').lower() == target_user_lower, # Exact platform, case-insensitive user
        lambda k, r: r.get('username', '').lower() == target_user_lower # Case-insensitive user on any platform
    ]

    for search_func in search_order:
        for key, record in checkins_data.items():
             if isinstance(record, dict) and search_func(key, record):
                  found_record = record
                  found_username = record.get('username', 'Unknown') # Use stored name
                  break # Found a match
        if found_record: break # Stop searching if found

    if found_record and found_username:
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        try:
            last_seen_dt = datetime.datetime.fromisoformat(found_record['last_seen'])
            first_seen_dt = datetime.datetime.fromisoformat(found_record.get('first_seen', found_record['last_seen'])) # Fallback to last_seen if first_seen missing
            # Ensure they are timezone-aware (assume UTC if not specified by ISO string)
            if last_seen_dt.tzinfo is None: last_seen_dt = last_seen_dt.replace(tzinfo=datetime.timezone.utc)
            if first_seen_dt.tzinfo is None: first_seen_dt = first_seen_dt.replace(tzinfo=datetime.timezone.utc)

            last_seen_delta = now_utc - last_seen_dt
            first_seen_delta = now_utc - first_seen_dt
            last_seen_fmt = format_timedelta_human(last_seen_delta)
            first_seen_fmt = format_timedelta_human(first_seen_delta)
            platform_seen = found_record.get('platform', 'unknown platform')
            channel_seen = found_record.get('channel')
            location_str = f"on {platform_seen}" + (f" in #{channel_seen}" if channel_seen else "")

            send_reply(event, f"Found {found_username} {location_str}. First seen: {first_seen_fmt}. Last seen: {last_seen_fmt}.")
        except (ValueError, KeyError, TypeError) as e:
             logger.error(f"Error parsing stored timestamp for {found_username}: {e}", exc_info=True)
             send_reply(event, f"Sorry, couldn't read the stored time data for {event.args[0]}.")
    else:
        send_reply(event, f"Haven't seen a check-in from '{event.args[0]}' yet.")

async def handle_uptime(event: CommandDetected):
    """Reports how long the bot process has been running."""
    uptime_delta = datetime.datetime.now(datetime.timezone.utc) - bot_start_time
    uptime_str = format_timedelta_human(uptime_delta).replace(" ago", "")
    if uptime_str == "just now": uptime_str = "a few moments"
    elif not uptime_str or uptime_str == "moments": uptime_str = "just started"
    send_reply(event, f"Bot process uptime: {uptime_str}")

async def handle_commands(event: CommandDetected):
    """Lists available commands."""
    prefix = settings.get('COMMAND_PREFIX', '!')
    # Combine built-in and custom commands
    all_cmds = sorted(list(command_registry.keys()) + list(custom_commands.keys()))
    # TODO: Add permission filtering here later
    formatted_cmds = [f"{prefix}{cmd}" for cmd in all_cmds]

    reply_text = "Available commands: " + ", ".join(formatted_cmds)
    MAX_LEN = 480 # Max length for typical chat message after prefixes etc.
    if len(reply_text) > MAX_LEN:
         # Split into multiple messages if too long (basic split)
         parts = []
         current_part = "Available commands: "
         for cmd in formatted_cmds:
              if len(current_part) + len(cmd) + 2 < MAX_LEN:
                   current_part += f"{cmd}, "
              else:
                   parts.append(current_part.rstrip(', '))
                   current_part = f"... {cmd}, "
         parts.append(current_part.rstrip(', '))
         for part in parts:
              send_reply(event, part)
              await asyncio.sleep(0.5) # Small delay between parts
    else:
         send_reply(event, reply_text)

async def handle_inc_counter(event: CommandDetected):
    """Increments a counter (e.g., !death). Command name is the counter key."""
    counter_name = event.command # e.g., 'death'
    counters = await load_counters() # Returns {} on failure

    current_value = counters.get(counter_name, 0)
    new_value = current_value + 1
    counters[counter_name] = new_value

    if await save_counters(counters):
        send_reply(event, f"{counter_name.capitalize()} count increased to {new_value}!")
        logger.info(f"Counter '{counter_name}' incremented to {new_value}.")
    else:
        send_reply(event, f"Sorry, error saving '{counter_name}' counter.")
        logger.error(f"Failed to save counters data after incrementing {counter_name}")

async def handle_show_count(event: CommandDetected):
     """Shows the value of a specific counter or all counters."""
     counters = await load_counters()
     if not event.args:
          # Show all counters if no argument provided
          if not counters:
               send_reply(event, "No counters are currently being tracked.")
               return
          reply_parts = ["Current Counts:"]
          for name, value in counters.items():
               reply_parts.append(f"{name.capitalize()}: {value}")
          send_reply(event, " | ".join(reply_parts))
     else:
          counter_name = event.args[0].lower()
          value = counters.get(counter_name, 0)
          send_reply(event, f"The current count for '{counter_name}' is: {value}")

async def handle_roll(event: CommandDetected):
    """Rolls dice (e.g., !roll d20, !roll 2d6)."""
    args = event.args
    if not args:
        args = ["d20"] # Default to d20

    roll_input = args[0].lower()
    num_dice = 1
    num_sides = 0

    try:
        if 'd' in roll_input:
            parts = roll_input.split('d')
            # Allow empty string before 'd' (means 1 die)
            num_dice_str = parts[0]
            if num_dice_str and num_dice_str.isdigit():
                num_dice = int(num_dice_str)
            elif num_dice_str: # If something is before 'd' but not a number
                 raise ValueError("Invalid number of dice")

            if parts[1].isdigit():
                num_sides = int(parts[1])
            else:
                 raise ValueError("Invalid sides format")
        elif roll_input.isdigit():
            # Interpret as rolling a single die with that many sides (e.g., !roll 6 is like !roll d6)
            num_sides = int(roll_input)
            if num_sides <= 0: raise ValueError("Sides must be positive")
        else:
             raise ValueError("Invalid roll format")

        # Add reasonable limits
        if not 1 <= num_dice <= 100: raise ValueError("Number of dice must be between 1 and 100.")
        if not 2 <= num_sides <= 1000: raise ValueError("Number of sides must be between 2 and 1000.")

        rolls = [random.randint(1, num_sides) for _ in range(num_dice)]
        total = sum(rolls)
        # Only show individual rolls if few dice, otherwise just total
        if num_dice <= 10:
            rolls_str = ", ".join(map(str, rolls))
            if num_dice == 1:
                 response_text = f"@{event.source_message.user} rolled a d{num_sides}: {total}"
            else:
                 response_text = f"@{event.source_message.user} rolled {num_dice}d{num_sides}: [{rolls_str}] Total = {total}"
        else: # Too many dice to show individually
             response_text = f"@{event.source_message.user} rolled {num_dice}d{num_sides}: Total = {total}"

    except ValueError as e:
        response_text = f"Invalid roll! Usage: !roll [N]d[S] (e.g., !roll d20, !roll 3d6). Error: {e}"
    except Exception as e:
         logger.error(f"Error during roll command: {e}", exc_info=True)
         response_text = "Oops, something went wrong with the dice!"

    send_reply(event, response_text)


# --- Command Registration ---
def register_command(name: str, handler: CommandHandler):
    """Registers a built-in command handler."""
    command_registry[name.lower()] = handler
    logger.debug(f"Registered built-in command: {name}")

# --- Register Built-in Commands ---
register_command("ping", handle_ping)
register_command("socials", handle_socials)
register_command("lurk", handle_lurk)
register_command("hype", handle_hype)
register_command("checkin", handle_checkin)
register_command("seen", handle_seen)
register_command("uptime", handle_uptime)
register_command("commands", handle_commands)
register_command("roll", handle_roll)
# Register counter commands dynamically based on convention? Or explicitly? Explicit for now.
register_command("death", handle_inc_counter)
register_command("win", handle_inc_counter)
register_command("fail", handle_inc_counter)
register_command("drop", handle_inc_counter) # Example additional counter
register_command("showcount", handle_show_count)


# --- Main Processing Logic ---
async def load_and_cache_commands():
     """Loads custom commands from JSON store into memory."""
     global custom_commands
     loaded = await load_commands() # load_commands now ensures lowercase keys
     if isinstance(loaded, dict):
          custom_commands = loaded
          logger.info(f"Loaded/Refreshed {len(custom_commands)} custom commands.")
     else:
          logger.error("Failed to load custom commands or invalid format.")
          custom_commands = {} # Reset cache on failure


async def process_chat_message(event: ChatMessageReceived):
    """Central processor for incoming messages."""
    msg = event.message
    prefix = settings.get('COMMAND_PREFIX', '!') # Get prefix from settings

    # Basic validation
    if not msg or not msg.text or not msg.user or not prefix:
        return

    # Check for command prefix
    if msg.text.startswith(prefix):
        parts = msg.text[len(prefix):].strip().split()
        if not parts: return # Ignore if only prefix is sent

        command_name = parts[0].lower()
        args = parts[1:]
        # Avoid logging the command detection if it's from Whatnot (can be spammy)
        if msg.platform != 'whatnot':
            logger.info(f"Command detected: '!{command_name}' from {msg.platform}:{msg.user}")

        # Ignore commands from Whatnot platform for now (Phase 1 limitation)
        # Re-enable this check if Whatnot commands should be ignored globally
        if msg.platform == 'whatnot':
             logger.debug(f"Ignoring command '!{command_name}' from Whatnot user {msg.user} (Phase 1)")
             return

        # Check cooldowns
        cooldown_remaining = is_command_on_cooldown(command_name, msg.platform, msg.user)
        if cooldown_remaining is not None:
            # Optionally notify user they are on cooldown (can be spammy)
            # send_reply(CommandDetected(command_name, args, msg), f"Command !{command_name} is on cooldown ({cooldown_remaining:.1f}s left).")
            logger.info(f"Command '!{command_name}' by {msg.user} skipped due to cooldown ({cooldown_remaining:.1f}s).")
            return

        # Create CommandDetected event
        cmd_event = CommandDetected(command=command_name, args=args, source_message=msg)

        # Check built-in commands first
        handler = command_registry.get(command_name)
        if handler:
            try:
                await handler(cmd_event)
                update_cooldowns(command_name, msg.platform, msg.user) # Update cooldowns *after* successful execution
            except Exception as e:
                logger.exception(f"Error executing built-in command handler for '!{command_name}': {e}")
                try: send_reply(cmd_event, f"Oops! Error running command '!{command_name}'.")
                except: pass # Avoid error loops
            return # Command handled

        # Check custom commands (case-insensitive lookup)
        custom_response = custom_commands.get(command_name)
        if custom_response:
            try:
                # Replace placeholders like {user}
                # Use display_name if available, fallback to user
                user_mention = f"@{msg.display_name or msg.user}"
                final_response = custom_response.replace("{user}", user_mention)
                # Add more placeholders as needed: {channel}, {platform}, {args[0]} etc.
                final_response = final_response.replace("{channel}", msg.channel or "unknown")
                final_response = final_response.replace("{platform}", msg.platform)
                final_response = final_response.replace("{arg1}", args[0] if args else "")
                # Add more {argN} or {all_args} if useful
                final_response = final_response.replace("{all_args}", " ".join(args))


                send_reply(cmd_event, final_response)
                update_cooldowns(command_name, msg.platform, msg.user) # Apply cooldowns to custom commands too
            except Exception as e:
                 logger.exception(f"Error sending custom command response for '!{command_name}': {e}")
                 try: send_reply(cmd_event, f"Oops! Error running custom command '!{command_name}'.")
                 except: pass
            return # Command handled

        # Handle Unknown Command (only if not from admin)
        if msg.platform != 'dashboard':
             logger.info(f"Unknown command '!{command_name}' from {msg.user}")
             # Consider only replying if it looks like a plausible command attempt, not just random text starting with '!'
             # For now, reply to any unknown command starting with prefix
             send_reply(cmd_event, f"Unknown command: '!{command_name}'. Try {prefix}commands.")


# --- Streamer Input Handling ---
async def handle_streamer_input(event: StreamerInputReceived):
    """Handles input from the streamer via the dashboard."""
    text = event.text.strip()
    if not text: return
    prefix = settings.get('COMMAND_PREFIX', '!')

    logger.info(f"Processing streamer input: '{text[:100]}...'")

    if text.startswith(prefix):
        # Treat as an admin command to be processed like any other command
        logger.info("Streamer input detected as command.")
        # Create a standard message object, marking it as from the dashboard admin
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        streamer_msg = InternalChatMessage(
            platform='dashboard',      # Special identifier for source
            user='STREAMER',           # Fixed admin username
            text=text,                 # The raw command string
            channel='admin_console',   # Arbitrary channel name/identifier
            timestamp=now_iso,         # Timestamp
            raw_data={'is_admin_command': True} # Metadata flag
        )
        # Publish ChatMessageReceived so chat_processor handles it
        # Allows admin commands to use the same command registry & bypass cooldowns
        event_bus.publish(ChatMessageReceived(message=streamer_msg))
    else:
        # Treat as a broadcast message request
        logger.info("Streamer input detected as broadcast message.")
        # Publish event for dashboard service to handle actual broadcasting
        event_bus.publish(BroadcastStreamerMessage(text=text))


# --- Service Setup ---
async def setup_chat_processor():
    """Loads commands and subscribes message processors to the event bus."""
    logger.info("Setting up Chat Processor...")
    await load_and_cache_commands() # Load custom commands on startup
    event_bus.subscribe(ChatMessageReceived, process_chat_message)
    event_bus.subscribe(StreamerInputReceived, handle_streamer_input) # Handle direct streamer input
    # Subscribe to command API events to reload cache? Or rely on API handlers to call reload.
    # event_bus.subscribe(CustomCommandsUpdated, load_and_cache_commands) # If using an event
    logger.info("Chat Processor setup complete and subscribed to events.")

# --- File: app/services/chat_processor.py --- END ---
""",
        "app/services/dashboard_service.py": r"""# Generated by install_fosbot.py
# --- File: app/services/dashboard_service.py --- START ---
import logging
import json
import asyncio
from fastapi import WebSocket, WebSocketDisconnect
from typing import Set # Use Set for active connections

# Core imports
from app.core.event_bus import event_bus
from app.events import (
    InternalChatMessage, ChatMessageReceived, PlatformStatusUpdate, LogMessage,
    StreamerInputReceived, BotResponseToSend, BroadcastStreamerMessage, BotResponse # Added BotResponse
)
# Use json_store for loading tokens to determine platforms to broadcast to
from app.core.json_store import load_tokens, load_settings # Load settings for masking

logger = logging.getLogger(__name__)

# --- Connection Management ---
class ConnectionManager:
    """Manages active WebSocket connections for the dashboard."""
    def __init__(self):
        self.active_connections: Set[WebSocket] = set()
        logger.info("Dashboard Connection Manager initialized.")

    async def connect(self, websocket: WebSocket):
        """Accepts a new WebSocket connection and adds it to the set."""
        await websocket.accept()
        self.active_connections.add(websocket)
        client_id = f"{websocket.client.host}:{websocket.client.port}" if websocket.client else "Unknown"
        logger.info(f"Dashboard client connected: {client_id} (Total: {len(self.active_connections)})")
        # Send initial status or welcome message
        try:
            await self.send_personal_message(json.dumps({"type":"status", "message":"Connected to FoSBot backend!"}), websocket)
        except Exception as e:
             logger.warning(f"Failed to send initial welcome to {client_id}: {e}")

    def disconnect(self, websocket: WebSocket):
        """Removes a WebSocket connection from the set."""
        client_id = f"{websocket.client.host}:{websocket.client.port}" if websocket.client else "Unknown"
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
            logger.info(f"Dashboard client disconnected: {client_id} (Total: {len(self.active_connections)})")
        else:
             logger.debug(f"Attempted to disconnect already removed client: {client_id}")

    async def send_personal_message(self, message: str, websocket: WebSocket) -> bool:
        """Sends a message to a single specific WebSocket connection. Returns True on success, False on failure."""
        if websocket in self.active_connections:
            try:
                await websocket.send_text(message)
                return True # Indicate success
            except Exception as e:
                 # Common errors: WebSocketStateError if closed during send, ConnectionClosedOK
                 client_id = f"{websocket.client.host}:{websocket.client.port}" if websocket.client else "Unknown"
                 # Log less severely for expected disconnects
                 if isinstance(e, (WebSocketDisconnect, ConnectionResetError, RuntimeError)):
                      logger.info(f"WebSocket closed for client {client_id} during send.")
                 else:
                      logger.warning(f"Failed to send personal message to client {client_id}: {e}. Disconnecting.")
                 # Disconnect on send error to clean up list
                 self.disconnect(websocket)
                 return False # Indicate failure
        return False # Not connected

    async def broadcast(self, data: dict):
        """Sends JSON data to all active WebSocket connections."""
        if not self.active_connections: return # Skip if no clients
        logger.debug(f"Broadcasting message type '{data.get('type')}' to {len(self.active_connections)} dashboard clients.")

        message_string = json.dumps(data) # Prepare message once
        # Use asyncio.gather for concurrent sending
        # Iterate over a copy of the set in case disconnect modifies it during broadcast
        tasks = [self.send_personal_message(message_string, ws) for ws in list(self.active_connections)]
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            # Log any errors that occurred during broadcast (send_personal_message already handles logging/disconnecting failed ones)
            error_count = sum(1 for result in results if isinstance(result, Exception) or result is False)
            if error_count > 0:
                 logger.warning(f"Broadcast finished with {error_count} send errors/failures.")

# Create a single instance of the manager
manager = ConnectionManager()

# --- WebSocket Handling Logic ---
async def handle_dashboard_websocket(websocket: WebSocket):
    """Handles the lifecycle of a single dashboard WebSocket connection."""
    await manager.connect(websocket)
    client_id = f"{websocket.client.host}:{websocket.client.port}" if websocket.client else "Unknown"
    try:
        while True:
            # Set a timeout for receive to detect dead connections sooner?
            # Or rely on ping/pong from frontend? Let's rely on frontend ping for now.
            data = await websocket.receive_text()
            logger.debug(f"Received from dashboard client {client_id}: {data}")
            try:
                message_data = json.loads(data)
                msg_type = message_data.get("type")
                payload = message_data.get("payload", {}) # Use payload consistently

                if msg_type == "streamer_input":
                    text = payload.get("text", "").strip() # Get text from payload
                    if text:
                        # Publish for backend processing (chat_processor handles command/broadcast logic)
                        event_bus.publish(StreamerInputReceived(text=text))
                        # Confirmation not strictly needed, relies on seeing message appear/action happen
                        # await manager.send_personal_message(json.dumps({"type": "status", "message": "Input received."}), websocket)
                    else:
                        logger.warning(f"Received empty streamer_input from {client_id}")
                        await manager.send_personal_message(json.dumps({"type": "error", "message": "Cannot send empty input."}), websocket)

                elif msg_type == "ping":
                    # Respond to keepalive pings from frontend
                    await manager.send_personal_message(json.dumps({"type":"pong"}), websocket)
                    logger.debug(f"Sent pong to dashboard client {client_id}")

                elif msg_type == "request_settings":
                     # Send current non-sensitive settings + auth status
                     logger.debug(f"Processing request_settings from {client_id}")
                     # Fetch settings via API handler logic for consistency
                     from app.apis.settings_api import get_current_settings
                     current_display_settings = await get_current_settings()
                     await manager.send_personal_message(json.dumps({"type": "current_settings", "payload": current_display_settings}), websocket)

                else:
                     logger.warning(f"Received unknown message type from dashboard {client_id}: {msg_type}")
                     await manager.send_personal_message(json.dumps({"type": "error", "message": f"Unknown message type: {msg_type}"}), websocket)

            except json.JSONDecodeError:
                logger.warning(f"Received non-JSON message from dashboard {client_id}: {data}")
                await manager.send_personal_message(json.dumps({"type": "error", "message": "Invalid JSON format."}), websocket)
            except Exception as e:
                 logger.exception(f"Error processing message from dashboard client {client_id}: {e}")
                 try: await manager.send_personal_message(json.dumps({"type": "error", "message": "Backend error processing request."}), websocket)
                 except: pass # Avoid error loops

    except WebSocketDisconnect as e:
        logger.info(f"Dashboard client {client_id} disconnected cleanly (Code: {e.code}).")
    except Exception as e:
        # Handle other potential exceptions during receive_text or connection handling
        logger.error(f"Dashboard client {client_id} unexpected error: {e}", exc_info=True)
    finally:
        manager.disconnect(websocket)


# --- Event Handlers (Subscribed by setup_dashboard_service_listeners) ---

async def forward_chat_to_dashboard(event: ChatMessageReceived):
    """Formats and broadcasts chat messages to all connected dashboards."""
    if not isinstance(event, ChatMessageReceived): return
    msg = event.message
    # Prepare payload matching frontend expectations
    payload_data = {
        "platform": msg.platform,
        "channel": msg.channel,
        "user": msg.user, # Use the primary username
        "display_name": msg.display_name or msg.user, # Fallback display name
        "text": msg.text,
        "timestamp": msg.timestamp # Already ISO string from InternalChatMessage
    }
    await manager.broadcast({"type": "chat_message", "payload": payload_data})

async def forward_status_to_dashboard(event: PlatformStatusUpdate):
    """Broadcasts platform connection status updates to dashboards."""
    if not isinstance(event, PlatformStatusUpdate): return
    payload_data = {
        "platform": event.platform,
        "status": event.status.lower(), # Ensure consistent casing
        "message": event.message or ""
    }
    await manager.broadcast({"type": "status_update", "payload": payload_data})

async def forward_log_to_dashboard(event: LogMessage):
    """Broadcasts important log messages (Info/Warning/Error/Critical) to dashboards."""
    if not isinstance(event, LogMessage): return
    # Only forward levels likely relevant to the user interface
    log_level_numeric = getattr(logging, event.level.upper(), logging.INFO)
    if log_level_numeric >= logging.INFO: # Send INFO and above
         payload_data = {
             "level": event.level.upper(),
             "message": event.message,
             "module": event.module or "Unknown" # Indicate source if available
         }
         await manager.broadcast({"type": "log_message", "payload": payload_data})

async def forward_bot_response_to_dashboard(event: BotResponseToSend):
    """Shows messages the bot sends in the dashboard chat for context."""
    if not isinstance(event, BotResponseToSend): return
    response = event.response
    # Mimic the chat message format but indicate it's from the bot
    payload_data = {
        "platform": response.target_platform,
        "channel": response.target_channel,
        "user": "FoSBot", # Clear bot identifier
        "display_name": "FoSBot",
        "text": response.text,
        "timestamp": datetime.datetime.now(datetime.timezone.utc).isoformat()
    }
    await manager.broadcast({"type": "bot_response", "payload": payload_data}) # Use distinct type


async def handle_broadcast_request(event: BroadcastStreamerMessage):
    """
    Receives a request to broadcast a message and publishes BotResponseToSend
    events for each connected/authenticated platform.
    """
    if not isinstance(event, BroadcastStreamerMessage): return
    logger.info(f"Received request to broadcast: '{event.text[:50]}...'")
    platforms_to_try = ["twitch", "youtube", "x"] # Whatnot handled via extension response
    # Get user login names for channel context if available
    tokens = {p: await load_tokens(p) for p in platforms_to_try}

    for platform in platforms_to_try:
        platform_tokens = tokens.get(platform)
        if platform_tokens and platform_tokens.get("access_token"):
             # Determine target channel (use user_login or a default)
             target_channel = platform_tokens.get("user_login", f"{platform}_default_channel")
             # For Twitch, use the *first* configured channel if available, else user_login
             if platform == 'twitch':
                  channels_str = await get_setting("TWITCH_CHANNELS", "")
                  channels_list = [ch.strip().lower() for ch in channels_str.split(',') if ch.strip()]
                  target_channel = channels_list[0] if channels_list else platform_tokens.get("user_login")

             if not target_channel:
                  logger.warning(f"Cannot determine target channel for broadcast on {platform}.")
                  continue

             response = BotResponse(
                  target_platform=platform,
                  target_channel=target_channel,
                  text=f"[Broadcast] {event.text}" # Prefix to indicate it's a broadcast
             )
             event_bus.publish(BotResponseToSend(response=response))
             logger.debug(f"Published broadcast message for {platform} to channel {target_channel}")
        else:
             logger.debug(f"Skipping broadcast for {platform}: Not authenticated.")


# --- Setup Function ---
def setup_dashboard_service_listeners():
    """Subscribes the necessary handlers to the event bus."""
    logger.info("Setting up Dashboard Service event listeners...")
    event_bus.subscribe(ChatMessageReceived, forward_chat_to_dashboard)
    event_bus.subscribe(PlatformStatusUpdate, forward_status_to_dashboard)
    event_bus.subscribe(LogMessage, forward_log_to_dashboard)
    # Subscribe to see bot's own messages in dashboard
    event_bus.subscribe(BotResponseToSend, forward_bot_response_to_dashboard)
    # Subscribe to handle broadcast requests coming from streamer input handler
    event_bus.subscribe(BroadcastStreamerMessage, handle_broadcast_request)
    logger.info("Dashboard Service listeners subscribed.")

# --- File: app/services/dashboard_service.py --- END ---
""",
        "app/services/streamer_command_handler.py": r"""# Generated by install_fosbot.py
# --- File: app/services/streamer_command_handler.py --- START ---
import logging
import datetime
from app.core.event_bus import event_bus
from app.events import StreamerInputReceived, CommandDetected, BroadcastStreamerMessage, InternalChatMessage # Use specific events
from app.core.config import logger, settings # Use settings dict

async def handle_streamer_input(event: StreamerInputReceived):
    """Handles raw text input from the streamer dashboard."""
    text = event.text.strip()
    if not text:
        logger.debug("Ignoring empty streamer input.")
        return

    prefix = settings.get('COMMAND_PREFIX', '!') # Get current command prefix
    logger.info(f"Processing streamer input: '{text[:100]}...'")

    if text.startswith(prefix):
        # Treat as a command to be processed by the main chat processor
        logger.info("Streamer input detected as command.")
        # Create a standard message object, marking it as from the dashboard admin
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        streamer_msg = InternalChatMessage(
            platform='dashboard',      # Special identifier for source
            user='STREAMER',           # Fixed admin username
            text=text,                 # The raw command string
            channel='admin_console',   # Arbitrary channel name/identifier
            timestamp=now_iso,         # Timestamp
            raw_data={'is_admin_command': True} # Metadata flag
        )
        # Publish ChatMessageReceived so chat_processor handles it
        # Allows admin commands to use the same command registry & bypass cooldowns
        event_bus.publish(ChatMessageReceived(message=streamer_msg))
    else:
        # Treat as a broadcast message request
        logger.info("Streamer input detected as broadcast message.")
        # Publish event for dashboard service to handle actual broadcasting
        event_bus.publish(BroadcastStreamerMessage(text=text))

def setup_streamer_command_handler():
    """Subscribes the handler to the event bus."""
    logger.info("Setting up Streamer Command/Input Handler...")
    # Listen for raw input from the dashboard WebSocket handler
    event_bus.subscribe(StreamerInputReceived, handle_streamer_input)
    logger.info("Streamer Command/Input Handler subscribed to StreamerInputReceived.")

# Note: Actual command execution logic (like !announce) should reside
# in the chat_processor's command handlers, triggered when it receives
# the ChatMessageReceived event with platform='dashboard'.

# --- File: app/services/streamer_command_handler.py --- END ---
""",
        "app/services/twitch_service.py": r"""# Generated by install_fosbot.py
# --- File: app/services/twitch_service.py --- START ---
import logging
import asyncio
import time
import traceback
from twitchio.ext import commands
from twitchio import Client, Chatter, Channel, Message # Use specific twitchio types
from twitchio.errors import AuthenticationError, TwitchIOException # Use specific errors
import httpx
from collections import defaultdict
import datetime
from typing import Dict, List, Optional, Coroutine, Any # Added imports

# Core imports
from app.core.json_store import load_tokens, save_tokens, get_setting # Use get_setting for TWITCH_CHANNELS
# Import App Owner Credentials from config
from app.core.config import logger, TWITCH_APP_CLIENT_ID, TWITCH_APP_CLIENT_SECRET
from app.core.event_bus import event_bus
from app.events import (
    InternalChatMessage, ChatMessageReceived,
    BotResponseToSend, BotResponse,
    PlatformStatusUpdate, SettingsUpdated, ServiceControl, LogMessage
)

# --- Constants ---
TWITCH_TOKEN_URL = "https://id.twitch.tv/oauth2/token"
DEFAULT_SEND_DELAY = 1.6 # Seconds between messages to avoid rate limits

# --- Module State ---
_STATE = {
    "task": None,       # The asyncio.Task running the main service loop
    "instance": None,   # The active TwitchBot instance
    "running": False,   # Control flag for the main run loop (set by start/stop)
    "connected": False, # Actual connection status flag
    "user_login": None, # Store the login name associated with the token
    "user_id": None,    # Store the user ID associated with the token
}
# Global reference to the task for cancellation from main.py
_run_task: asyncio.Task | None = None

# --- Twitch Bot Class ---
class TwitchBot(commands.Bot):
    """Custom Bot class extending twitchio.ext.commands.Bot"""
    def __init__(self, token: str, nick: str, client_id: str, channels: List[str]):
        self.initial_channels_list = [ch.strip().lower() for ch in channels if ch.strip()]
        if not self.initial_channels_list:
            logger.warning("TwitchBot initialized with an empty channel list.")

        # Ensure token starts with oauth:, handle None token gracefully
        valid_token = token if token and token.startswith('oauth:') else (f'oauth:{token}' if token else None)
        if not valid_token:
             # This should ideally be caught before initialization, but handle defensively
             logger.error("CRITICAL: TwitchBot initialized without a valid token.")
             # Raise an error to prevent proceeding without auth
             raise ValueError("Cannot initialize TwitchBot without a valid OAuth token.")

        if not nick:
             logger.error("CRITICAL: TwitchBot initialized without a 'nick' (username).")
             raise ValueError("Cannot initialize TwitchBot without a 'nick'.")
        if not client_id:
             logger.error("CRITICAL: TwitchBot initialized without a 'client_id'.")
             raise ValueError("Cannot initialize TwitchBot without a 'client_id'.")

        super().__init__(
            token=valid_token,
            client_id=client_id,
            nick=nick.lower(), # Ensure nick is lowercase
            prefix=None, # We handle commands via event bus, not twitchio's prefix system
            initial_channels=self.initial_channels_list
        )
        self._closing = False
        self._response_queue: asyncio.Queue[BotResponse] = asyncio.Queue(maxsize=100) # Queue for outgoing messages
        self._sender_task: asyncio.Task | None = None
        logger.info(f"TwitchBot instance created for nick '{self.nick}'. Attempting to join: {self.initial_channels_list}")

    async def event_ready(self):
        """Called once the bot connects to Twitch successfully."""
        global _STATE
        _STATE["connected"] = True
        self._closing = False
        # Store actual user ID and nick confirmed by Twitch
        _STATE["user_id"] = self.user_id
        _STATE["user_login"] = self.nick
        logger.info(f"Twitch Bot Ready! Logged in as: {self.nick} (ID: {self.user_id})")
        if self.connected_channels:
            channel_names = ', '.join(ch.name for ch in self.connected_channels)
            logger.info(f"Successfully joined channels: {channel_names}")
            event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connected', message=f"Joined: {channel_names}"))
        else:
            logger.warning(f"Twitch Bot connected but failed to join specified channels: {self.initial_channels_list}")
            event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message="Connected but failed to join channels"))

        # Start the message sender task only when ready
        if self._sender_task is None or self._sender_task.done():
            self._sender_task = asyncio.create_task(self._message_sender(), name=f"TwitchSender_{self.nick}")
            logger.info("Twitch message sender task started.")

        # Subscribe to BotResponseToSend events *after* ready and sender is running
        event_bus.subscribe(BotResponseToSend, self.handle_bot_response_event)

    async def event_message(self, message: Message):
        """Processes incoming chat messages from joined channels."""
        # Ignore messages from the bot itself or if shutting down
        if message.echo or self._closing or not message.author or not message.channel:
            return

        logger.debug(f"Twitch <#{message.channel.name}> {message.author.name}: {message.content}")

        # Convert timestamp to UTC ISO format string
        timestamp_iso = message.timestamp.replace(tzinfo=datetime.timezone.utc).isoformat() if message.timestamp else datetime.datetime.now(datetime.timezone.utc).isoformat()

        # Create the standardized internal message format
        internal_msg = InternalChatMessage(
            platform='twitch',
            channel=message.channel.name,
            user=message.author.name, # Use name for general display
            text=message.content,
            timestamp=timestamp_iso,
            # Include additional useful info
            user_id=str(message.author.id),
            display_name=message.author.display_name,
            message_id=message.id,
            raw_data={ # Store tags and other potentially useful raw data
                'tags': message.tags or {},
                'is_mod': message.author.is_mod,
                'is_subscriber': message.author.is_subscriber,
                'bits': getattr(message, 'bits', 0) # Include bits if available
            }
        )
        # Publish the internal message onto the event bus
        event_bus.publish(ChatMessageReceived(message=internal_msg))

    async def event_join(self, channel: Channel, user: Chatter):
        """Logs when a user (or the bot) joins a channel."""
        # Log joins unless it's the bot itself joining
        if user.name and self.nick and user.name.lower() != self.nick.lower():
            logger.debug(f"User '{user.name}' joined #{channel.name}")

    async def event_part(self, channel: Channel, user: Chatter):
        """Logs when a user (or the bot) leaves a channel."""
         if user.name and self.nick and user.name.lower() != self.nick.lower():
            logger.debug(f"User '{user.name}' left #{channel.name}")

    async def event_error(self, error: Exception, data: str = None):
        """Handles errors reported by the twitchio library."""
        global _STATE
        error_name = type(error).__name__
        logger.error(f"Twitch Bot event_error: {error_name} - {error}", exc_info=logger.isEnabledFor(logging.DEBUG))

        # Specific handling for authentication failures
        if isinstance(error, AuthenticationError) or 'Login authentication failed' in str(error):
            logger.critical("Twitch login failed - Invalid token or nick. Check settings. Disabling service.")
            event_bus.publish(PlatformStatusUpdate(platform='twitch', status='auth_error', message='Login failed - Check Credentials'))
            _STATE["running"] = False # Signal the main run loop to stop retrying this config
            # Optionally clear the bad token here
            # await clear_tokens("twitch")
        elif isinstance(error, TwitchIOException):
             logger.error(f"Twitch IO Error: {error}. May indicate connection issue.")
             # Let the main loop handle reconnection for IO errors
                          event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"IO Error: {error_name}"))
                     else:
                         # General error reporting
                         event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"Internal Error: {error_name}"))

                 async def event_close(self):
                     """Called when the underlying connection is closed."""
                     global _STATE
                     logger.warning(f"Twitch Bot WebSocket connection closed (Instance ID: {id(self)}).")
                     _STATE["connected"] = False
                     # Stop the sender task if it's running
                     if self._sender_task and not self._sender_task.done():
                          logger.debug("Cancelling sender task due to connection close.")
                          self._sender_task.cancel()
                     # Unsubscribe from BotResponseToSend to prevent queueing messages while disconnected
                     # Check if method exists before unsubscribing (handle potential race conditions)
                     if hasattr(self, 'handle_bot_response_event'):
                          try:
                               event_bus.unsubscribe(BotResponseToSend, self.handle_bot_response_event)
                          except ValueError:
                               pass # Already unsubscribed

                     # Publish disconnected status only if not initiated by our own shutdown
                     if not self._closing:
                         event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnected', message="Connection closed unexpectedly"))
                         # Reconnection is handled by the run_twitch_service loop

                 async def handle_bot_response_event(self, event: BotResponseToSend):
                     """Event bus subscriber method to queue outgoing messages."""
                     # Check if this response is for Twitch and if we are connected
                     if event.response.target_platform == 'twitch' and _STATE.get("connected") and not self._closing:
                         logger.debug(f"Queueing Twitch response for channel {event.response.target_channel}: {event.response.text[:50]}...")
                         try:
                             self._response_queue.put_nowait(event.response)
                         except asyncio.QueueFull:
                             logger.error("Twitch response queue FULL! Discarding message.")
                     # Silently ignore messages for other platforms or when disconnected/closing

                 async def _message_sender(self):
                     """Task that pulls messages from the queue and sends them with rate limiting."""
                     global _STATE
                     logger.info("Twitch message sender task running.")
                     while _STATE.get("connected") and not self._closing:
                         try:
                             # Wait for a message with a timeout to allow checking the running state
                             response: BotResponse = await asyncio.wait_for(self._response_queue.get(), timeout=1.0)

                             target_channel_name = response.target_channel
                             if not target_channel_name:
                                 logger.warning("Skipping Twitch send: No target channel specified.")
                                 self._response_queue.task_done()
                                 continue

                             # Get the channel object (case-insensitive check)
                             channel = self.get_channel(target_channel_name.lower())
                             if not channel:
                                 # Attempt to join the channel if not currently joined
                                 logger.warning(f"Not in channel '{target_channel_name}'. Attempting to join...")
                                 try:
                                      await self.join_channels([target_channel_name.lower()])
                                      # Give twitchio a moment to process the join
                                      await asyncio.sleep(1.0)
                                      channel = self.get_channel(target_channel_name.lower())
                                      if not channel:
                                           logger.error(f"Failed to join channel '{target_channel_name}' for sending.")
                                           self._response_queue.task_done()
                                           continue
                                      else:
                                           logger.info(f"Successfully joined '{target_channel_name}' for sending.")
                                 except Exception as join_err:
                                      logger.error(f"Error joining channel '{target_channel_name}': {join_err}")
                                      self._response_queue.task_done()
                                      continue

                             # Format message (e.g., add reply mention)
                             text_to_send = response.text
                             if response.reply_to_user:
                                 clean_user = response.reply_to_user.lstrip('@')
                                 text_to_send = f"@{clean_user}, {text_to_send}"

                             # Send the message
                             try:
                                 # Truncate if necessary (Twitch limit is 500 chars)
                                 if len(text_to_send) > 500:
                                      logger.warning(f"Truncating message to 500 chars for Twitch: {text_to_send[:50]}...")
                                      text_to_send = text_to_send[:500]

                                 logger.info(f"Sending Twitch to #{target_channel_name}: {text_to_send[:100]}...")
                                 await channel.send(text_to_send)
                                 self._response_queue.task_done()
                                 # Wait *after* sending to respect rate limits
                                 await asyncio.sleep(DEFAULT_SEND_DELAY)
                             except ConnectionResetError:
                                 logger.error(f"Connection reset while sending to #{target_channel_name}. Stopping sender.")
                                 self._response_queue.task_done()
                                 break # Exit sender loop, main loop will handle reconnect
                             except TwitchIOException as tio_e:
                                 logger.error(f"TwitchIO Error during send: {tio_e}. Message likely not sent.")
                                 self._response_queue.task_done()
                                 await asyncio.sleep(DEFAULT_SEND_DELAY) # Still wait to avoid spamming on transient errors
                             except Exception as send_e:
                                 logger.error(f"Unexpected error sending to #{target_channel_name}: {send_e}", exc_info=True)
                                 self._response_queue.task_done()
                                 await asyncio.sleep(DEFAULT_SEND_DELAY) # Wait even on error

                         except asyncio.TimeoutError:
                             # No message in queue, loop continues to check connected/closing state
                             continue
                         except asyncio.CancelledError:
                             logger.info("Twitch message sender task cancelled.")
                             break # Exit loop
                         except Exception as e:
                             logger.exception(f"Critical error in Twitch sender loop: {e}")
                             await asyncio.sleep(5) # Pause before potentially retrying loop

                     logger.warning("Twitch message sender task stopped.")
                     # Ensure any remaining tasks in queue are marked done if loop exits unexpectedly
                     while not self._response_queue.empty():
                         try: self._response_queue.get_nowait(); self._response_queue.task_done()
                         except asyncio.QueueEmpty: break

                 async def custom_shutdown(self):
                     """Initiates a graceful shutdown of this bot instance."""
                     global _STATE
                     if self._closing: return # Prevent double shutdown
                     instance_id = id(self)
                     logger.info(f"Initiating shutdown for TwitchBot instance {instance_id}...")
                     self._closing = True
                     _STATE["connected"] = False # Mark as disconnected immediately

                     # Unsubscribe from events first
                     if hasattr(self, 'handle_bot_response_event'):
                          try: event_bus.unsubscribe(BotResponseToSend, self.handle_bot_response_event)
                          except ValueError: pass

                     event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnecting'))

                     # Cancel and await the sender task
                     if self._sender_task and not self._sender_task.done():
                         if not self._sender_task.cancelling():
                             logger.debug(f"Cancelling sender task for instance {instance_id}...")
                             self._sender_task.cancel()
                         try:
                             await asyncio.wait_for(self._sender_task, timeout=5.0)
                             logger.debug(f"Sender task for instance {instance_id} finished.")
                         except asyncio.CancelledError:
                             logger.debug(f"Sender task for instance {instance_id} confirmed cancelled.")
                         except asyncio.TimeoutError:
                              logger.warning(f"Timeout waiting for sender task of instance {instance_id} to cancel.")
                         except Exception as e:
                             logger.error(f"Error awaiting cancelled sender task for instance {instance_id}: {e}")
                     self._sender_task = None

                     # Clear the response queue *before* closing the connection
                     logger.debug(f"Clearing response queue for instance {instance_id}...")
                     while not self._response_queue.empty():
                         try: self._response_queue.get_nowait(); self._response_queue.task_done()
                         except asyncio.QueueEmpty: break
                     logger.debug(f"Response queue cleared for instance {instance_id}.")

                     # Close the twitchio connection
                     logger.debug(f"Closing Twitch connection for instance {instance_id}...")
                     try:
                         # Use twitchio's close method
                         await self.close()
                     except Exception as e:
                         logger.error(f"Error during twitchio bot close for instance {instance_id}: {e}", exc_info=True)
                     logger.info(f"Twitch bot instance {instance_id} shutdown process complete.")


             # --- Token Refresh ---
             async def refresh_twitch_token(refresh_token: str) -> Optional[Dict[str, Any]]:
                 """Refreshes the Twitch OAuth token."""
                 if not refresh_token:
                     logger.error("Cannot refresh Twitch token: No refresh token provided.")
                     return None
                 if not TWITCH_APP_CLIENT_ID or not TWITCH_APP_CLIENT_SECRET:
                     logger.error("Cannot refresh Twitch token: App credentials missing.")
                     return None

                 logger.info("Attempting to refresh Twitch OAuth token...")
                 token_params = {
                     "grant_type": "refresh_token",
                     "refresh_token": refresh_token,
                     "client_id": TWITCH_APP_CLIENT_ID,
                     "client_secret": TWITCH_APP_CLIENT_SECRET
                 }
                 async with httpx.AsyncClient(timeout=15.0) as client:
                     try:
                         response = await client.post(TWITCH_TOKEN_URL, data=token_params)
                         response.raise_for_status()
                         token_data = response.json()
                         logger.info("Twitch token refreshed successfully.")
                         # Prepare data structure consistent with save_tokens expectations
                         return {
                             "access_token": token_data.get("access_token"),
                             "refresh_token": token_data.get("refresh_token"), # Usually gets a new refresh token too
                             "expires_in": token_data.get("expires_in"),
                             "scope": token_data.get("scope", []), # Scope might be a list here
                         }
                     except httpx.TimeoutException:
                         logger.error("Timeout refreshing Twitch token.")
                         return None
                     except httpx.HTTPStatusError as e:
                         logger.error(f"HTTP error refreshing Twitch token: {e.response.status_code} - {e.response.text}")
                         if e.response.status_code in [400, 401]: # Bad request or unauthorized often means bad refresh token
                              logger.error("Refresh token may be invalid or revoked.")
                              # Consider clearing the invalid token here? Or let auth flow handle it.
                         return None
                     except Exception as e:
                         logger.exception(f"Unexpected error refreshing Twitch token: {e}")
                         return None

             # --- Service Runner & Control ---
             async def run_twitch_service():
                 """Main loop for the Twitch service: handles loading config, connecting, and reconnecting."""
                 global _STATE, _run_task
                 logger.info("Twitch service runner task started.")

                 while True: # Outer loop allows reloading settings if needed
                     # --- Cancellation Check ---
                     # Use current_task() instead of relying on _run_task which might be None briefly
                     current_task_obj = asyncio.current_task()
                     if current_task_obj and current_task_obj.cancelled():
                          logger.info("Twitch run loop detected cancellation request.")
                          break

                     # --- Load Configuration ---
                     logger.debug("Loading Twitch tokens and settings...")
                     token_data = await load_tokens("twitch")
                     # Load channels specifically using get_setting with a default
                     channels_str = await get_setting("TWITCH_CHANNELS", "")
                     channels_list = [ch.strip().lower() for ch in channels_str.split(',') if ch.strip()]

                     # --- Configuration Validation ---
                     if not token_data or not token_data.get("access_token") or not token_data.get("user_login"):
                         logger.warning("Twitch service disabled: Not authenticated via OAuth. Waiting for login.")
                         event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disabled', message='Not logged in'))
                         await wait_for_settings_update({"twitch_access_token"}) # Wait for login event essentially
                         continue # Re-check config after settings update

                     if not TWITCH_APP_CLIENT_ID: # App Client ID is needed by twitchio
                          logger.error("Twitch service disabled: TWITCH_APP_CLIENT_ID missing in config.")
                          event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disabled', message='App Client ID Missing'))
                          # This is an admin config issue, likely won't be fixed by user settings update
                          await asyncio.sleep(300) # Wait a long time
                          continue

                     if not channels_list:
                         # Default to the authenticated user's own channel if none specified
                         own_channel = token_data["user_login"].lower()
                         logger.warning(f"No TWITCH_CHANNELS configured. Defaulting to bot's own channel: {own_channel}")
                         channels_list = [own_channel]
                         # Optionally save this default back? For now, just use it.
                         # await update_setting("TWITCH_CHANNELS", own_channel)

                     # --- Token Refresh Check ---
                     expires_at = token_data.get("expires_at")
                     if expires_at and expires_at < time.time() + 300: # 5 min buffer
                         logger.info("Twitch token expired or expiring soon. Attempting refresh...")
                         refreshed_data = await refresh_twitch_token(token_data.get("refresh_token"))
                         if refreshed_data:
                              # Need user_id and user_login which aren't returned by refresh
                              refreshed_data['user_id'] = token_data.get('user_id')
                              refreshed_data['user_login'] = token_data.get('user_login')
                              if await save_tokens("twitch", refreshed_data):
                                   token_data = await load_tokens("twitch") # Reload updated tokens
                                   logger.info("Twitch token refreshed and saved successfully.")
                              else:
                                   logger.error("Failed to save refreshed Twitch token. Stopping service.")
                                   event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message='Token refresh save failed'))
                                   _STATE["running"] = False # Stop trying until manual intervention
                                   break # Exit outer loop
                         else:
                             logger.error("Twitch token refresh failed. Requires manual re-authentication.")
                             event_bus.publish(PlatformStatusUpdate(platform='twitch', status='auth_error', message='Token refresh failed'))
                             # Clear potentially invalid token to force re-auth
                             await clear_tokens("twitch")
                             await wait_for_settings_update({"twitch_access_token"}) # Wait for new login
                             continue # Restart outer loop

                     # --- Connection Loop ---
                     _STATE["running"] = True # Set running flag for this configuration attempt
                     attempt = 0
                     MAX_CONNECT_ATTEMPTS = 5
                     bot_instance = None

                     while _STATE.get("running") and attempt < MAX_CONNECT_ATTEMPTS:
                         attempt += 1
                         try:
                             logger.info(f"Attempting Twitch connection (Attempt {attempt}/{MAX_CONNECT_ATTEMPTS})...")
                             event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connecting'))

                             # --- Create and Start Bot Instance ---
                             bot_instance = TwitchBot(
                                 token=token_data["access_token"],
                                 nick=token_data["user_login"],
                                 client_id=TWITCH_APP_CLIENT_ID,
                                 channels=channels_list
                             )
                             _STATE["instance"] = bot_instance # Store current instance

                             # Start the bot. This runs until disconnected or closed.
                             await bot_instance.start()

                             # If start() returns without error, it means connection closed normally/unexpectedly
                             logger.warning("Twitch bot's start() method returned. Connection likely closed.")
                             # Reset attempt count if we were connected and just got disconnected normally
                             if _STATE["connected"]: # If we were previously connected, maybe reset attempts?
                                  # Or just let the loop handle retries as configured below
                                  pass

                         except asyncio.CancelledError:
                             logger.info("Twitch connection attempt cancelled by task.")
                             _STATE["running"] = False # Ensure outer loop exits
                             break # Exit inner connection loop
                         except AuthenticationError as auth_err:
                              logger.critical(f"Twitch Authentication Error on connect (Attempt {attempt}): {auth_err}. Disabling service.")
                              event_bus.publish(PlatformStatusUpdate(platform='twitch', status='auth_error', message="Authentication Failed"))
                              _STATE["running"] = False # Stop retrying with bad credentials
                              await clear_tokens("twitch") # Clear bad tokens
                              break # Exit inner loop
                         except ValueError as val_err: # Catch init errors
                              logger.critical(f"Twitch Bot Initialization Error: {val_err}. Check config/tokens. Disabling.")
                              event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"Init Error: {val_err}"))
                              _STATE["running"] = False
                              break # Exit inner loop
                         except Exception as e:
                             logger.error(f"Error during Twitch connection/run (Attempt {attempt}): {e}", exc_info=logger.isEnabledFor(logging.DEBUG))
                             event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"Connect/Run Error: {type(e).__name__}"))
                         finally:
                             # --- Cleanup After Each Attempt ---
                             # Ensure bot instance is shut down properly, even if start() failed
                             if bot_instance:
                                 logger.debug(f"Cleaning up bot instance {id(bot_instance)} after connection attempt {attempt}...")
                                 await bot_instance.custom_shutdown()
                             # Clear state references ONLY IF this instance is the one in state
                             if _STATE.get("instance") == bot_instance:
                                  _STATE["instance"] = None
                                  _STATE["connected"] = False
                             bot_instance = None # Clear local var

                         # --- Retry Logic ---
                         if not _STATE.get("running"):
                             logger.info("Twitch running flag turned false, exiting connection loop.")
                             break # Exit inner loop if stop was requested

                         if attempt >= MAX_CONNECT_ATTEMPTS:
                             logger.error("Maximum Twitch connection attempts reached. Disabling until restart/settings change.")
                             event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message='Max connection attempts'))
                             _STATE["running"] = False # Stop trying
                             break # Exit inner loop

                         # Calculate wait time with exponential backoff
                         wait_time = min(5 * (2 ** (attempt - 1)), 60) # e.g., 5s, 10s, 20s, 40s, 60s
                         logger.info(f"Waiting {wait_time}s before Twitch retry (Attempt {attempt + 1})...")
                         try:
                             await asyncio.sleep(wait_time)
                         except asyncio.CancelledError:
                             logger.info("Twitch retry sleep cancelled.")
                             _STATE["running"] = False # Ensure outer loop exits
                             break # Exit inner loop

                     # --- After Inner Connection Loop ---
                     if not _STATE.get("running"):
                         logger.info("Twitch service runner stopping as requested.")
                         break # Exit outer loop

                     # If max attempts were reached and we weren't stopped, wait for settings update
                     if attempt >= MAX_CONNECT_ATTEMPTS:
                          logger.warning("Max attempts reached. Waiting for relevant settings update to retry.")
                          await wait_for_settings_update({
                              "twitch_access_token", "twitch_refresh_token", "TWITCH_CHANNELS"
                          })
                          # Continue outer loop to reload settings and retry connection

                 logger.info("Twitch service runner task finished.")


             async def wait_for_settings_update(relevant_keys: set):
                 """Waits for a SettingsUpdated event affecting relevant keys or task cancellation."""
                 # Create a future that will be resolved when the relevant setting is updated
                 update_future = asyncio.get_running_loop().create_future()
                 listener_task = None

                 async def settings_listener(event: SettingsUpdated):
                     # nonlocal update_future # Not needed with instance/class approach, but needed here
                     if not update_future.done():
                         if any(key in relevant_keys for key in event.keys_updated):
                             logger.info(f"Detected relevant settings update: {event.keys_updated}. Resuming service check.")
                             update_future.set_result(True)

                 # Subscribe the listener
                 event_bus.subscribe(SettingsUpdated, settings_listener)
                 logger.info(f"Waiting for settings update affecting: {relevant_keys}...")

                 try:
                     # Wait for either the settings update or the main task being cancelled
                     # Get the current task (the one running run_twitch_service)
                     current_task = asyncio.current_task()
                     if not current_task: raise RuntimeError("Could not get current task in wait_for_settings_update")

                     # Create a future representing the cancellation of the current task
                     # A simple way is to wait on the task itself, but that can lead to complex exception handling.
                     # A safer way is to check periodically or use a dedicated cancellation event if the bus supports it.
                     # For simplicity here, we'll rely on the main loop's cancellation check.
                     # We just wait on the update_future, potentially indefinitely if no update/cancellation occurs.
                     await update_future

                 except asyncio.CancelledError:
                     logger.info("Wait for settings update cancelled.")
                     raise # Re-raise to propagate cancellation
                 finally:
                     # CRITICAL: Always unsubscribe the listener to prevent leaks
                     event_bus.unsubscribe(SettingsUpdated, settings_listener)
                     logger.debug("Unsubscribed settings listener.")

             # Ensure stop function uses the global _run_task
             async def stop_twitch_service():
                 """Stops the Twitch service task gracefully."""
                 global _STATE, _run_task
                 logger.info("Stop requested for Twitch service.")
                 _STATE["running"] = False # Signal the run loop and bot tasks to stop

                 # Shutdown the bot instance first
                 bot_instance = _STATE.get("instance")
                 if bot_instance:
                     logger.info("Requesting shutdown of active TwitchBot instance...")
                     await bot_instance.custom_shutdown() # Call the graceful shutdown
                     if _STATE.get("instance") == bot_instance: # Check if it wasn't replaced meanwhile
                          _STATE["instance"] = None # Clear instance ref after shutdown

                 # Cancel the main service task using the global reference
                 current_task = _run_task
                 if current_task and not current_task.done():
                     if not current_task.cancelling():
                         logger.info("Cancelling main Twitch service task...")
                         current_task.cancel()
                         try:
                             # Wait for the task cancellation to complete
                             await asyncio.wait_for(current_task, timeout=5.0)
                             logger.info("Main Twitch service task cancellation confirmed.")
                         except asyncio.CancelledError:
                             logger.info("Main Twitch service task confirmed cancelled (exception caught).")
                         except asyncio.TimeoutError:
                              logger.warning("Timeout waiting for main Twitch service task to cancel.")
                         except Exception as e:
                             logger.error(f"Error waiting for cancelled Twitch service task: {e}", exc_info=True)
                     else:
                         logger.info("Main Twitch service task already cancelling.")
                 else:
                     logger.info("No active Twitch service task found to cancel.")

                 # Clear global task reference
                 _run_task = None
                 _STATE["task"] = None # Also clear state's task reference
                 _STATE["connected"] = False # Ensure connected state is false

                 # Unsubscribe settings handler *after* ensuring task is stopped
                 # Ensure the specific handler function is referenced
                 try:
                     event_bus.unsubscribe(SettingsUpdated, handle_settings_update_restart)
                 except ValueError:
                     logger.debug("Settings handler already unsubscribed or never subscribed.")

                 logger.info("Twitch service stopped.")
                 event_bus.publish(PlatformStatusUpdate(platform='twitch', status='stopped')) # Publish final stopped status

             async def handle_settings_update_restart(event: SettingsUpdated):
                 """Restarts the Twitch service if relevant settings changed."""
                 # Define keys that necessitate a restart
                 relevant_keys = {
                     "twitch_access_token", "twitch_refresh_token", # Auth tokens
                     "twitch_user_login", "twitch_user_id",         # User identity
                     "TWITCH_CHANNELS"                              # Channels to join
                     # App Client ID/Secret changes require full app restart, not handled here.
                 }
                 # Check if any updated key is relevant
                 if any(key in relevant_keys for key in event.keys_updated):
                     logger.info(f"Relevant Twitch settings updated ({event.keys_updated}). Triggering service restart...")
                     # Publish a control event for main.py's handler to manage the restart
                     event_bus.publish(ServiceControl(service_name="twitch", command="restart"))

             def start_twitch_service_task() -> asyncio.Task | None:
                 """Creates and starts the background task for the Twitch service."""
                 global _STATE, _run_task
                 # Prevent starting if already running
                 if _run_task and not _run_task.done():
                     logger.warning("Twitch service task is already running or starting.")
                     return _run_task

                 logger.info("Creating and starting background task for Twitch service.")
                 # Subscribe to settings updates *before* starting the task
                 event_bus.subscribe(SettingsUpdated, handle_settings_update_restart)
                 # Create the task
                 _run_task = asyncio.create_task(run_twitch_service(), name="TwitchServiceRunner")
                 _STATE["task"] = _run_task # Store task reference in state as well

                 return _run_task

             # --- File: app/services/twitch_service.py --- END ---
             """,
                     "app/services/youtube_service.py": r"""# Generated by install_fosbot.py
             # --- File: app/services/youtube_service.py --- START ---
             import logging
             import asyncio
             import time
             from google.oauth2.credentials import Credentials
             from google.auth.transport.requests import Request as GoogleAuthRequest # Standard transport
             from google_auth_oauthlib.flow import InstalledAppFlow # If needed for manual auth, but web flow preferred
             from googleapiclient.discovery import build, Resource # For type hinting
             from googleapiclient.errors import HttpError
             import httpx # Use httpx for refresh
             from datetime import datetime, timezone, timedelta # Use timezone-aware datetimes
             from typing import Dict, List, Optional, Any, Coroutine

             # Core imports
             from app.core.event_bus import event_bus
             from app.events import (
                 PlatformStatusUpdate, SettingsUpdated, ServiceControl, BotResponseToSend,
                 InternalChatMessage, ChatMessageReceived, BotResponse, LogMessage
             )
             from app.core.json_store import load_tokens, save_tokens, get_setting
             # Import App Owner Credentials from config
             from app.core.config import logger, YOUTUBE_APP_CLIENT_ID, YOUTUBE_APP_CLIENT_SECRET

             # --- Constants ---
             YOUTUBE_TOKEN_URL = "https://oauth2.googleapis.com/token"
             YOUTUBE_API_SERVICE_NAME = "youtube"
             YOUTUBE_API_VERSION = "v3"
             # Scopes required for reading chat and potentially posting
             YOUTUBE_SCOPES = [
                 "https://www.googleapis.com/auth/youtube.readonly", # Needed to list broadcasts/chats
                 "https://www.googleapis.com/auth/youtube.force-ssl", # Often needed for chat operations
                 "https://www.googleapis.com/auth/youtube" # Needed to insert chat messages
             ]

             # --- Module State ---
             _STATE = {
                 "task": None,
                 "running": False,
                 "connected": False, # Represents connection to a specific live chat
                 "live_chat_id": None,
                 "youtube_client": None, # Stores the authorized googleapiclient resource
                 "user_login": None,
                 "user_id": None,
                 "last_poll_time": 0.0,
                 "next_page_token": None
             }
             _run_task: asyncio.Task | None = None

             # --- Helper Functions ---
             async def refresh_youtube_token(refresh_token: str) -> Optional[Dict[str, Any]]:
                 """Refreshes the YouTube OAuth token using httpx."""
                 if not refresh_token:
                     logger.error("Cannot refresh YouTube token: No refresh token provided.")
                     return None
                 if not YOUTUBE_APP_CLIENT_ID or not YOUTUBE_APP_CLIENT_SECRET:
                     logger.error("Cannot refresh YouTube token: App credentials missing.")
                     return None

                 logger.info("Attempting to refresh YouTube OAuth token...")
                 token_params = {
                     "grant_type": "refresh_token",
                     "refresh_token": refresh_token,
                     "client_id": YOUTUBE_APP_CLIENT_ID,
                     "client_secret": YOUTUBE_APP_CLIENT_SECRET
                 }
                 async with httpx.AsyncClient(timeout=15.0) as client:
                     try:
                         response = await client.post(YOUTUBE_TOKEN_URL, data=token_params)
                         response.raise_for_status()
                         token_data = response.json()
                         logger.info("YouTube token refreshed successfully.")
                         # Prepare data for save_tokens
                         return {
                             "access_token": token_data.get("access_token"),
                             "refresh_token": refresh_token, # Refresh token usually doesn't change unless revoked
                             "expires_in": token_data.get("expires_in"),
                             "scope": token_data.get("scope", "").split(),
                         }
                     except httpx.TimeoutException:
                          logger.error("Timeout refreshing YouTube token.")
                          return None
                     except httpx.HTTPStatusError as e:
                         logger.error(f"HTTP error refreshing YouTube token: {e.response.status_code} - {e.response.text}")
                         if e.response.status_code in [400, 401]:
                              logger.error("Refresh token may be invalid or revoked.")
                              # Consider clearing the token?
                         return None
                     except Exception as e:
                         logger.exception(f"Unexpected error refreshing YouTube token: {e}")
                         return None

             async def build_youtube_client_async(credentials: Credentials) -> Optional[Resource]:
                  """Builds the YouTube API client resource asynchronously using run_in_executor."""
                  loop = asyncio.get_running_loop()
                  try:
                       # googleapiclient.discovery.build is synchronous/blocking
                       youtube = await loop.run_in_executor(
                            None, # Use default thread pool executor
                            lambda: build(YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION, credentials=credentials)
                       )
                       logger.info("YouTube API client built successfully.")
                       return youtube
                  except Exception as e:
                       logger.error(f"Failed to build YouTube API client: {e}", exc_info=True)
                       return None

             async def get_active_live_chat_id(youtube: Resource) -> Optional[str]:
                 """Finds the liveChatId for the channel's active broadcast asynchronously."""
                 if not youtube:
                     logger.error("Cannot get live chat ID: YouTube client is not available.")
                     return None
                 try:
                     logger.debug("Fetching active live broadcasts...")
                     loop = asyncio.get_running_loop()
                     request = youtube.liveBroadcasts().list(
                         part="snippet",
                         broadcastStatus="active",
                         broadcastType="all",
                         mine=True,
                         maxResults=1
                     )
                     response = await loop.run_in_executor(None, request.execute)

                     if not response or not response.get("items"):
                         logger.info("No active YouTube live broadcasts found for this account.")
                         return None

                     live_broadcast = response["items"][0]
                     snippet = live_broadcast.get("snippet", {})
                     live_chat_id = snippet.get("liveChatId")
                     title = snippet.get("title", "Unknown Broadcast")

                     if live_chat_id:
                         logger.info(f"Found active liveChatId: {live_chat_id} for broadcast '{title}'")
                         return live_chat_id
                     else:
                         # This can happen if the stream is active but chat is disabled or not yet fully initialized
                         logger.warning(f"Active broadcast found ('{title}'), but it has no liveChatId yet.")
                         return None

                 except HttpError as e:
                     logger.error(f"YouTube API error fetching broadcasts/chat ID: {e.resp.status} - {e.content}")
                     if e.resp.status == 403:
                          logger.error("Permission denied fetching YouTube broadcasts. Check API scopes/enablement.")
                     return None
                 except Exception as e:
                     logger.exception(f"Unexpected error fetching YouTube live chat ID: {e}")
                     return None

             async def poll_youtube_chat(youtube: Resource, live_chat_id: str):
                 """Polls the specified YouTube live chat for new messages."""
                 global _STATE # Need to access/modify state like next_page_token
                 logger.info(f"Starting polling for YouTube liveChatId: {live_chat_id}")
                 error_count = 0
                 MAX_ERRORS = 5
                 ERROR_BACKOFF_BASE = 5 # Seconds

                 while _STATE.get("running") and _STATE.get("live_chat_id") == live_chat_id:
                     try:
                         loop = asyncio.get_running_loop()
                         request = youtube.liveChatMessages().list(
                             liveChatId=live_chat_id,
                             part="id,snippet,authorDetails",
                             maxResults=200,
                             pageToken=_STATE.get("next_page_token") # Use state's token
                         )
                         # response = await loop.run_in_executor(None, request.execute)
                         response = request.execute() # Blocking call

                         if response:
                              items = response.get("items", [])
                              if items:
                                   logger.debug(f"Received {len(items)} YouTube chat messages.")
                                   for item in items:
                                        snippet = item.get("snippet", {})
                                        author = item.get("authorDetails", {})
                                        msg_text = snippet.get("displayMessage")
                                        published_at_str = snippet.get("publishedAt")

                                        if msg_text:
                                             timestamp_iso = published_at_str or datetime.now(timezone.utc).isoformat()
                                             internal_msg = InternalChatMessage(
                                                  platform="youtube",
                                                  channel=author.get("channelId", live_chat_id),
                                                  user=author.get("displayName", "Unknown User"),
                                                  text=msg_text,
                                                  timestamp=timestamp_iso,
                                                  user_id=author.get("channelId"),
                                                  display_name=author.get("displayName"),
                                                  message_id=item.get("id"),
                                                  raw_data={'authorDetails': author, 'snippet': snippet}
                                             )
                                             event_bus.publish(ChatMessageReceived(message=internal_msg))
                                             logger.debug(f"YouTube <{live_chat_id}> {author.get('displayName')}: {msg_text}")

                              _STATE["next_page_token"] = response.get("nextPageToken")
                              polling_interval_ms = response.get("pollingIntervalMillis", 5000)
                              wait_seconds = max(polling_interval_ms / 1000.0, 2.0)

                              logger.debug(f"YouTube poll successful. Waiting {wait_seconds}s. Next page: {'Yes' if _STATE['next_page_token'] else 'No'}")
                              error_count = 0 # Reset error count
                              await asyncio.sleep(wait_seconds)
                         else:
                              logger.warning("YouTube chat poll returned empty/invalid response.")
                              await asyncio.sleep(10)

                     except HttpError as e:
                         error_count += 1
                         logger.error(f"YouTube API error during chat polling (Attempt {error_count}/{MAX_ERRORS}): {e.resp.status} - {e.content}")
                         event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message=f"Chat poll failed: {e.resp.status}"))

                         if e.resp.status in [403, 404]: # Forbidden or Not Found often means chat ended
                             logger.warning(f"YouTube chat polling failed ({e.resp.status}). Chat likely ended or permissions lost.")
                             _STATE["connected"] = False
                             _STATE["live_chat_id"] = None
                             event_bus.publish(PlatformStatusUpdate(platform='youtube', status='disconnected', message=f"Chat ended/unavailable ({e.resp.status})"))
                             break # Exit polling loop for this chat_id

                         if error_count >= MAX_ERRORS:
                              logger.error("Max YouTube polling errors reached. Stopping polling.")
                              _STATE["connected"] = False
                              event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message="Max polling errors"))
                              break # Exit polling loop

                         wait_time = ERROR_BACKOFF_BASE * (2 ** (error_count - 1)) # Exponential backoff
                         logger.info(f"Waiting {wait_time}s before retrying YouTube poll...")
                         await asyncio.sleep(wait_time)

                     except asyncio.CancelledError:
                          logger.info("YouTube chat polling task cancelled.")
                          break # Exit loop
                     except Exception as e:
                         error_count += 1
                         logger.exception(f"Unexpected error polling YouTube chat (Attempt {error_count}/{MAX_ERRORS}): {e}")
                         event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message=f"Unexpected Poll Error: {type(e).__name__}"))
                         if error_count >= MAX_ERRORS:
                              logger.error("Max YouTube polling errors reached (unexpected). Stopping polling.")
                              break
                         wait_time = ERROR_BACKOFF_BASE * (2 ** (error_count - 1))
                         await asyncio.sleep(wait_time)

                 logger.info("YouTube chat polling loop finished.")
                 _STATE["connected"] = False # Ensure state reflects polling stopped

             async def handle_youtube_response(event: BotResponseToSend):
                 """Handles sending messages to YouTube live chat."""
                 if event.response.target_platform != "youtube":
                     return

                 youtube_client = _STATE.get("youtube_client")
                 live_chat_id = _STATE.get("live_chat_id")
                 if not youtube_client or not live_chat_id or not _STATE.get("connected"):
                     logger.error(f"Cannot send YouTube response: Client/ChatID not available or not connected. State: {_STATE}")
                     return

                 logger.info(f"Attempting to send YouTube message to {live_chat_id}: {event.response.text[:50]}...")
                 try:
                     loop = asyncio.get_running_loop()
                     request = youtube_client.liveChatMessages().insert(
                         part="snippet",
                         body={
                             "snippet": {
                                 "liveChatId": live_chat_id,
                                 "type": "textMessageEvent",
                                 "textMessageDetails": {"messageText": event.response.text}
                             }
                         }
                     )
                     # await loop.run_in_executor(None, request.execute)
                     request.execute() # Blocking call
                     logger.info(f"Successfully sent YouTube message to {live_chat_id}.")

                 except HttpError as e:
                     logger.error(f"Error sending YouTube live chat message: {e.resp.status} - {e.content}")
                     event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message=f"Send failed: {e.resp.status}"))
                     if e.resp.status == 403: # Forbidden might mean chat ended or bot banned/timed out
                          logger.warning("YouTube send failed (403) - Chat possibly ended or bot lacks permission.")
                          # Consider stopping polling if sends consistently fail with 403
                          # stop_youtube_service() # Maybe too aggressive?
                 except Exception as e:
                     logger.exception(f"Unexpected error sending YouTube message: {e}")
                     event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message=f"Send Exception: {type(e).__name__}"))


             # --- Main Service Runner ---
             async def run_youtube_service():
                 """Main loop for the YouTube service."""
                 global _STATE, _run_task
                 logger.info("YouTube service runner task started.")

                 while True: # Outer loop for re-checking auth/broadcast state
                     current_task_obj = asyncio.current_task()
                     if current_task_obj and current_task_obj.cancelled():
                         logger.info("YouTube run loop detected cancellation request.")
                         break

                     # --- Load Auth Tokens ---
                     logger.debug("Loading YouTube tokens...")
                     token_data = await load_tokens("youtube")

                     if not token_data or not token_data.get("access_token") or not token_data.get("user_id"):
                         logger.warning("YouTube service disabled: Not authenticated. Waiting for login.")
                         event_bus.publish(PlatformStatusUpdate(platform='youtube', status='disabled', message='Not logged in'))
                         await wait_for_settings_update({"youtube_access_token"})
                         continue # Re-check config

                     _STATE["user_id"] = token_data["user_id"]
                     _STATE["user_login"] = token_data.get("user_login", "Unknown YT User")

                     # --- Token Refresh Check ---
                     expires_at = token_data.get("expires_at")
                     if expires_at and expires_at < time.time() + 300:
                         logger.info("YouTube token expired or expiring soon. Attempting refresh...")
                         refreshed_data = await refresh_youtube_token(token_data.get("refresh_token"))
                         if refreshed_data:
                              # Merge user info back into refreshed data before saving
                              refreshed_data['user_id'] = _STATE["user_id"]
                              refreshed_data['user_login'] = _STATE["user_login"]
                              if await save_tokens("youtube", refreshed_data):
                                   token_data = await load_tokens("youtube") # Reload
                                   logger.info("YouTube token refreshed and saved successfully.")
                              else:
                                   logger.error("Failed to save refreshed YouTube token. Disabling service.")
                                   event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message='Token refresh save failed'))
                                   _STATE["running"] = False; break # Stop trying
                         else:
                             logger.error("YouTube token refresh failed. Requires manual re-authentication.")
                             event_bus.publish(PlatformStatusUpdate(platform='youtube', status='auth_error', message='Token refresh failed'))
                             await clear_tokens("youtube") # Clear bad tokens
                             await wait_for_settings_update({"youtube_access_token"}) # Wait for new login
                             continue # Restart outer loop

                     # --- Build API Client ---
                     credentials = Credentials(
                         token=token_data["access_token"],
                         refresh_token=token_data.get("refresh_token"),
                         token_uri=YOUTUBE_TOKEN_URL,
                         client_id=YOUTUBE_APP_CLIENT_ID,
                         client_secret=YOUTUBE_APP_CLIENT_SECRET,
                         scopes=token_data.get("scopes", YOUTUBE_SCOPES) # Use stored scopes if available
                     )
                     # Ensure credentials are valid/refreshed before building client (optional but good practice)
                     try:
                          # credentials.refresh(GoogleAuthRequest()) # Synchronous refresh if needed immediately
                          pass # Assume token is valid or refresh handled above/by google client lib implicitly
                     except Exception as cred_err:
                          logger.error(f"Error validating/refreshing credentials before build: {cred_err}")
                          # Handle potential token invalidation
                          event_bus.publish(PlatformStatusUpdate(platform='youtube', status='auth_error', message='Credential validation failed'))
                          await clear_tokens("youtube")
                          await wait_for_settings_update({"youtube_access_token"})
                          continue

                     youtube_client = await build_youtube_client_async(credentials)
                     if not youtube_client:
                          logger.error("Failed to build YouTube client. Disabling service temporarily.")
                          event_bus.publish(PlatformStatusUpdate(platform='youtube', status='error', message='Client build failed'))
                          await asyncio.sleep(60); continue # Wait and retry outer loop

                     _STATE["youtube_client"] = youtube_client
                     _STATE["running"] = True # Set running flag for this attempt cycle
                     _STATE["live_chat_id"] = None # Reset live chat ID
                     _STATE["connected"] = False
                     _STATE["next_page_token"] = None # Reset page token

                     # --- Find Active Chat and Poll ---
                     while _STATE.get("running"): # Inner loop: Find chat -> Poll -> Repeat if chat ends
                         if asyncio.current_task().cancelled(): break

                         live_chat_id = await get_active_live_chat_id(youtube_client)
                         if live_chat_id:
                              _STATE["live_chat_id"] = live_chat_id
                              _STATE["connected"] = True
                              event_bus.publish(PlatformStatusUpdate(platform='youtube', status='connected', message=f"Polling chat {live_chat_id}"))
                              # Start polling - this will run until the chat ends, an error occurs, or stop is requested
                              await poll_youtube_chat(youtube_client, live_chat_id)
                              # If poll_youtube_chat returns, it means chat ended or error occurred
                              logger.info("Polling finished or stopped. Will check for new active chat.")
                              _STATE["connected"] = False # Mark as disconnected from *this* chat
                              _STATE["live_chat_id"] = None
                              _STATE["next_page_token"] = None # Reset page token
                              # Publish disconnected status after polling stops for a specific chat
                              event_bus.publish(PlatformStatusUpdate(platform='youtube', status='disconnected', message='Polling stopped/ended'))
                              # Optional: Add a small delay before checking for a new stream
                              await asyncio.sleep(10)
                         else:
                              # No active chat found
                              logger.info("No active YouTube chat found. Waiting before checking again.")
                              event_bus.publish(PlatformStatusUpdate(platform='youtube', status='waiting', message='No active stream found'))
                              # Wait for a while before checking for a new live stream
                              try: await asyncio.sleep(60)
                              except asyncio.CancelledError: break # Exit if cancelled during wait

                     # --- Cleanup after inner loop (if stop was requested) ---
                     if not _STATE.get("running"):
                         logger.info("YouTube service runner stopping as requested.")
                         break # Exit outer loop

                 # --- Final Cleanup ---
                 logger.info("YouTube service runner task finished.")
                 _STATE["running"] = False
                 _STATE["connected"] = False
                 _STATE["live_chat_id"] = None
                 _STATE["youtube_client"] = None


             # --- Wait Function ---
             async def wait_for_settings_update(relevant_keys: set):
                 """Waits for a SettingsUpdated event affecting relevant keys or task cancellation."""
                 # (Same implementation as in twitch_service)
                 update_future = asyncio.get_running_loop().create_future()
                 listener_task = None

                 async def settings_listener(event: SettingsUpdated):
                     if not update_future.done():
                         if any(key in relevant_keys for key in event.keys_updated):
                             logger.info(f"Detected relevant YouTube settings update: {event.keys_updated}. Resuming service check.")
                             update_future.set_result(True)