# Consolidated Files from: /Users/jgleason/Development/FoSBot_v0.1
# Generated by script: combine_FoSBot_Files.sh
# Timestamp: 2025-04-17 14:10:02 EDT

========================= File: requirements.txt =========================

fastapi>=0.110.0
uvicorn[standard]>=0.29.0
python-dotenv>=1.0.0
websockets>=11.0.0
aiofiles>=23.1.0
pydantic>=2.0.0
typing-extensions>=4.8.0
# Base uvicorn[standard] deps
click>=7.0
h11>=0.8
httptools>=0.5.0
pyyaml>=5.1
uvloop>=0.17.0
watchfiles>=0.13
# Other minimal needed deps
nest-asyncio>=1.5.0 # Often helpful with frameworks/async


========================= File: setup_fosbot.sh =========================

#!/bin/bash

# --- Configuration ---
PROJECT_DIR_NAME="FoSBot"
PYTHON_VERSION_TARGET="3.13"
PYTHON_VERSION_PACKAGE="python@${PYTHON_VERSION_TARGET}"
PYTHON_EXECUTABLE_NAME="python${PYTHON_VERSION_TARGET}"
DATA_DIR="data" # Directory to store JSON files
# --- End Configuration ---

# --- Safety & Setup ---
set -u; set -o pipefail
# set -e # Keep disabled for better error reporting during setup

command_exists() { command -v "$1" >/dev/null 2>&1; }
fail() { echo "" >&2; echo "ERROR: $1" >&2; exit 1; }
check_success() { CODE=$?; MSG="$1"; if [ $CODE -ne 0 ]; then fail "${MSG} (Exit code: ${CODE})"; fi; }

echo "--- FoSBot Phase 1 Setup (Webapp Config / JSON Storage) ---"
echo "---                Project: ${PROJECT_DIR_NAME}               ---"
echo ""
sleep 1

# --- Verify running location ---
CURRENT_DIR_NAME=$(basename "$PWD")
if [ "$CURRENT_DIR_NAME" != "$PROJECT_DIR_NAME" ]; then fail "Script must be run from the '$PROJECT_DIR_NAME' directory."; fi
echo "Running in: $(pwd)"

# --- [1/9] Check/Install Xcode Command Line Tools ---
echo ""; echo "[1/9] Checking/Installing Xcode Command Line Tools..."
if ! xcode-select -p > /dev/null 2>&1; then
    echo "    Initiating installation..."; echo "    >>> Please click 'Install' in the macOS dialog. <<<"; xcode-select --install
    check_success "Xcode Tools installation failed/cancelled."; echo "    Waiting for completion..."; until xcode-select -p >/dev/null 2>&1; do echo "    ..."; sleep 10; done; echo "    Xcode Tools installed."
else echo "    Xcode Tools already installed."; fi

# --- [2/9] Check/Install Homebrew ---
echo ""; echo "[2/9] Checking/Installing Homebrew..."
if ! command_exists brew; then echo "    Homebrew not found. Installing..."; /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; check_success "Homebrew install failed."; fi
if [[ -x "/opt/homebrew/bin/brew" ]]; then eval "$(/opt/homebrew/bin/brew shellenv)"; fi; if [[ -x "/usr/local/bin/brew" ]]; then eval "$(/usr/local/bin/brew shellenv)"; fi
if ! command_exists brew; then fail "Homebrew not found after install attempt."; fi
echo "    Updating Homebrew..."; brew update > /dev/null; check_success "Homebrew update failed."; echo "    Homebrew ready."

# --- [3/9] Install System Dependencies (Python, Git ONLY) ---
echo ""; echo "[3/9] Checking/Installing Python & Git via Homebrew..."
echo "    Installing/Upgrading ${PYTHON_VERSION_PACKAGE}..."; brew install ${PYTHON_VERSION_PACKAGE}; check_success "Failed to install ${PYTHON_VERSION_PACKAGE}."
echo "    Installing/Upgrading git..."; brew install git; check_success "Failed to install git."; echo "    System dependencies installed."
# Removed PostgreSQL steps

# --- [4/9] Create Project Structure ---
echo ""; echo "[4/9] Creating project structure..."
mkdir -p app/core app/services app/apis static plugins tests whatnot_extension/icons "${DATA_DIR}"
touch app/__init__.py app/core/__init__.py app/services/__init__.py app/apis/__init__.py
# No models needed yet
touch .gitignore requirements.txt README.md
touch whatnot_extension/icons/icon16.png whatnot_extension/icons/icon48.png whatnot_extension/icons/icon128.png
echo "{}" > "${DATA_DIR}/settings.json"; check_success "Failed creating settings.json"
echo "{}" > "${DATA_DIR}/checkins.json"; check_success "Failed creating checkins.json"
echo "{}" > "${DATA_DIR}/counters.json"; check_success "Failed creating counters.json"
echo "Project structure created."

# --- [5/9] Setup Python Virtual Environment ---
echo ""; echo "[5/9] Setting up Python Virtual Environment ('venv')..."
echo "    Removing old venv (if exists)..."; rm -rf venv || echo "    (No old venv/failed removal)"
echo "    Finding Python ${PYTHON_VERSION_TARGET}..."; PYTHON_PREFIX=$(brew --prefix ${PYTHON_VERSION_PACKAGE}); check_success "Could not get prefix."; PYTHON_EXECUTABLE="${PYTHON_PREFIX}/bin/${PYTHON_EXECUTABLE_NAME}"
if [ ! -x "$PYTHON_EXECUTABLE" ]; then fail "Python executable not found: ${PYTHON_EXECUTABLE}"; fi; echo "    Using: ${PYTHON_EXECUTABLE}"
echo "    Creating new venv..."; "$PYTHON_EXECUTABLE" -m venv venv; check_success "Failed to create venv."
echo "    Verifying venv structure..."; VENV_SITE_PACKAGES_PATH="venv/lib/python${PYTHON_VERSION_TARGET}/site-packages"; if [ ! -d "$VENV_SITE_PACKAGES_PATH" ]; then fail "'site-packages' MISSING."; fi; echo "    Venv created successfully."

# --- [6/9] Install Base Python Dependencies ---
echo ""; echo "[6/9] Installing base Python dependencies..."
# Define minimal requirements for server, websockets, json store, config
cat << EOF > requirements.txt
fastapi>=0.110.0
uvicorn[standard]>=0.29.0
python-dotenv>=1.0.0
websockets>=11.0.0
aiofiles>=23.1.0
pydantic>=2.0.0
typing-extensions>=4.8.0
# Base uvicorn[standard] deps
click>=7.0
h11>=0.8
httptools>=0.5.0
pyyaml>=5.1
uvloop>=0.17.0
watchfiles>=0.13
# Other minimal needed deps
nest-asyncio>=1.5.0 # Often helpful with frameworks/async
EOF
check_success "Failed writing requirements.txt"

echo "    Activating venv..."; source venv/bin/activate; check_success "Failed activating venv."; echo "    Upgrading pip..."; ./venv/bin/pip install --upgrade pip --quiet; check_success "Pip upgrade failed."
echo "    Installing base packages..."; ./venv/bin/pip install -r requirements.txt; check_success "'pip install -r requirements.txt' failed."
echo "    Base dependencies installed."

# --- [7/9] Create Basic .env File ---
echo ""; echo "[7/9] Creating basic .env file..."
DEFAULT_WS_HOST="localhost"; DEFAULT_WS_PORT="8000"; DEFAULT_LOG_LEVEL="DEBUG"; DATA_DIR_CONFIG="${DATA_DIR}"
(
echo "# --- Application Settings ---"
echo "COMMAND_PREFIX=!"
echo "WS_HOST=${DEFAULT_WS_HOST}"
echo "WS_PORT=${DEFAULT_WS_PORT}"
echo "LOG_LEVEL=${DEFAULT_LOG_LEVEL}" # Default to DEBUG
echo "DATA_DIR=${DATA_DIR_CONFIG}"
echo ""
echo "# API Keys and Secrets are managed via the application UI (Settings Tab)"
echo "# and stored in '${DATA_DIR_CONFIG}/settings.json'"
) > .env
check_success "Failed writing .env file."
echo "    Basic .env file created."

# --- [8/9] Create Python Application Files ---
echo ""; echo "[8/9] Creating Python application source files..."

# --- app/core/config.py ---
echo "    Creating app/core/config.py..."
cat << 'EOF' > app/core/config.py
import os, logging; from dotenv import load_dotenv; from pathlib import Path
project_root = Path(__file__).parent.parent.parent; env_path = project_root / '.env'
loaded_env = load_dotenv(dotenv_path=env_path, verbose=True)
if loaded_env: print(f"Loaded .env from: {env_path}")
else: print(f"INFO: .env not found at {env_path}.")
COMMAND_PREFIX = os.getenv("COMMAND_PREFIX", "!"); WS_HOST = os.getenv("WS_HOST", "localhost"); WS_PORT = int(os.getenv("WS_PORT", "8000")); LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper(); DATA_DIR = Path(os.getenv("DATA_DIR", project_root / "data"))
log_level_int = getattr(logging, LOG_LEVEL, logging.INFO); logging.basicConfig(level=log_level_int, format='%(asctime)s - %(name)s [%(levelname)s] - %(message)s', datefmt='%Y-%m-%d %H:%M:%S'); logging.getLogger("websockets").setLevel(logging.WARNING); logging.getLogger("uvicorn").setLevel(logging.INFO)
logger = logging.getLogger(__name__); logger.setLevel(log_level_int); logger.info(f"Config Loaded: WS={WS_HOST}:{WS_PORT}, Log={LOG_LEVEL}, Data='{DATA_DIR}'")
try: DATA_DIR.mkdir(parents=True, exist_ok=True); logger.info(f"Data dir verified: {DATA_DIR}")
except OSError as e: logger.error(f"CRITICAL: Cannot create data dir '{DATA_DIR}': {e}")
EOF
check_success "Failed writing app/core/config.py"

# --- app/core/json_store.py --- (With improvements)
echo "    Creating app/core/json_store.py..."
cat << 'EOF' > app/core/json_store.py
import json; import logging; import aiofiles; import asyncio; from pathlib import Path; from typing import Dict, Any, Optional, Union
from app.core.config import DATA_DIR
logger = logging.getLogger(__name__); _file_locks: Dict[Path, asyncio.Lock] = {}

async def _get_lock(filepath: Path) -> asyncio.Lock:
    """Gets or creates an asyncio Lock per file to prevent write races."""
    loop = asyncio.get_running_loop()
    if filepath not in _file_locks: _file_locks[filepath] = asyncio.Lock(loop=loop)
    return _file_locks[filepath]

async def load_json_data(filename: str, default: Any = None) -> Optional[Any]:
    filepath = DATA_DIR / f"{filename}.json"; lock = await _get_lock(filepath); logger.debug(f"Acquiring lock for read: {filepath}")
    async with lock: logger.debug(f"Lock acquired for read: {filepath}");
        try:
            if not filepath.is_file(): logger.warning(f"JSON file not found: {filepath}. Returning default."); return default
            async with aiofiles.open(filepath, mode='r', encoding='utf-8') as f: content = await f.read()
            if not content: logger.warning(f"JSON file empty: {filepath}. Returning default."); return default
            data = json.loads(content); logger.info(f"Loaded data from {filepath}"); return data
        except json.JSONDecodeError: logger.error(f"JSON decode error in {filepath}.", exc_info=True); return default
        except Exception as e: logger.error(f"Error loading {filepath}: {e}", exc_info=True); return default
        finally: logger.debug(f"Released lock for read: {filepath}")

async def save_json_data(filename: str, data: Any) -> bool:
    filepath = DATA_DIR / f"{filename}.json"; lock = await _get_lock(filepath); temp_filepath = filepath.with_suffix(filepath.suffix + f'.{asyncio.current_task().get_name()}.tmp'); logger.debug(f"Acquiring lock for write: {filepath}")
    async with lock: logger.debug(f"Lock acquired for write: {filepath}");
        try:
            async with aiofiles.open(temp_filepath, mode='w', encoding='utf-8') as f: await f.write(json.dumps(data, indent=4, ensure_ascii=False))
            temp_filepath.rename(filepath); logger.info(f"Saved data to {filepath}"); return True
        except Exception as e: logger.error(f"Error saving {filepath}: {e}", exc_info=True);
             if temp_filepath.exists(): try: temp_filepath.unlink() except OSError: pass; return False
        finally: logger.debug(f"Released lock for write: {filepath}")

SETTINGS_FILE = "settings"; CHECKINS_FILE = "checkins"; COUNTERS_FILE = "counters"
async def load_settings() -> Dict[str, Any]: return await load_json_data(SETTINGS_FILE, default={}) or {}
async def save_settings(settings_data: Dict[str, Any]) -> bool: logger.warning("Saving settings (potentially sensitive) to plain JSON."); return await save_json_data(SETTINGS_FILE, settings_data)
async def get_setting(key: str, default: Any = None) -> Any: settings = await load_settings(); return settings.get(key, default)
async def load_checkins() -> Dict[str, Any]: return await load_json_data(CHECKINS_FILE, default={}) or {}
async def save_checkins(data: Dict[str, Any]) -> bool: return await save_json_data(CHECKINS_FILE, data)
async def load_counters() -> Dict[str, int]: return await load_json_data(COUNTERS_FILE, default={}) or {}
async def save_counters(data: Dict[str, int]) -> bool: return await save_json_data(COUNTERS_FILE, data)
EOF
check_success "Failed writing app/core/json_store.py"

# --- app/events.py ---
echo "    Creating app/events.py..."
cat << 'EOF' > app/events.py
from dataclasses import dataclass, field; from typing import Optional, Dict, Any, List; import datetime # List added
@dataclass
class InternalChatMessage: platform: str; user: str; text: str; channel: Optional[str]=None; user_id: Optional[str]=None; display_name: Optional[str]=None; timestamp: datetime.datetime=field(default_factory=datetime.datetime.utcnow); message_id: Optional[str]=None; is_command: bool=False; raw_data: Dict[str,Any]=field(default_factory=dict)
@dataclass
class BotResponse: target_platform: str; text: str; target_channel: Optional[str]=None; reply_to_user: Optional[str]=None; reply_to_message_id: Optional[str]=None
class Event: pass
@dataclass
class ChatMessageReceived(Event): message: InternalChatMessage
@dataclass
class CommandDetected(Event): command: str; args: list[str]; source_message: InternalChatMessage
@dataclass
class BotResponseToSend(Event): response: BotResponse
@dataclass
class StreamerInputReceived(Event): text: str
@dataclass
class BroadcastStreamerMessage(Event): text: str
@dataclass
class PlatformStatusUpdate(Event): platform: str; status: str; message: Optional[str]=None
@dataclass
class LogMessage(Event): level: str; message: str; module: Optional[str]=None
@dataclass
class SettingsUpdated(Event): keys_updated: List[str] # List of keys changed
@dataclass
class ServiceControl(Event): service_name: str; command: str # 'start', 'stop', 'restart'
@dataclass
class GameEvent(Event): pass # Base for game events
EOF
check_success "Failed writing app/events.py"

# --- app/core/event_bus.py --- (No changes needed)
echo "    Creating app/core/event_bus.py..."
cat << 'EOF' > app/core/event_bus.py
import asyncio, logging, sys; from collections import defaultdict; from typing import Type, Callable, Dict, List, TypeVar, Coroutine, Any; from app.events import Event
logger = logging.getLogger(__name__); T = TypeVar('T', bound=Event)
class AsyncEventBus:
    def __init__(self): self._listeners: Dict[Type[Event], List[Callable[[T], Coroutine[Any, Any, None]]]] = defaultdict(list); self._queue=asyncio.Queue(maxsize=500); self._worker_task=None; self._running=False # Added queue size
    def subscribe(self, event_type: Type[T], handler: Callable[[T], Coroutine[Any, Any, None]]):
        if not asyncio.iscoroutinefunction(handler): raise TypeError(f"Handler {handler.__name__} must be async"); self._listeners[event_type].append(handler); logger.debug(f"Handler '{getattr(handler, '__name__', repr(handler))}' subscribed to {event_type.__name__}")
    def publish(self, event: Event):
        if not self._running: logger.warning(f"Event bus not running, discarding: {type(event).__name__}"); return
        try: self._queue.put_nowait(event); logger.debug(f"Event {type(event).__name__} published.")
        except asyncio.QueueFull: logger.error(f"Event bus queue FULL! Discarding event: {type(event).__name__}. Consider increasing queue size or faster processing.")
    async def _process_events(self):
        logger.info("Event bus processor started."); while self._running:
            try: event = await self._queue.get(); event_type = type(event); logger.debug(f"Processing {event_type.__name__}")
                handlers_to_call = [];
                for reg_type, handlers in self._listeners.items():
                    if isinstance(event, reg_type): handlers_to_call.extend(handlers)
                if not handlers_to_call: self._queue.task_done(); continue
                tasks = [asyncio.create_task(handler(event), name=f"event_handler_{getattr(handler, '__name__', 'unknown')}") for handler in handlers_to_call] # Name tasks
                results = await asyncio.gather(*tasks, return_exceptions=True)
                for i, result in enumerate(results):
                    if isinstance(result, Exception): hn = getattr(handlers_to_call[i], '__name__', repr(handlers_to_call[i])); logger.error(f"Exception in handler '{hn}' for {event_type.__name__}: {result}", exc_info=result if logger.isEnabledFor(logging.DEBUG) else False)
                self._queue.task_done()
            except asyncio.CancelledError: logger.info("Event processor cancelled."); break
            except Exception as e: logger.exception(f"Event processor error: {e}"); await asyncio.sleep(1)
        logger.info("Event bus processor stopped.")
    async def start(self):
        if self._running: logger.warning("Event bus already running."); return
        self._running=True; self._worker_task=asyncio.create_task(self._process_events(), name="EventBusProcessor"); logger.info("Event bus started.")
    async def stop(self):
        if not self._running or not self._worker_task or self._worker_task.done(): logger.info("Event bus already stopped."); return
        logger.info("Stopping event bus..."); self._running=False; # Signal loop to stop
        # Add small item to queue to unblock worker if waiting on empty queue
        try: self._queue.put_nowait(None) # Sentinel value, processor needs to handle None gracefully or just exit
        except asyncio.QueueFull: pass # Ignore if full during shutdown
        if not self._worker_task.done(): self._worker_task.cancel() # Cancel task
        try: await self._worker_task; logger.info("Event bus stopped.")
        except asyncio.CancelledError: logger.info("Event bus stop confirmed (cancelled).")
        except Exception as e: logger.exception(f"Error during event bus shutdown: {e}")
        finally: self._worker_task = None
event_bus = AsyncEventBus()
EOF
check_success "Failed writing app/core/event_bus.py"

# --- Service Stubs/Placeholders ---
echo "    Creating service stubs (twitch, youtube, x, whatnot)..."
cat << 'EOF' > app/services/twitch_service.py
import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate, SettingsUpdated, BotResponseToSend; from app.core.json_store import get_setting, load_settings
_STATE = {"task": None, "instance": None, "running": False, "settings": {}} # Module level state
async def run_twitch_service(): # The main loop
    global _STATE; logger.info("Twitch run loop started."); _STATE["running"] = True
    while _STATE["running"]:
        token = _STATE["settings"].get("TWITCH_TOKEN"); nick = _STATE["settings"].get("TWITCH_NICK"); client_id = _STATE["settings"].get("TWITCH_CLIENT_ID"); channels_raw = _STATE["settings"].get("TWITCH_CHANNELS",""); channels = [c.strip().lower() for c in channels_raw.split(',') if c.strip()]
        if not all([token, nick, client_id]) or not channels: logger.warning("Twitch config missing in settings.json. Stopping."); event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disabled', message='Config missing')); _STATE["running"]=False; break
        bot = None; attempt = 0; MAX_ATTEMPTS=5; wait = 5
        while _STATE["running"] and attempt < MAX_ATTEMPTS:
            attempt += 1; logger.info(f"Attempting Twitch connection (Attempt {attempt}/{MAX_ATTEMPTS})..."); event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connecting'))
            try: from twitchio.ext import commands; bot = commands.Bot(token=token, client_id=client_id, nick=nick, prefix=None, initial_channels=channels); _STATE["instance"] = bot # Store instance
                 # Simplified event handlers inline for this stub
                 @bot.event async def event_ready(): logger.info(f"Twitch Bot Ready as {bot.nick}"); event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connected')); event_bus.subscribe(BotResponseToSend, handle_send_response) # Subscribe here
                 @bot.event async def event_message(message):
                     if message.echo or not message.author: return; from app.events import InternalChatMessage, ChatMessageReceived; import datetime; ts = message.timestamp.replace(tzinfo=None) if message.timestamp else datetime.datetime.utcnow(); msg=InternalChatMessage(platform='twitch', user=message.author.name, text=message.content, channel=message.channel.name, user_id=str(message.author.id), display_name=message.author.display_name, timestamp=ts, message_id=message.id, raw_data={'tags': message.tags or {}}); event_bus.publish(ChatMessageReceived(message=msg))
                 @bot.event async def event_close(): logger.warning("Twitch connection closed by server."); event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnected')) # Let outer loop handle reconnect
                 @bot.event async def event_error(error, data=None): logger.error(f"Twitch Error: {error}"); event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=str(error))); if 'authentication failed' in str(error): raise error # Raise auth errors to stop retries
                 await bot.start(); logger.info("Twitch bot start() returned (connection closed).") # If it returns, connection closed
            except asyncio.CancelledError: logger.info("Twitch run cancelled."); _STATE["running"]=False; break # Exit outer loop too
            except Exception as e: logger.error(f"Twitch connection failed (Attempt {attempt}): {e}"); event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"Connect attempt failed: {e}")); if 'authentication failed' in str(e): logger.critical("Twitch Auth failed. Stopping."); _STATE["running"]=False; break # Stop retries on auth error
            finally: if bot: await bot.close(); _STATE["instance"]=None # Ensure close
            if not _STATE["running"]: break # Exit if stop was requested during attempt
            logger.info(f"Waiting {wait}s before Twitch retry..."); await asyncio.sleep(wait); wait = min(wait * 2, 60) # Exponential backoff
        if not _STATE["running"]: logger.info("Twitch service run loop exiting."); break # Break outer loop if stopped
        if attempt >= MAX_ATTEMPTS: logger.error("Max Twitch connection attempts reached. Stopping service."); _STATE["running"]=False; event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message='Max connection attempts')); break
async def handle_send_response(event: BotResponseToSend): # Standalone response handler
    global _STATE; bot = _STATE.get("instance"); if not bot or not bot.is_connected or event.response.target_platform != 'twitch': return
    resp=event.response; chan_name=resp.target_channel; text=resp.text; if not chan_name: return
    chan = bot.get_channel(chan_name); if not chan: logger.warning(f"Twitch chan '{chan_name}' not found."); return
    if resp.reply_to_user: text = f"@{resp.reply_to_user.lstrip('@')}, {text}"
    try: logger.info(f"Sending Twitch to #{chan_name}: {text[:50]}..."); await chan.send(text)
    except Exception as e: logger.error(f"Failed Twitch send to #{chan_name}: {e}")
async def handle_settings_update(event: SettingsUpdated):
    global _STATE; twitch_keys={"TWITCH_TOKEN","TWITCH_NICK","TWITCH_CLIENT_ID","TWITCH_CHANNELS"};
    if any(k in twitch_keys for k in event.keys_updated): logger.info("Twitch settings updated, triggering restart..."); await stop_twitch_service(); await asyncio.sleep(1); start_twitch_service_task() # Trigger full restart via task helper
async def stop_twitch_service():
    global _STATE, _run_task; logger.info("Stopping Twitch service..."); _STATE["running"] = False; bot = _STATE.get("instance")
    # Unsubscribe - needs unsubscribe method on event bus
    # try: event_bus.unsubscribe(BotResponseToSend, handle_send_response) except: pass
    if bot: logger.info("Closing Twitch bot instance..."); await bot.close(); _STATE["instance"] = None
    if _run_task and not _run_task.done(): logger.info("Cancelling Twitch run task..."); _run_task.cancel();
        try: await _run_task; logger.info("Twitch task cancelled.")
        except asyncio.CancelledError: logger.info("Twitch task confirmed cancelled.")
        except Exception as e: logger.error(f"Error waiting for cancelled Twitch task: {e}")
    _run_task = None; logger.info("Twitch service stopped.")
def start_twitch_service_task():
    global _run_task, _STATE;
    if _run_task and not _run_task.done(): logger.warning("Twitch task already running."); return _run_task
    logger.info("Creating background task for Twitch service."); event_bus.subscribe(SettingsUpdated, handle_settings_update); _run_task = asyncio.create_task(run_twitch_service(), name="TwitchRunner"); return _run_task
EOF
check_success "Failed writing app/services/twitch_service.py"
echo "    Creating app/services/youtube_service.py (stub)..."
cat << 'EOF' > app/services/youtube_service.py
import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate
async def run_youtube_service(): event_bus.publish(PlatformStatusUpdate(platform='youtube', status='disabled', message='Not implemented')); logger.warning("YouTube service NOT IMPLEMENTED."); await asyncio.sleep(3600*24) # Sleep long time
async def stop_youtube_service(): logger.info("YouTube service stop called (stub).")
def start_youtube_service_task(): logger.info("YouTube service start called (stub)."); return None # Return None as no task created
EOF
echo "    Creating app/services/x_service.py (stub)..."
cat << 'EOF' > app/services/x_service.py
import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate
async def run_x_service(): event_bus.publish(PlatformStatusUpdate(platform='x', status='disabled', message='Not implemented')); logger.warning("X/Twitter service NOT IMPLEMENTED."); await asyncio.sleep(3600*24)
async def stop_x_service(): logger.info("X/Twitter service stop called (stub).")
def start_x_service_task(): logger.info("X/Twitter service start called (stub)."); return None
EOF
echo "    Creating app/services/whatnot_bridge.py (stub)..."
cat << 'EOF' > app/services/whatnot_bridge.py
import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate
# This service would likely manage the pool of WS connections from the extension
# For now, it's just a placeholder task
async def run_whatnot_bridge(): event_bus.publish(PlatformStatusUpdate(platform='whatnot', status='disabled', message='Bridge not active')); logger.warning("Whatnot Bridge service NOT IMPLEMENTED."); await asyncio.sleep(3600*24)
async def stop_whatnot_bridge(): logger.info("Whatnot Bridge stop called (stub).")
def start_whatnot_bridge_task(): logger.info("Whatnot Bridge start called (stub)."); return None
EOF
check_success "Failed writing service stubs"

# --- app/apis/ws_endpoints.py ---
echo "    Creating app/apis/ws_endpoints.py..."
# ... (cat EOF > app/apis/ws_endpoints.py ... same as before) ...
cat << 'EOF' > app/apis/ws_endpoints.py
import logging; import json; from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from app.services.dashboard_service import handle_dashboard_websocket
from app.core.event_bus import event_bus; from app.events import InternalChatMessage
logger = logging.getLogger(__name__); router = APIRouter()
@router.websocket("/dashboard")
async def websocket_dashboard_endpoint(websocket: WebSocket): await handle_dashboard_websocket(websocket)
@router.websocket("/whatnot")
async def websocket_whatnot_endpoint(websocket: WebSocket):
    client = f"{websocket.client.host}:{websocket.client.port}"; logger.info(f"Whatnot Ext client connected: {client}"); await websocket.accept()
    try:
        while True: data = await websocket.receive_text(); logger.debug(f"From Whatnot Ext {client}: {data}")
            try: # Parse and publish ONLY, no command processing here
                 payload = json.loads(data)
                 if 'platform' in payload and payload['platform'] == 'whatnot': # Basic validation
                      msg = InternalChatMessage(platform='whatnot', user=payload.get('user','WN_User'), text=payload.get('text',''), raw_data=payload)
                      event_bus.publish(ChatMessageReceived(message=msg))
                 else: logger.warning(f"Invalid payload from Whatnot Ext: {data}")
            except json.JSONDecodeError: logger.warning(f"Non-JSON from Whatnot Ext: {data}")
            except Exception as e: logger.exception(f"Error processing msg from Whatnot Ext: {e}")
    except WebSocketDisconnect: logger.info(f"Whatnot Ext client {client} disconnected.")
    except Exception as e: logger.error(f"Whatnot Ext WS error for {client}: {e}", exc_info=True)
    finally: logger.debug(f"Closing Whatnot Ext WS handler for {client}")
EOF
check_success "Failed writing app/apis/ws_endpoints.py"

# --- app/apis/settings_api.py --- (Updated for clarity)
echo "    Creating app/apis/settings_api.py..."
cat << 'EOF' > app/apis/settings_api.py
import logging; from fastapi import APIRouter, HTTPException, Body; from pydantic import BaseModel, Field; from typing import Dict, Any, List, Optional
from app.core.json_store import load_settings, save_settings; from app.core.event_bus import event_bus; from app.events import SettingsUpdated, ServiceControl
logger = logging.getLogger(__name__); router = APIRouter()

class AllSettings(BaseModel): # Use one model for easier updates
    TWITCH_TOKEN: Optional[str] = None; TWITCH_CLIENT_ID: Optional[str] = None; TWITCH_NICK: Optional[str] = None; TWITCH_CHANNELS: Optional[str] = None
    YOUTUBE_API_KEY: Optional[str] = None; YOUTUBE_CLIENT_SECRETS_FILE: Optional[str] = None; YOUTUBE_LIVE_CHAT_ID: Optional[str] = None
    X_BEARER_TOKEN: Optional[str] = None; X_API_KEY: Optional[str] = None; X_API_SECRET: Optional[str] = None; X_ACCESS_TOKEN: Optional[str] = None; X_ACCESS_SECRET: Optional[str] = None; X_HASHTAG_OR_MENTION: Optional[str] = None
    # Add non-secret app settings if needed: COMMAND_PREFIX: Optional[str] = None etc.

@router.get("/settings", response_model=Dict[str, Any], summary="Get Current Settings (Secrets Masked)")
async def get_current_settings():
    settings = await load_settings(); safe_settings = {};
    for key, value in settings.items(): safe_settings[key] = "********" if ("TOKEN" in key or "SECRET" in key or "PASSWORD" in key) and value else value
    return safe_settings

@router.post("/settings", status_code=200, summary="Update Settings")
async def update_settings_endpoint(new_settings: AllSettings = Body(...)):
    logger.info("Received POST /api/settings"); current_settings = await load_settings(); updated_keys = []; update_data = new_settings.dict(exclude_unset=True)
    if not update_data: raise HTTPException(status_code=400, detail="No settings provided.")
    for key, value in update_data.items():
        # Update if value is provided (not None) AND is different from current or key doesn't exist
        # Treat empty string "" as a valid value to set (e.g., clearing optional field)
        if value is not None and current_settings.get(key) != value:
            current_settings[key] = value; updated_keys.append(key); logger.debug(f"Setting '{key}' updated.")
    if not updated_keys: logger.info("No actual changes to settings."); return {"message": "No settings changed."}
    if await save_settings(current_settings): logger.info(f"Settings updated for keys: {updated_keys}"); event_bus.publish(SettingsUpdated(keys_updated=updated_keys)); return {"message": f"Settings updated successfully ({', '.join(updated_keys)}). Service restart may be needed."}
    else: raise HTTPException(status_code=500, detail="Failed to save settings.")

@router.post("/control/{service_name}/{command}", status_code=200, summary="Control Services (start/stop/restart)")
async def control_service(service_name: str, command: str):
     allowed_services = ["twitch", "youtube", "x", "whatnot"]; allowed_commands = ["start", "stop", "restart"]; service_name = service_name.lower(); command = command.lower()
     if service_name not in allowed_services: raise HTTPException(status_code=404, detail="Service not found.")
     if command not in allowed_commands: raise HTTPException(status_code=400, detail="Invalid command.")
     logger.info(f"Control command '{command}' for service '{service_name}' received."); event_bus.publish(ServiceControl(service_name=service_name, command=command)); return {"message": f"'{command}' command sent to '{service_name}' service."}

EOF
check_success "Failed writing app/apis/settings_api.py"

# --- app/main.py --- (Final version - slightly updated)
echo "    Creating app/main.py..."
# Paste the full corrected main.py (with JSON focus) from previous response here
cat << 'EOF' > app/main.py
import asyncio; import logging; import signal; from fastapi import FastAPI; from fastapi.staticfiles import StaticFiles; from contextlib import asynccontextmanager; from pathlib import Path; import sys
from app.core.config import logger; from app.core.event_bus import event_bus
from app.apis import ws_endpoints, settings_api # Import settings_api
from app.services.twitch_service import start_twitch_service_task, stop_twitch_service
from app.services.youtube_service import start_youtube_service_task, stop_youtube_service
from app.services.x_service import start_x_service_task, stop_x_service
from app.services.whatnot_bridge import start_whatnot_bridge_task, stop_whatnot_bridge
from app.services.chat_processor import setup_chat_processor
from app.services.dashboard_service import setup_dashboard_service_listeners
from app.services.streamer_command_handler import setup_streamer_command_handler
from app.events import ServiceControl

background_tasks = set(); _service_tasks_map: dict[str, asyncio.Task | None] = {} # Store running tasks

async def handle_service_control(event: ServiceControl):
     logger.info(f"Handling control: '{event.command}' for '{event.service_name}'"); control_funcs = service_control_map.get(event.service_name); task = _service_tasks_map.get(event.service_name)
     if not control_funcs: logger.error(f"No controls for '{event.service_name}'"); return
     start_func=control_funcs.get("start"); stop_func=control_funcs.get("stop");
     if event.command == "stop":
          if stop_func: await stop_func()
          else: logger.warning(f"No stop func for '{event.service_name}'")
          _service_tasks_map[event.service_name] = None # Clear task reference
     elif event.command == "start":
          if task and not task.done(): logger.warning(f"Service '{event.service_name}' already running/starting."); return
          if start_func: new_task = start_func();
               if new_task: _service_tasks_map[event.service_name] = new_task; background_tasks.add(new_task); new_task.add_done_callback(background_tasks.discard)
          else: logger.warning(f"No start func for '{event.service_name}'")
     elif event.command == "restart":
          logger.info(f"Restarting '{event.service_name}'...");
          if stop_func: await stop_func(); await asyncio.sleep(1)
          else: logger.warning(f"No stop func for restart of '{event.service_name}'")
          if start_func: new_task = start_func();
               if new_task: _service_tasks_map[event.service_name] = new_task; background_tasks.add(new_task); new_task.add_done_callback(background_tasks.discard)
          else: logger.warning(f"No start func for restart of '{event.service_name}'")

service_control_map = { "twitch": {"start": start_twitch_service_task, "stop": stop_twitch_service}, "youtube": {"start": start_youtube_service_task, "stop": stop_youtube_service}, "x": {"start": start_x_service_task, "stop": stop_x_service}, "whatnot": {"start": start_whatnot_bridge_task, "stop": stop_whatnot_bridge} }

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("--- Application startup sequence ---"); logger.info("Starting event bus..."); await event_bus.start()
    logger.info("Setting up listeners..."); setup_chat_processor(); setup_dashboard_service_listeners(); setup_streamer_command_handler(); event_bus.subscribe(ServiceControl, handle_service_control)
    logger.info("Startup listeners complete. Services will start based on saved settings via UI/API trigger."); logger.info("--- Application startup complete. Running! ---")
    yield # App runs
    logger.info("--- Application shutdown sequence ---"); logger.info("Stopping platform services...");
    await asyncio.gather(stop_twitch_service(), stop_youtube_service(), stop_x_service(), stop_whatnot_bridge(), return_exceptions=True) # Stop all in parallel
    logger.info("Waiting briefly..."); await asyncio.sleep(1); logger.info("Stopping event bus..."); await event_bus.stop()
    if background_tasks: logger.warning(f"Cancelling {len(background_tasks)} lingering tasks...");
    for task in list(background_tasks):
         if task and not task.done(): task.cancel()
    if background_tasks: try: await asyncio.wait_for(asyncio.gather(*background_tasks, return_exceptions=True), timeout=5.0); except Exception: pass
    logger.info("--- Application shutdown complete. ---")

app = FastAPI(title="FoSBot (JSON Config)", version="0.3.0-json", lifespan=lifespan); app.include_router(ws_endpoints.router, prefix="/ws"); app.include_router(settings_api.router, prefix="/api", tags=["Settings & Control"])
STATIC_DIR = "static";
if not Path(STATIC_DIR).is_dir(): logger.error(f"Static dir '{STATIC_DIR}' not found!")
else: try: app.mount("/", StaticFiles(directory=STATIC_DIR, html=True), name="static"); logger.info(f"Mounted static files from './{STATIC_DIR}'.")
      except Exception as e: logger.exception(f"Failed mount static: {e}")
if __name__ == "__main__": import uvicorn; from app.core.config import WS_HOST, WS_PORT, LOG_LEVEL; logger.warning("Run via 'uvicorn app.main:app --reload'."); uvicorn.run("app.main:app", host=WS_HOST, port=WS_PORT, log_level=LOG_LEVEL.lower(), reload=False)

EOF
check_success "Failed writing app/main.py"

echo "    Python application files created."

# --- [9/10] Create Whatnot Extension Files ---
echo ""; echo "[9/10] Setting up Whatnot Extension files..."
# ... (manifest, background, popup.html, popup.js, content.js - use final versions from previous answers) ...
# (Ensure content.js includes inspector logic)
cat << 'EOF' > whatnot_extension/manifest.json
{"manifest_version": 3,"name": "FoSBot Whatnot Helper","version": "0.3.0","description": "Reads Whatnot chat. Requires config via popup.","permissions": ["storage","activeTab","scripting"],"host_permissions": ["*://*.whatnot.com/*"],"background": {"service_worker": "background.js"},"content_scripts": [{"matches": ["*://*.whatnot.com/*"],"js": ["content.js"],"run_at": "document_idle","all_frames": false}],"action": {"default_popup": "popup.html","default_icon": {"16": "icons/icon16.png","48": "icons/icon48.png","128": "icons/icon128.png"}},"icons": {"16": "icons/icon16.png","48": "icons/icon48.png","128": "icons/icon128.png"}}
EOF
cat << 'EOF' > whatnot_extension/background.js
chrome.runtime.onInstalled.addListener(details => { console.log(`FoSBot WN Helper ${details.reason}.`); }); console.log("FoSBot BG Loaded.");
EOF
cat << 'EOF' > whatnot_extension/popup.html
<!DOCTYPE html><html><head><title>FoSBot Helper</title><meta charset="UTF-8"><style>body{width:250px;font-family:sans-serif;padding:10px;font-size:14px}button{margin-top:10px;padding:5px 10px;cursor:pointer}p{margin:5px 0;line-height:1.3}#status,#ws-status{font-style:italic;color:grey;min-height:1.2em;margin-top:5px}#currentSelectors{margin-top:15px;font-size:11px;color:#333;max-height:150px;overflow-y:auto;border-top:1px solid #ccc;padding-top:5px;background-color:#f9f9f9;padding:5px;border-radius:3px}#currentSelectors div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:3px}strong{display:block;margin-bottom:4px}</style></head><body><h3>Whatnot Selectors</h3><p>Configure elements for chat interaction. Click, then follow overlay prompts.</p><button id="configureButton">Configure/Re-Configure</button><div id="status"></div><div id="ws-status">WS: Loading...</div><div id="currentSelectors">Loading...</div><script src="popup.js"></script></body></html>
EOF
cat << 'EOF' > whatnot_extension/popup.js
const cfgBtn=document.getElementById('configureButton');const statEl=document.getElementById('status');const selDiv=document.getElementById('currentSelectors');const wsStatEl=document.getElementById('ws-status');
function displaySelectors(){chrome.storage.local.get(['whatnotSelectors'],(r)=>{selDiv.innerHTML='<strong>Current:</strong><br>';if(r.whatnotSelectors){const k=['chatContainer','messageItem','username','messageText','chatInput','sendButton'];k.forEach(key=>{const d=document.createElement('div');const v=r.whatnotSelectors[key];d.textContent=`${key}: ${v||'N/A'}`;d.title=v||'N/A';selDiv.appendChild(d);});}else{selDiv.innerHTML+='<i>None saved.</i>';}});}
function checkConnection(){wsStatEl.textContent='WS: Chk...';chrome.tabs.query({active:true,currentWindow:true},(tabs)=>{const wt=tabs.find(t=>t.url&&t.url.includes('whatnot.com'));if(wt&&wt.id){chrome.tabs.sendMessage(wt.id,{action:"query_status"},(r)=>{if(chrome.runtime.lastError){wsStatEl.textContent=`WS: Err`;console.error(chrome.runtime.lastError.message);}else if(r){wsStatEl.textContent=`WS: ${r.ws_status||'?'}`;if(r.selectors_ok===false)statEl.textContent="WARN: Selectors missing!";else if(r.selectors_ok===true)statEl.textContent="Selectors loaded.";}else{wsStatEl.textContent='WS: No Resp';}});}});}
cfgBtn.addEventListener('click',()=>{statEl.textContent='Sending...';chrome.tabs.query({active:true,currentWindow:true},(tabs)=>{const wt=tabs.find(t=>t.url&&t.url.includes('whatnot.com'));if(wt&&wt.id){chrome.tabs.sendMessage(wt.id,{action:"start_inspector"},(r)=>{if(chrome.runtime.lastError){statEl.textContent=`Err: ${chrome.runtime.lastError.message}. Refresh?`;console.error(chrome.runtime.lastError);}else if(r&&r.status==="started"){statEl.textContent='Inspector started.';window.close();}else if(r&&r.status==="already_active"){statEl.textContent='Inspector active.';window.close();}else{statEl.textContent='Failed: No response.';console.warn(r);}});}});}
document.addEventListener('DOMContentLoaded',()=>{displaySelectors();checkConnection();});
EOF
cat << 'EOF' > whatnot_extension/content.js
// FoSBot Whatnot Helper Content Script v0.4 (Webapp Config)
let selectors = {}; const STORAGE_KEY = 'whatnotSelectors'; let WS_URL = 'ws://localhost:8000/ws/whatnot'; let socket = null; let reconnectTimer = null; let reconnectAttempts = 0; const MAX_RECONNECT_ATTEMPTS = 15; const RECONNECT_DELAY_BASE = 3000; let observer = null; let isInspectorMode = false; let inspectorStep = 0;
const inspectorSteps = [ { key: 'chatContainer', prompt: 'Click MAIN chat message area' }, { key: 'messageItem', prompt: 'Click ANY single chat message row' }, { key: 'username', prompt: 'Click USERNAME in that message' }, { key: 'messageText', prompt: 'Click MESSAGE TEXT in that message' }, { key: 'chatInput', prompt: 'Click the text INPUT field' }, { key: 'sendButton', prompt: 'Click the SEND button/icon' } ];
let inspectorOverlay = null; let lastClickedElementForStep = {};
function initialize() { console.log("FoSBot WN Helper: Init"); loadSelectors().then(loaded => { connectWebSocket(); }); setupMessageListener(); }
function connectWebSocket() { clearTimeout(reconnectTimer); if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return; console.log(`WN Ext: Connecting WS: ${WS_URL}`); try { socket = new WebSocket(WS_URL); } catch (e) { console.error(`WN Ext: WS connect failed: ${e}`); scheduleReconnect(); return; }
    socket.onopen = () => { console.log('WN Ext: WS Connected'); reconnectAttempts = 0; startObserver(); };
    socket.onmessage = (event) => { console.debug('WN Ext: Msg from server:', event.data); try { const data = JSON.parse(event.data); if (data.action === 'postToWhatnot') { handlePostToWhatnot(data.message); } } catch (e) { console.error("WN Ext: Error parsing server msg", e); } };
    socket.onclose = (event) => { console.log(`WN Ext: WS closed (Code: ${event.code})`); stopObserver(); socket = null; scheduleReconnect(); };
    socket.onerror = (error) => { console.error('WN Ext: WS Error:', error); };
}
function scheduleReconnect() { if (isInspectorMode) return; reconnectAttempts++; if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) { const delay = Math.min(RECONNECT_DELAY_BASE * Math.pow(1.5, reconnectAttempts -1), 60000); console.log(`WN Ext: Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000}s...`); clearTimeout(reconnectTimer); reconnectTimer = setTimeout(connectWebSocket, delay); } else { console.error("WN Ext: Max WS reconnect attempts."); } }
function handlePostToWhatnot(message) { console.log(`WN Ext: Attempt post: "${message}"`); if (!validateSelectors(['chatInput', 'sendButton'])) { console.error("Cannot post: Selectors invalid."); return false; } const chatInput = document.querySelector(selectors.chatInput); const sendButton = document.querySelector(selectors.sendButton); if (!chatInput || !sendButton) { console.error(`Cannot find Input/Button: ${selectors.chatInput} / ${selectors.sendButton}`); return false; }
    try { chatInput.focus(); const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set; setter.call(chatInput, message); chatInput.dispatchEvent(new Event('input', { bubbles: true, composed: true })); chatInput.dispatchEvent(new Event('change', { bubbles: true, composed: true }));
        setTimeout(() => { if (!sendButton.disabled) sendButton.click(); else console.warn("WN Send disabled."); }, 150); return true;
    } catch (e) { console.error("Error posting to WN:", e); return false; }
}
async function loadSelectors() { try { const result = await chrome.storage.local.get([STORAGE_KEY]); if (result[STORAGE_KEY] && typeof result[STORAGE_KEY] === 'object') { const keys = Object.keys(selectors); if (keys.every(k => Object.keys(result[STORAGE_KEY]).includes(k))) { selectors = result[STORAGE_KEY]; console.log('WN Ext: Loaded selectors:', selectors); return validateSelectors(keys); } } console.warn('WN Ext: No valid selectors.'); return false; } catch (e) { console.error("WN Ext: Error loading selectors:", e); return false; } }
function validateSelectors(keysToCheck) { return keysToCheck.every(key => selectors[key] && typeof selectors[key] === 'string' && selectors[key].trim() !== ''); }
async function saveSelectors() { try { await chrome.storage.local.set({ [STORAGE_KEY]: selectors }); console.log('WN Ext: Selectors saved:', selectors); if (inspectorOverlay) updateInspectorStatus('Saved! Restarting observer...'); stopObserver(); startObserver(); } catch (e) { console.error("WN Ext: Error saving selectors:", e); if (inspectorOverlay) updateInspectorStatus('ERROR saving!'); } }
function startObserver() { stopObserver(); if (!socket || socket.readyState !== WebSocket.OPEN) return; if (!validateSelectors(['chatContainer', 'messageItem', 'username', 'messageText'])) { console.warn('Observer not started: Read selectors invalid.'); return; } const container = document.querySelector(selectors.chatContainer); if (!container) { console.error(`Observer failed: Cannot find container: ${selectors.chatContainer}`); return; } console.log(`WN Ext: Starting Observer on: ${selectors.chatContainer}`);
    observer = new MutationObserver((mutations) => { for (const m of mutations) { if (m.addedNodes.length) { m.addedNodes.forEach(node => { if (node.nodeType === 1) { if (node.matches(selectors.messageItem)) { parseAndSend(node); } else { node.querySelectorAll(selectors.messageItem).forEach(parseAndSend); } } }); } } });
    observer.observe(container, { childList: true, subtree: true }); console.log("WN Ext: Observer active.");
}
function parseAndSend(el) { const userEl = el.querySelector(selectors.username); const textEl = el.querySelector(selectors.messageText); const user = userEl?.textContent?.trim(); const text = textEl?.textContent?.trim(); if (user && text && text !== user && socket && socket.readyState === WebSocket.OPEN) { console.debug(`WN Ext: Sending: [${user}] ${text}`); socket.send(JSON.stringify({ platform: 'whatnot', user: user, text: text })); } }
function stopObserver() { if (observer) { observer.disconnect(); observer = null; console.log("WN Ext: Observer stopped."); } }
function startInspectorMode() { if (isInspectorMode) return; isInspectorMode = true; inspectorStep = 0; lastClickedElementForStep = {}; console.log("WN Ext: Starting Inspector"); createInspectorOverlay(); updateInspectorPrompt(); document.body.style.cursor = 'crosshair'; document.addEventListener('click', inspectorClickListener, { capture: true }); }
function stopInspectorMode(save = false) { if (!isInspectorMode) return; isInspectorMode = false; document.body.style.cursor = 'default'; document.removeEventListener('click', inspectorClickListener, { capture: true }); removeInspectorOverlay(); console.log("WN Ext: Inspector Stopped."); if (save) { saveSelectors(); } }
function createInspectorOverlay() { removeInspectorOverlay(); inspectorOverlay = document.createElement('div'); inspectorOverlay.style.cssText = `all: initial; position: fixed; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.85); color: white; padding: 15px; border: 3px solid gold; border-radius: 5px; z-index: 2147483647; font-family: sans-serif; font-size: 14px; line-height: 1.4; max-width: 350px; box-shadow: 0 0 15px rgba(0,0,0,0.5);`; inspectorOverlay.innerHTML = `<h4 style="all: revert; margin: 0 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid gold;">Configure Selectors</h4><p id="inspectorPrompt" style="all: revert; margin: 5px 0; font-weight: bold;"></p><p id="inspectorStatus" style="all: revert; margin: 10px 0 0 0; font-style: italic; color: #ddd;"></p><button id="cancelInspector" style="all: revert; margin-top: 15px; padding: 5px 8px; background-color: #cc5555; color: white; border: 1px solid #aa4444; cursor: pointer; border-radius: 3px; font-size: 12px;">Cancel</button>`; document.body.appendChild(inspectorOverlay); inspectorOverlay.querySelector('#cancelInspector').addEventListener('click', (e) => { e.stopPropagation(); stopInspectorMode(false); }); }
function removeInspectorOverlay() { if (inspectorOverlay) { inspectorOverlay.remove(); inspectorOverlay = null; } }
function updateInspectorPrompt() { if (!inspectorOverlay) return; const promptEl = inspectorOverlay.querySelector('#inspectorPrompt'); const cancelBtn = inspectorOverlay.querySelector('#cancelInspector'); if (inspectorStep < inspectorSteps.length) { promptEl.textContent = `Step ${inspectorStep + 1}/${inspectorSteps.length}: ${inspectorSteps[inspectorStep].prompt}`; } else { promptEl.textContent = 'All steps done! Review selectors.'; updateInspectorStatus('Click Save to apply.'); const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save Selectors'; saveBtn.style.cssText = 'all: revert; margin-left: 10px; padding: 5px 8px; background-color: #4CAF50; color: white; border: 1px solid #388E3C; cursor: pointer; border-radius: 3px; font-size: 12px;'; saveBtn.onclick = (e) => { e.stopPropagation(); stopInspectorMode(true); }; cancelBtn.insertAdjacentElement('afterend', saveBtn); } }
function updateInspectorStatus(text) { if (!inspectorOverlay) return; inspectorOverlay.querySelector('#inspectorStatus').textContent = text; }
function generateRobustSelector(el) { if (!el || typeof el.getAttribute !== 'function') return null; try { if (el.id) { const idSel = `#${CSS.escape(el.id)}`; if (document.querySelectorAll(idSel).length === 1) return idSel; } const dataAttrs = Array.from(el.attributes).filter(a => a.name.startsWith('data-test') && a.value); for (const a of dataAttrs) { const s = `${el.tagName.toLowerCase()}[${a.name}="${CSS.escape(a.value)}"]`; if (document.querySelectorAll(s).length === 1) return s; } const role = el.getAttribute('role'); if (role) { const s = `${el.tagName.toLowerCase()}[role="${CSS.escape(role)}"]`; if (document.querySelectorAll(s).length === 1) return s; } if (el.classList.length > 0) { const classes = Array.from(el.classList).filter(c => !/^(?:js-|is-|has-|active|focus|hover|animating)/.test(c) && !/\d/.test(c) && c.length > 3); if (classes.length > 0) { return `${el.tagName.toLowerCase()}.${classes.map(c => CSS.escape(c)).join('.')}`; } } return el.tagName.toLowerCase(); } catch (e) { console.error("Error generating selector:", e, el); return null; } }
function generateRelativeSelector(target, base) { if (!base || !target || !base.contains(target)) { return generateRobustSelector(target); } try { if (target.id && base.querySelectorAll(`#${CSS.escape(target.id)}`).length === 1) return `#${CSS.escape(target.id)}`; const dataAttrs = Array.from(target.attributes).filter(a => a.name.startsWith('data-test') && a.value); for (const a of dataAttrs) { const s = `[${a.name}="${CSS.escape(a.value)}"]`; if (base.querySelectorAll(s).length === 1 && base.querySelector(s) === target) return s; } if (target.classList.length > 0) { const classes = Array.from(target.classList).filter(c => !/^(?:js-|is-|has-|active|focus|hover|animating)/.test(c) && !/\d/.test(c) && c.length > 3); if (classes.length > 0) { const s = `.${classes.map(c => CSS.escape(c)).join('.')}`; if (base.querySelectorAll(s).length === 1 && base.querySelector(s) === target) return s; } } return generateRobustSelector(target); } catch (e) { console.error("Error generating relative selector:", e); return generateRobustSelector(target); } }
function inspectorClickListener(event) { if (!isInspectorMode) return; event.preventDefault(); event.stopPropagation(); const targetElement = event.target; const currentStep = inspectorSteps[inspectorStep]; let selector; targetElement.style.outline = '3px dashed gold'; setTimeout(() => { targetElement.style.outline = ''; }, 750); if (currentStep.key === 'username' || currentStep.key === 'messageText') { const baseElement = lastClickedElementForStep['messageItem']; selector = generateRelativeSelector(targetElement, baseElement); } else { selector = generateRobustSelector(targetElement); lastClickedElementForStep[currentStep.key] = targetElement; } selectors[currentStep.key] = selector; updateInspectorStatus(`Selected ${currentStep.key}: ${selector}`); inspectorStep++; updateInspectorPrompt(); }
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { console.log("WN Ext: Received message:", request); if (request.action === "start_inspector") { if (isInspectorMode) { sendResponse({ status: "already_active" }); if(inspectorOverlay) inspectorOverlay.style.zIndex = '2147483647'; } else { startInspectorMode(); sendResponse({ status: "started" }); } return true; } else if (request.action === "query_status") { sendResponse({ ws_status: socket ? ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][socket.readyState] : "Not Init", selectors_ok: validateSelectors(Object.keys(selectors)) }); return false; } });
initialize(); // Start
EOF
check_success "Failed writing whatnot_extension/content.js"

# --- Create Static Files (Dashboard UI) ---
echo "    Creating static/index.html (with Settings UI)..."
# ... (cat EOF > static/index.html ... same as before) ...
cat << 'EOF' > static/index.html
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>FoSBot Dashboard</title><style>body{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;margin:0;display:flex;flex-direction:column;height:100vh;background-color:#f0f2f5;font-size:14px}button{cursor:pointer;padding:8px 15px;border:none;border-radius:4px;font-weight:600;transition:background-color .2s ease}input[type=text],input[type=password],input[type=url]{padding:8px 10px;border:1px solid #ccc;border-radius:3px;font-size:14px;width:calc(100% - 22px);margin-bottom:8px}label{display:block;margin-bottom:3px;font-weight:600;font-size:.9em;color:#555}#header{background-color:#2c3e50;color:#ecf0f1;padding:8px 15px;display:flex;justify-content:space-between;align-items:center;box-shadow:0 2px 4px rgba(0,0,0,.1)}#header h1{margin:0;font-size:1.4em}#status-indicators{display:flex;gap:12px;font-size:.8em}#status-indicators span{display:flex;align-items:center}.status-light{width:10px;height:10px;border-radius:50%;margin-right:4px;border:1px solid rgba(0,0,0,.1)}.status-text{color:#bdc3c7}.status-disconnected,.status-disabled{background-color:#7f8c8d}.status-connected{background-color:#2ecc71}.status-connecting{background-color:#f39c12;animation:pulseConnect 1.5s infinite}.status-error,.status-crashed,.status-auth_error{background-color:#e74c3c;animation:pulseError 1s infinite}.status-disconnecting{background-color:#e67e22}@keyframes pulseConnect{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}@keyframes pulseError{0%{transform:scale(.8)}50%{transform:scale(1.1)}100%{transform:scale(.8)}}#main-content{display:flex;flex:1;overflow:hidden}#tab-buttons{background-color:#e1e5eb;padding:5px 10px;border-bottom:1px solid #d1d9e6}#tab-buttons button{background:0 0;border:none;padding:8px 12px;cursor:pointer;font-size:1em;border-bottom:3px solid transparent;margin-right:5px}#tab-buttons button.active{border-bottom-color:#3498db;font-weight:700;color:#2980b9}#content-area{flex:1;display:flex;overflow:hidden}#chat-container{flex:3;display:flex;flex-direction:column;border-right:1px solid #d1d9e6}.tab-content{display:none;height:100%;flex-direction:column;overflow:hidden}.tab-content.active{display:flex}#chat-output{flex:1;overflow-y:auto;padding:10px 15px;background-color:#fff;line-height:1.6}#chat-output div{margin-bottom:6px;word-wrap:break-word;padding:3px 0}#chat-output .platform-tag{font-weight:700;margin-right:5px;display:inline-block;min-width:35px;text-align:right}.twitch{color:#9146ff}.youtube{color:#f00}.x{color:#1da1f2}.whatnot{color:#ff6b00}.streamer_admin{color:#f39c12}.system{color:#7f8c8d}.streamer-msg{background-color:#fff9e6;padding:4px 8px;border-left:3px solid #f1c40f;border-radius:3px;margin-left:-8px;margin-right:-8px}.timestamp{font-size:.75em;color:#95a5a6;margin-left:8px;float:right;opacity:.7}a{color:#3498db;text-decoration:none}a:hover{text-decoration:underline}#input-area{display:flex;padding:10px;border-top:1px solid #d1d9e6;background-color:#ecf0f1}#streamerInput{flex:1;margin-right:8px}#sendButton{background-color:#27ae60;color:#fff}#sendButton:hover{background-color:#2ecc71}#clearButton{background-color:#e67e22;color:#fff;margin-left:5px}#clearButton:hover{background-color:#f39c12}#settings-container{padding:20px;overflow-y:auto;background-color:#fff}.settings-section{margin-bottom:25px;padding-bottom:15px;border-bottom:1px solid #eee}.settings-section h3{margin-top:0;color:#2c3e50;font-size:1.1em}.settings-section button{background-color:#3498db;color:#fff;margin-top:10px}.settings-section button:hover{background-color:#2980b9}.form-group{margin-bottom:10px}#sidebar{flex:1;padding:15px;background-color:#f8f9fa;border-left:1px solid #d1d9e6;overflow-y:auto;font-size:12px;min-width:250px}#sidebar h3{margin-top:0;margin-bottom:10px;color:#2c3e50;border-bottom:1px solid #eee;padding-bottom:5px}#log-output{height:200px;overflow-y:scroll;border:1px solid #eee;padding:8px;margin-top:10px;font-family:Menlo,Monaco,Consolas,Courier New,monospace;background-color:#fff;border-radius:3px;margin-bottom:15px}.log-error{color:#c0392b;font-weight:700}.log-warning{color:#f39c12}.log-info{color:#2980b9}</style></head><body><div id="header"><h1>FoSBot Dashboard</h1><div id="status-indicators"><span id="status-ws">WS: <span class="status-light status-disconnected"></span><span class="status-text">Offline</span></span> <span id="status-twitch">Twitch: <span class="status-light status-disabled"></span><span class="status-text">Off</span></span> <span id="status-youtube">YouTube: <span class="status-light status-disabled"></span><span class="status-text">Off</span></span> <span id="status-x">X: <span class="status-light status-disabled"></span><span class="status-text">Off</span></span> <span id="status-whatnot">Whatnot: <span class="status-light status-disabled"></span><span class="status-text">Ext</span></span></div></div><div id="tab-buttons"><button class="tab-button active" data-tab="chat">Chat</button> <button class="tab-button" data-tab="settings">Settings</button></div><div id="content-area"><div id="chat-container" class="tab-content active" data-tab-content="chat"><div id="chat-output"><div>Welcome! Attempting to connect to backend...</div></div><div id="input-area"><input type="text" id="streamerInput" placeholder="Type message or command (e.g., !roll) to send..."><button id="sendButton">Send</button><button id="clearButton">Clear Display</button></div></div><div id="settings-container" class="tab-content" data-tab-content="settings"><h2>Application Settings</h2><p id="settings-status" style="font-style:italic;"></p><div class="settings-section"><h3>Twitch</h3><form id="twitch-settings-form"><div class="form-group"><label for="twitch-nick">Bot Username (TWITCH_NICK)</label><input type="text" id="twitch-nick" name="TWITCH_NICK"></div><div class="form-group"><label for="twitch-token">Bot OAuth Token (TWITCH_TOKEN)</label><input type="password" id="twitch-token" name="TWITCH_TOKEN" placeholder="oauth:xxxxxxxxxxxx"></div><div class="form-group"><label for="twitch-client-id">Client ID (TWITCH_CLIENT_ID)</label><input type="text" id="twitch-client-id" name="TWITCH_CLIENT_ID"></div><div class="form-group"><label for="twitch-channels">Channel(s) to Join (TWITCH_CHANNELS, comma-separated)</label><input type="text" id="twitch-channels" name="TWITCH_CHANNELS"></div><button type="submit">Save Twitch Settings</button></form></div><div class="settings-section"><h3>YouTube</h3><form id="youtube-settings-form"><div class="form-group"><label for="youtube-api-key">API Key (YOUTUBE_API_KEY)</label><input type="text" id="youtube-api-key" name="YOUTUBE_API_KEY"></div><div class="form-group"><label for="youtube-secrets-file">Client Secrets File Path (YOUTUBE_CLIENT_SECRETS_FILE)</label><input type="text" id="youtube-secrets-file" name="YOUTUBE_CLIENT_SECRETS_FILE" placeholder="/path/to/your/client_secret.json"></div><div class="form-group"><label for="youtube-chat-id">Live Chat ID (YOUTUBE_LIVE_CHAT_ID, optional)</label><input type="text" id="youtube-chat-id" name="YOUTUBE_LIVE_CHAT_ID" placeholder="Leave blank to auto-detect"></div><button type="submit">Save YouTube Settings</button></form></div><div class="settings-section"><h3>X / Twitter</h3><form id="x-settings-form"><div class="form-group"><label for="x-bearer">Bearer Token (X_BEARER_TOKEN)</label><input type="text" id="x-bearer" name="X_BEARER_TOKEN"></div><div class="form-group"><label for="x-api-key">API Key (X_API_KEY)</label><input type="text" id="x-api-key" name="X_API_KEY"></div><div class="form-group"><label for="x-api-secret">API Secret (X_API_SECRET)</label><input type="password" id="x-api-secret" name="X_API_SECRET"></div><div class="form-group"><label for="x-access-token">Access Token (X_ACCESS_TOKEN)</label><input type="text" id="x-access-token" name="X_ACCESS_TOKEN"></div><div class="form-group"><label for="x-access-secret">Access Secret (X_ACCESS_SECRET)</label><input type="password" id="x-access-secret" name="X_ACCESS_SECRET"></div><div class="form-group"><label for="x-monitor">Hashtag/Mention to Monitor (X_HASHTAG_OR_MENTION)</label><input type="text" id="x-monitor" name="X_HASHTAG_OR_MENTION" placeholder="#YourTag or @YourBot"></div><button type="submit">Save X/Twitter Settings</button></form></div><div class="settings-section"><h3>Service Control</h3><p>Restart services after changing credentials.</p><button class="control-button" data-service="twitch" data-command="start">Start Twitch</button> <button class="control-button" data-service="twitch" data-command="stop">Stop Twitch</button> <button class="control-button" data-service="twitch" data-command="restart">Restart Twitch</button><br><button class="control-button" data-service="youtube" data-command="start">Start YouTube</button> <button class="control-button" data-service="youtube" data-command="stop">Stop YouTube</button> <button class="control-button" data-service="youtube" data-command="restart">Restart YouTube</button><br><button class="control-button" data-service="x" data-command="start">Start X</button> <button class="control-button" data-service="x" data-command="stop">Stop X</button> <button class="control-button" data-service="x" data-command="restart">Restart X</button><br></div></div><div id="sidebar"><h3>Status & Logs</h3><div id="general-status">App Status: Initializing...</div><div id="log-output"></div></div></div><script src="main.js"></script></body></html>
EOF
check_success "Failed writing static/index.html"

echo "    Creating static/main.js..."
# Paste the full updated main.js from previous response here
cat << 'EOF' > static/main.js
// FoSBot Dashboard Frontend JS v0.4 (Webapp Config)
const chatOutput=document.getElementById('chat-output');const streamerInput=document.getElementById('streamerInput');const sendButton=document.getElementById('sendButton');const clearButton=document.getElementById('clearButton');const wsStatusElement=document.getElementById('status-ws').querySelector('.status-text');const wsLightElement=document.getElementById('status-ws').querySelector('.status-light');const platformStatus={twitch:document.getElementById('status-twitch'),youtube:document.getElementById('status-youtube'),x:document.getElementById('status-x'),whatnot:document.getElementById('status-whatnot')};const generalStatus=document.getElementById('general-status');const logOutput=document.getElementById('log-output');const tabButtons=document.querySelectorAll('.tab-button');const tabContents=document.querySelectorAll('.tab-content');const settingsStatus=document.getElementById('settings-status');const twitchForm=document.getElementById('twitch-settings-form');const youtubeForm=document.getElementById('youtube-settings-form');const xForm=document.getElementById('x-settings-form');const controlButtons=document.querySelectorAll('.control-button');let socket=null;let reconnectTimer=null;let reconnectAttempts=0;const MAX_RECONNECT_ATTEMPTS=10;const RECONNECT_DELAY_BASE=3000;
function updateStatus(id,cls,txt=''){const i=platformStatus[id];if(i){const t=i.querySelector('.status-text');const l=i.querySelector('.status-light');l.className='status-light';l.classList.add(`status-${cls}`);t.textContent=txt||cls.charAt(0).toUpperCase()+cls.slice(1);}else if(id==='ws'){wsLightElement.className='status-light';wsLightElement.classList.add(`status-${cls}`);wsStatusElement.textContent=txt||cls.charAt(0).toUpperCase()+cls.slice(1);}}
function formatTimestamp(iso){if(!iso)return '';try{const d=new Date(iso);if(isNaN(d.getTime()))return '';return d.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit',second:'2-digit'});}catch(e){console.error("TS fmt err:",e);return '';}}
function addChatMessage(p,u,t,ts=null){const d=document.createElement('div');const ps=document.createElement('span');const us=document.createElement('span');const ts_span=document.createElement('span');const tm=document.createElement('span');const pCls=p?p.toLowerCase().replace(/[^a-z0-9]/g,''):'system';ps.classList.add('platform-tag',pCls);ps.textContent=`[${p?p.toUpperCase():'SYS'}]`;us.style.fontWeight='bold';us.textContent=` ${u}: `;const sT=t.replace(/</g,"<").replace(/>/g,">");const urlRgx=/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;ts_span.innerHTML=sT.replace(urlRgx,'<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');tm.classList.add('timestamp');tm.textContent=formatTimestamp(ts);d.appendChild(tm);d.appendChild(ps);d.appendChild(us);d.appendChild(ts_span);const streamerU="STREAMER";if(u&&u.toLowerCase()===streamerU.toLowerCase()){d.classList.add('streamer-msg');}const scroll=chatOutput.scrollTop+chatOutput.clientHeight>=chatOutput.scrollHeight-50;chatOutput.appendChild(d);if(scroll){chatOutput.scrollTop=chatOutput.scrollHeight;}}
function addLogMessage(l,m,mod=''){const le=document.createElement('div');const lu=l.toUpperCase();le.classList.add(`log-${l.toLowerCase()}`);const tm=new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit',second:'2-digit'});le.textContent=`[${tm}] [${lu}] ${mod?'['+mod+'] ':''}${m}`;logOutput.appendChild(le);const MAX_LOG=150;while(logOutput.children.length>MAX_LOG){logOutput.removeChild(logOutput.firstChild);}logOutput.scrollTop=logOutput.scrollHeight;}
function handleWebSocketMessage(data){switch(data.type){case 'chat':addChatMessage(data.platform,data.user,data.text,data.timestamp);break;case 'platform_status':updateStatus(data.platform,data.status.toLowerCase(),data.status);addLogMessage('INFO',`Platform [${data.platform.toUpperCase()}]: ${data.status} ${data.message?'- '+data.message:''}`);break;case 'log':addLogMessage(data.level,data.message,data.module);break;case 'status':addLogMessage('INFO',`Backend: ${data.message}`);generalStatus.textContent=`App Status: ${data.message}`;break;case 'error':addLogMessage('ERROR',`Backend Err: ${data.message}`);generalStatus.textContent=`App Status: Error - ${data.message}`;break;case 'pong':console.log("Pong.");break;case 'current_settings':populateSettingsForm(data.payload||{});break;default:console.warn("Unknown WS type:",data.type,data);addLogMessage('WARN',`Unknown WS type: ${data.type}`);}}
function connectWebSocket(){clearTimeout(reconnectTimer);if(socket&&(socket.readyState===WebSocket.OPEN||socket.readyState===WebSocket.CONNECTING))return;const wsProto=window.location.protocol==='https:'?'wss:':'ws:';const wsUrl=`${wsProto}//localhost:8000/ws/dashboard`;console.log(`Connecting WS: ${wsUrl}`);updateStatus('ws','connecting','Connecting...');addLogMessage('INFO',`Connecting WS...`);generalStatus.textContent="Connecting...";socket=new WebSocket(wsUrl);socket.onopen=()=>{console.log('WS Open');updateStatus('ws','connected','Online');addLogMessage('INFO','WS connected.');reconnectAttempts=0;generalStatus.textContent="Connected";requestSettings();};socket.onmessage=(e)=>{try{const d=JSON.parse(e.data);handleWebSocketMessage(d);}catch(err){console.error("WS Parse Err:",err);addLogMessage("ERROR","Bad WS msg.");}};socket.onclose=(e)=>{console.log(`WS Closed: ${e.code}`);updateStatus('ws','disconnected',`Offline`);addLogMessage('WARN',`WS closed (${e.code}).`);generalStatus.textContent="Disconnected";socket=null;if(reconnectAttempts<MAX_RECONNECT_ATTEMPTS){reconnectAttempts++;const delay=Math.min(RECONNECT_DELAY_BASE*Math.pow(1.5,reconnectAttempts-1),30000);console.log(`WS Reconnect ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay/1000}s...`);addLogMessage('INFO',`Attempt reconnect (${reconnectAttempts})...`);reconnectTimer=setTimeout(connectWebSocket,delay);}else{console.error("WS Max reconnects.");addLogMessage('ERROR',"Max WS reconnects.");generalStatus.textContent="Connection Failed";}};socket.onerror=(err)=>{console.error('WS Error:',err);updateStatus('ws','error','Error');addLogMessage('ERROR','WS connection error.');};}
function sendStreamerInput(){const t=streamerInput.value.trim();if(!t)return;if(socket&&socket.readyState===WebSocket.OPEN){const m={type:"streamer_input",text:t};try{socket.send(JSON.stringify(m));streamerInput.value='';addLogMessage('INFO',`Sent: "${t.substring(0,50)}..."`);}catch(e){console.error("WS Send Err:",e);addLogMessage('ERROR',`Send fail: ${e.message}`);}}else{addLogMessage('ERROR',"Cannot send: WS closed.");}}
sendButton.addEventListener('click',sendStreamerInput);streamerInput.addEventListener('keypress',(e)=>{if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();sendStreamerInput();}});clearButton.addEventListener('click',()=>{chatOutput.innerHTML='';addLogMessage('INFO',"Chat display cleared.");});
tabButtons.forEach(b=>{b.addEventListener('click',()=>{const tab=b.getAttribute('data-tab');tabButtons.forEach(btn=>btn.classList.remove('active'));tabContents.forEach(c=>c.classList.remove('active'));b.classList.add('active');document.querySelector(`.tab-content[data-tab-content="${tab}"]`).classList.add('active');if(tab==='settings'){requestSettings();}});});
function requestSettings(){if(socket&&socket.readyState===WebSocket.OPEN){console.log("Requesting settings...");socket.send(JSON.stringify({type:"request_settings"}));}else{showSettingsStatus("Cannot load: WS closed.",true);}}
function populateSettingsForm(s){console.log("Populating settings:",s);twitchForm.elements['TWITCH_NICK'].value=s.TWITCH_NICK||'';twitchForm.elements['TWITCH_TOKEN'].placeholder=s.TWITCH_TOKEN?'********':'oauth:xxxx';twitchForm.elements['TWITCH_TOKEN'].value='';twitchForm.elements['TWITCH_CLIENT_ID'].value=s.TWITCH_CLIENT_ID||'';twitchForm.elements['TWITCH_CHANNELS'].value=s.TWITCH_CHANNELS||'';youtubeForm.elements['YOUTUBE_API_KEY'].value=s.YOUTUBE_API_KEY||'';youtubeForm.elements['YOUTUBE_CLIENT_SECRETS_FILE'].value=s.YOUTUBE_CLIENT_SECRETS_FILE||'';youtubeForm.elements['YOUTUBE_LIVE_CHAT_ID'].value=s.YOUTUBE_LIVE_CHAT_ID||'';xForm.elements['X_BEARER_TOKEN'].value=s.X_BEARER_TOKEN||'';xForm.elements['X_API_KEY'].value=s.X_API_KEY||'';xForm.elements['X_API_SECRET'].placeholder=s.X_API_SECRET?'********':'Enter Secret';xForm.elements['X_API_SECRET'].value='';xForm.elements['X_ACCESS_TOKEN'].value=s.X_ACCESS_TOKEN||'';xForm.elements['X_ACCESS_SECRET'].placeholder=s.X_ACCESS_SECRET?'********':'Enter Secret';xForm.elements['X_ACCESS_SECRET'].value='';xForm.elements['X_HASHTAG_OR_MENTION'].value=s.X_HASHTAG_OR_MENTION||'';showSettingsStatus("Settings loaded (secrets hidden). Enter new values to update.",false);}
async function saveSettings(formEl){const formData=new FormData(formEl);const dataToSend={};let hasChanges=false;formData.forEach((value,key)=>{const inputEl=formEl.elements[key];const isSecret=(inputEl.type==='password');if(value!==''){dataToSend[key]=value;hasChanges=true;}else if(isSecret&&inputEl.placeholder&&!inputEl.placeholder.includes('********')){/*If placeholder wasn't masked, user cleared it - maybe send null?*/}});if(!hasChanges){showSettingsStatus("No changes entered to save.",false);return;}console.log("Saving:",Object.keys(dataToSend));showSettingsStatus("Saving...",false);try{const response=await fetch('/api/settings',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(dataToSend)});const result=await response.json();if(response.ok){showSettingsStatus(result.message||"Saved!",false);formEl.reset();requestSettings();}else{showSettingsStatus(`Error: ${result.detail||response.statusText}`,true);}}catch(error){console.error("Save Settings Err:",error);showSettingsStatus(`Network error: ${error.message}`,true);}}
twitchForm.addEventListener('submit',(e)=>{e.preventDefault();saveSettings(e.target);});youtubeForm.addEventListener('submit',(e)=>{e.preventDefault();saveSettings(e.target);});xForm.addEventListener('submit',(e)=>{e.preventDefault();saveSettings(e.target);});
controlButtons.forEach(b=>{b.addEventListener('click',async(e)=>{const srv=e.target.getAttribute('data-service');const cmd=e.target.getAttribute('data-command');showSettingsStatus(`Sending '${cmd}' to ${srv}...`,false);try{const response=await fetch(`/api/control/${srv}/${cmd}`,{method:'POST'});const result=await response.json();if(response.ok){showSettingsStatus(result.message||`Cmd sent.`,false);}else{showSettingsStatus(`Error: ${result.detail||response.statusText}`,true);}}catch(error){console.error("Control Err:",error);showSettingsStatus(`Network error: ${error.message}`,true);}});});
document.addEventListener('DOMContentLoaded',()=>{addLogMessage('INFO','Dashboard UI Initialized.');connectWebSocket();});
EOF
check_success "Failed writing static/main.js"
# --- Create basic .gitignore ---
echo "    Creating .gitignore..."
cat << EOF > .gitignore
venv/
__pycache__/
*.pyc
*.pyo
*.pyd
.env
*.db
*.db-journal
*.sqlite3
client_secret.json
*.log
*.tmp
# Data directory (contains secrets!)
/${DATA_DIR}/
# IDE files
.vscode/
*.sublime-project
*.sublime-workspace
# OS files
.DS_Store
# Coverage
.coverage
htmlcov/
EOF
check_success "Failed writing .gitignore"
# --- Create basic README ---
echo "    Creating README.md..."
cat << EOF > README.md
# FoSBot - Multi-Platform Stream Chatbot (Webapp Config Version)

Handles chat aggregation and bot commands. API keys and settings are configured via the web UI after launching. Data is stored in JSON files in the \`./${DATA_DIR}\` directory.

## Setup

1.  Run the setup script: \`./setup_fosbot.sh\`
2.  Follow prompts (may require sudo for Homebrew/Xcode tools).
3.  Follow the final manual steps printed by the script (Load browser extension, configure its selectors).

## Running

1.  Activate the virtual environment: \`source venv/bin/activate\`
2.  Start the backend server: \`uvicorn app.main:app --reload --host localhost\`
3.  Open the dashboard in your browser (usually \`http://localhost:8000\`).
4.  Navigate to the **Settings** tab in the dashboard.
5.  Enter your API keys, tokens, bot/channel names, etc., and click "Save" for each section.
6.  Use the "Service Control" buttons (e.g., "Start Twitch") on the Settings tab to activate the platform connections.
7.  Configure the Whatnot extension selectors via its popup while on a Whatnot page.

EOF
check_success "Failed writing README.md"

# --- [10/10] Create Basic Placeholder Icons ---
echo ""; echo "[10/10] Creating placeholder icons..."
if command_exists convert; then ICON_COLOR="rgba(60,80,100,0.8)"; convert -size 16x16 xc:"${ICON_COLOR}" whatnot_extension/icons/icon16.png; convert -size 48x48 xc:"${ICON_COLOR}" whatnot_extension/icons/icon48.png; convert -size 128x128 xc:"${ICON_COLOR}" whatnot_extension/icons/icon128.png; check_success "Failed creating icons."; echo "    Placeholder icons created.";
else echo "    WARNING: ImageMagick 'convert' not found. Skipping icon creation. Create dummy icons manually in whatnot_extension/icons/."; fi

# --- Finish ---
echo ""; echo ""; echo "--- //////////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ ---"
echo "--- //    SETUP COMPLETE - CONFIGURE VIA WEB UI NEXT!          \\\\ ---"
echo "--- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\////////////////////////////////// ---"
echo ""; echo "Project files and base dependencies are set up for Phase 1 (Webapp Config / JSON Storage)."
echo ""; echo "NEXT STEPS:"; echo ""
echo "1.  **LOAD BROWSER EXTENSION:**"; echo "    Open Browser -> Extensions -> Dev Mode ON -> Load Unpacked -> Select './whatnot_extension' dir."
echo ""; echo "2.  **RUN THE BACKEND (Activate venv first!):**"; echo "    In Terminal (in ${PROJECT_DIR_NAME} dir):"; echo "    source venv/bin/activate"; echo "    uvicorn app.main:app --reload --host localhost"
echo ""; echo "3.  **ACCESS DASHBOARD & CONFIGURE:**"; echo "    Open browser to: http://localhost:8000"; echo "    Go to the 'Settings' tab."; echo "    Enter your API keys/tokens/settings for Twitch, YouTube, X."; echo "    Place 'client_secret.json' at the path you enter for YouTube."; echo "    Click 'Save' for each section."
echo ""; echo "4.  **START SERVICES:**"; echo "    On the 'Settings' tab, use the 'Start Twitch', 'Start YouTube', etc., buttons."
echo "    Watch the terminal logs and dashboard status indicators."
echo ""; echo "5.  **CONFIGURE WHATNOT SELECTORS (CRITICAL for Whatnot):**"; echo "    Go to a Whatnot stream page."; echo "    Click extension icon -> 'Configure Selectors' -> Follow overlay -> Save."; echo "    (Repeat when Whatnot chat breaks)"
echo ""; echo "--- Your bot is ready for configuration via the dashboard! ---"; echo ""
exit 0


========================= File: README.md =========================

# FoSBot - Multi-Platform Stream Chatbot (Webapp Config Version)

Handles chat aggregation and bot commands. API keys and settings are configured via the web UI after launching. Data is stored in JSON files in the `./data` directory.

## Setup

1.  Run the setup script: `./setup_fosbot.sh`
2.  Follow prompts (may require sudo for Homebrew/Xcode tools).
3.  Follow the final manual steps printed by the script (Load browser extension, configure its selectors).

## Running

1.  Activate the virtual environment: `source venv/bin/activate`
2.  Start the backend server: `uvicorn app.main:app --reload --host localhost`
3.  Open the dashboard in your browser (usually `http://localhost:8000`).
4.  Navigate to the **Settings** tab in the dashboard.
5.  Enter your API keys, tokens, bot/channel names, etc., and click "Save" for each section.
6.  Use the "Service Control" buttons (e.g., "Start Twitch") on the Settings tab to activate the platform connections.
7.  Configure the Whatnot extension selectors via its popup while on a Whatnot page.



========================= File: client_secret_425804375982-i89gr34gji82l1ahm5juskqbhe6c6899.apps.googleusercontent.com.json =========================

{"installed":{"client_id":"425804375982-i89gr34gji82l1ahm5juskqbhe6c6899.apps.googleusercontent.com","project_id":"fosbot-456712","auth_uri":"https://accounts.google.com/o/oauth2/auth","token_uri":"https://oauth2.googleapis.com/token","auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs","client_secret":"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","redirect_uris":["http://localhost"]}}


========================= File: app/events.py =========================

from dataclasses import dataclass, field; from typing import Optional, Dict, Any, List; import datetime # List added
@dataclass
class InternalChatMessage: platform: str; user: str; text: str; channel: Optional[str]=None; user_id: Optional[str]=None; display_name: Optional[str]=None; timestamp: datetime.datetime=field(default_factory=datetime.datetime.utcnow); message_id: Optional[str]=None; is_command: bool=False; raw_data: Dict[str,Any]=field(default_factory=dict)
@dataclass
class BotResponse: target_platform: str; text: str; target_channel: Optional[str]=None; reply_to_user: Optional[str]=None; reply_to_message_id: Optional[str]=None
class Event: pass
@dataclass
class ChatMessageReceived(Event): message: InternalChatMessage
@dataclass
class CommandDetected(Event): command: str; args: list[str]; source_message: InternalChatMessage
@dataclass
class BotResponseToSend(Event): response: BotResponse
@dataclass
class StreamerInputReceived(Event): text: str
@dataclass
class BroadcastStreamerMessage(Event): text: str
@dataclass
class PlatformStatusUpdate(Event): platform: str; status: str; message: Optional[str]=None
@dataclass
class LogMessage(Event): level: str; message: str; module: Optional[str]=None
@dataclass
class SettingsUpdated(Event): keys_updated: List[str] # List of keys changed
@dataclass
class ServiceControl(Event): service_name: str; command: str # 'start', 'stop', 'restart'
@dataclass
class GameEvent(Event): pass # Base for game events


========================= File: app/__init__.py =========================



========================= File: app/main.py =========================

# --- File: app/main.py --- START ---
import asyncio
import logging
import signal
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
from pathlib import Path
import sys

# --- Core Imports ---
from app.core.config import logger # Use configured logger
from app.core.event_bus import event_bus

# --- API Routers ---
from app.apis import ws_endpoints, settings_api
from app.apis import auth_api # <-- Import the new auth router

# --- Service Control & Setup ---
from app.services.twitch_service import start_twitch_service_task, stop_twitch_service
from app.services.youtube_service import start_youtube_service_task, stop_youtube_service
from app.services.x_service import start_x_service_task, stop_x_service
from app.services.whatnot_bridge import start_whatnot_bridge_task, stop_whatnot_bridge
from app.services.chat_processor import setup_chat_processor
from app.services.dashboard_service import setup_dashboard_service_listeners
from app.services.streamer_command_handler import setup_streamer_command_handler

# --- Events ---
from app.events import ServiceControl

# --- Global State ---
background_tasks = set()
_service_tasks_map: dict[str, asyncio.Task | None] = {} # Store running tasks by name

# --- Service Control Mapping ---
service_control_map = {
    "twitch": {"start": start_twitch_service_task, "stop": stop_twitch_service},
    "youtube": {"start": start_youtube_service_task, "stop": stop_youtube_service},
    "x": {"start": start_x_service_task, "stop": stop_x_service},
    "whatnot": {"start": start_whatnot_bridge_task, "stop": stop_whatnot_bridge},
}

async def handle_service_control(event: ServiceControl):
    """Handles start/stop/restart commands for services via the event bus."""
    logger.info(f"Handling control: '{event.command}' for '{event.service_name}'...")
    control_funcs = service_control_map.get(event.service_name)
    current_task = _service_tasks_map.get(event.service_name)

    if not control_funcs:
        logger.error(f"No control functions found for service '{event.service_name}'.")
        return

    start_func = control_funcs.get("start")
    stop_func = control_funcs.get("stop")

    if event.command == "stop":
        if current_task and not current_task.done():
            logger.info(f"Stopping running/starting service '{event.service_name}'...")
            if stop_func: await stop_func()
            else: logger.warning(f"No stop function defined but task exists for '{event.service_name}'.")
        else:
             logger.info(f"Service '{event.service_name}' not running, no stop action needed.")
        _service_tasks_map[event.service_name] = None # Clear task reference after stop

    elif event.command == "start":
        if current_task and not current_task.done():
            logger.warning(f"Service '{event.service_name}' already running or starting.")
            return

        if start_func:
            logger.info(f"Executing start for '{event.service_name}'...")
            new_task = start_func() # Start func handles async task creation
            if new_task and isinstance(new_task, asyncio.Task):
                _service_tasks_map[event.service_name] = new_task
                background_tasks.add(new_task)
                # Remove task from set when it finishes (success, error, or cancel)
                new_task.add_done_callback(background_tasks.discard)
                logger.info(f"Task for '{event.service_name}' started and added to background tasks.")
            elif new_task is None:
                 logger.warning(f"Start function for '{event.service_name}' did not return a task (disabled/failed pre-check?).")
            else:
                 logger.error(f"Start function for '{event.service_name}' returned invalid object: {type(new_task)}")
        else:
            logger.warning(f"No start function defined for '{event.service_name}'.")

    elif event.command == "restart":
        logger.info(f"Executing restart for '{event.service_name}'...")
        if current_task and not current_task.done():
            logger.info("...stopping existing service first.")
            if stop_func:
                 await stop_func()
                 await asyncio.sleep(1) # Brief pause for graceful shutdown
            else: logger.warning(f"No stop function for restart of '{event.service_name}'.")
        else:
             logger.info("...service not running, attempting start.")

        _service_tasks_map[event.service_name] = None # Ensure old task ref is cleared

        if start_func:
            logger.info("...starting new service instance.")
            new_task = start_func()
            if new_task and isinstance(new_task, asyncio.Task):
                _service_tasks_map[event.service_name] = new_task
                background_tasks.add(new_task)
                new_task.add_done_callback(background_tasks.discard)
                logger.info(f"Task for '{event.service_name}' added after restart.")
            elif new_task is None: logger.warning(f"Start function for '{event.service_name}' did not return task on restart.")
            else: logger.error(f"Start function '{event.service_name}' returned invalid object on restart: {type(new_task)}")
        else:
            logger.warning(f"No start function available for restart of '{event.service_name}'.")

# --- Lifespan Manager ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handles application startup and shutdown events."""
    logger.info("--- Application startup sequence initiated ---")
    logger.info("Starting event bus worker..."); await event_bus.start()
    logger.info("Setting up event listeners...");
    setup_chat_processor()
    setup_dashboard_service_listeners()
    setup_streamer_command_handler()
    event_bus.subscribe(ServiceControl, handle_service_control) # Subscribe control handler
    logger.info("Service control handler subscribed.")
    logger.info("Services will start automatically IF valid OAuth tokens are found.")
    # Attempt to start services that might have stored tokens (e.g., Twitch)
    # They will check tokens internally and connect if valid/refreshed.
    initial_start_tasks = [
        handle_service_control(ServiceControl(service_name="twitch", command="start")),
        handle_service_control(ServiceControl(service_name="youtube", command="start")),
        handle_service_control(ServiceControl(service_name="x", command="start")),
        # Don't auto-start Whatnot bridge usually
    ]
    await asyncio.gather(*initial_start_tasks, return_exceptions=True)
    logger.info("--- Application startup complete. Running! ---")

    yield # App runs

    logger.info("--- Application shutdown sequence initiated ---")
    logger.info("Stopping platform services (sending stop commands)...");
    stop_tasks = [
        handle_service_control(ServiceControl(service_name=name, command="stop"))
        for name in service_control_map.keys()
    ]
    await asyncio.gather(*stop_tasks, return_exceptions=True)

    logger.info("Waiting briefly..."); await asyncio.sleep(2);
    logger.info("Stopping event bus worker..."); await event_bus.stop()

    # Final check for lingering tasks (should be handled by stop commands now)
    if background_tasks:
        logger.warning(f"Attempting final cancellation for {len(background_tasks)} lingering background tasks...")
        for task in list(background_tasks):
            if task and not task.done(): task.cancel()
        try:
            await asyncio.wait_for(asyncio.gather(*background_tasks, return_exceptions=True), timeout=5.0)
            logger.debug("Gathered cancelled background tasks successfully.")
        except asyncio.TimeoutError: logger.error("Timeout waiting for background tasks to cancel.")
        except Exception as e: logger.exception(f"Error during final gathering of cancelled tasks: {e}")
    else: logger.info("No lingering background tasks found during shutdown.")
    logger.info("--- Application shutdown complete. ---")


# --- FastAPI App Creation ---
app = FastAPI(
    title="FoSBot (OAuth Config)",
    version="0.4.0-oauth", # Updated version
    lifespan=lifespan
)

# --- Mount Routers ---
app.include_router(auth_api.router) # Add the Auth router
app.include_router(ws_endpoints.router, prefix="/ws")
app.include_router(settings_api.router, prefix="/api", tags=["Settings & Control"])

# --- Mount Static Files ---
STATIC_DIR = "static"
static_path = Path(STATIC_DIR)
if not static_path.is_dir():
    logger.error(f"Static files directory '{STATIC_DIR}' not found at {static_path.resolve()}. Dashboard UI unavailable.")
else:
    try:
        app.mount("/", StaticFiles(directory=STATIC_DIR, html=True), name="static")
        logger.info(f"Mounted static files for dashboard UI from './{STATIC_DIR}'.")
    except Exception as e:
        logger.exception(f"Failed to mount static files directory './{STATIC_DIR}': {e}")

# --- Direct Run (Debugging Only) ---
if __name__ == "__main__":
    import uvicorn
    from app.core.config import WS_HOST, WS_PORT, LOG_LEVEL
    logger.warning("Running via main.py is intended for debugging ONLY.")
    uvicorn.run("app.main:app", host=WS_HOST, port=WS_PORT, log_level=LOG_LEVEL.lower(), reload=True) # Enable reload for dev
# --- File: app/main.py --- END ---


========================= File: app/apis/settings_api.py =========================

import logging; from fastapi import APIRouter, HTTPException, Body; from pydantic import BaseModel, Field; from typing import Dict, Any, List, Optional
from app.core.json_store import load_settings, save_settings; from app.core.event_bus import event_bus; from app.events import SettingsUpdated, ServiceControl
logger = logging.getLogger(__name__); router = APIRouter()

class AllSettings(BaseModel): # Use one model for easier updates
    TWITCH_TOKEN: Optional[str] = None; TWITCH_CLIENT_ID: Optional[str] = None; TWITCH_NICK: Optional[str] = None; TWITCH_CHANNELS: Optional[str] = None
    YOUTUBE_API_KEY: Optional[str] = None; YOUTUBE_CLIENT_SECRETS_FILE: Optional[str] = None; YOUTUBE_LIVE_CHAT_ID: Optional[str] = None
    X_BEARER_TOKEN: Optional[str] = None; X_API_KEY: Optional[str] = None; X_API_SECRET: Optional[str] = None; X_ACCESS_TOKEN: Optional[str] = None; X_ACCESS_SECRET: Optional[str] = None; X_HASHTAG_OR_MENTION: Optional[str] = None
    # Add non-secret app settings if needed: COMMAND_PREFIX: Optional[str] = None etc.

@router.get("/settings", response_model=Dict[str, Any], summary="Get Current Settings (Secrets Masked)")
async def get_current_settings():
    settings = await load_settings(); safe_settings = {};
    for key, value in settings.items(): safe_settings[key] = "********" if ("TOKEN" in key or "SECRET" in key or "PASSWORD" in key) and value else value
    return safe_settings

@router.post("/settings", status_code=200, summary="Update Settings")
async def update_settings_endpoint(new_settings: AllSettings = Body(...)):
    logger.info("Received POST /api/settings"); current_settings = await load_settings(); updated_keys = []; update_data = new_settings.dict(exclude_unset=True)
    if not update_data: raise HTTPException(status_code=400, detail="No settings provided.")
    for key, value in update_data.items():
        # Update if value is provided (not None) AND is different from current or key doesn't exist
        # Treat empty string "" as a valid value to set (e.g., clearing optional field)
        if value is not None and current_settings.get(key) != value:
            current_settings[key] = value; updated_keys.append(key); logger.debug(f"Setting '{key}' updated.")
    if not updated_keys: logger.info("No actual changes to settings."); return {"message": "No settings changed."}
    if await save_settings(current_settings): logger.info(f"Settings updated for keys: {updated_keys}"); event_bus.publish(SettingsUpdated(keys_updated=updated_keys)); return {"message": f"Settings updated successfully ({', '.join(updated_keys)}). Service restart may be needed."}
    else: raise HTTPException(status_code=500, detail="Failed to save settings.")

@router.post("/control/{service_name}/{command}", status_code=200, summary="Control Services (start/stop/restart)")
async def control_service(service_name: str, command: str):
     allowed_services = ["twitch", "youtube", "x", "whatnot"]; allowed_commands = ["start", "stop", "restart"]; service_name = service_name.lower(); command = command.lower()
     if service_name not in allowed_services: raise HTTPException(status_code=404, detail="Service not found.")
     if command not in allowed_commands: raise HTTPException(status_code=400, detail="Invalid command.")
     logger.info(f"Control command '{command}' for service '{service_name}' received."); event_bus.publish(ServiceControl(service_name=service_name, command=command)); return {"message": f"'{command}' command sent to '{service_name}' service."}



========================= File: app/apis/__init__.py =========================



========================= File: app/apis/ws_endpoints.py =========================

# --- File: app/apis/ws_endpoints.py --- START ---
import logging
import json
import asyncio
from fastapi import APIRouter, WebSocket, WebSocketDisconnect

# --- Imports ---
# Service functions to handle the actual WebSocket logic
from app.services.dashboard_service import handle_dashboard_websocket # Corrected import during error sequence

# Event bus and related events for communication
from app.core.event_bus import event_bus
from app.events import InternalChatMessage, ChatMessageReceived

# Whatnot bridge handler (will be implemented later)
# from app.services.whatnot_bridge import handle_whatnot_websocket

# --- Setup ---
logger = logging.getLogger(__name__)
router = APIRouter()

# --- WebSocket Endpoints ---

@router.websocket("/dashboard")
async def websocket_dashboard_endpoint(websocket: WebSocket):
    """
    Handles WebSocket connections from the Streamer Dashboard UI.
    Delegates handling to the dashboard_service.
    """
    await handle_dashboard_websocket(websocket)

@router.websocket("/whatnot")
async def websocket_whatnot_endpoint(websocket: WebSocket):
    """
    Handles WebSocket connections from the Whatnot Browser Extension.
    Phase 1: Receives messages, parses basic info, publishes ChatMessageReceived.
    Does not process commands originating from Whatnot or send replies back yet.
    """
    client = f"{websocket.client.host}:{websocket.client.port}" if websocket.client else "Unknown Client"
    logger.info(f"Whatnot Extension client trying connection: {client}")
    await websocket.accept()
    logger.info(f"Whatnot Extension client connected: {client}")
    try:
        while True:
            # Wait indefinitely for a message from the extension
            data = await websocket.receive_text()
            logger.debug(f"Received raw data from Whatnot Ext {client}: {data}")

            # --- CORRECTED INDENTATION & LOGIC ---
            try: # This try block likely had wrong indentation initially
                # Parse the incoming JSON data
                payload = json.loads(data)

                # Basic validation and creation of internal message object
                # Assumes extension sends {'platform': 'whatnot', 'user': '...', 'text': '...'}
                if isinstance(payload, dict) and payload.get('platform') == 'whatnot':
                    user = payload.get('user', 'WN_UnknownUser')
                    text = payload.get('text', '')
                    user_id = payload.get('user_id') # Optional user ID

                    if user and text: # Ensure minimal useful data
                        # Create standardized internal message
                        # Timestamp added automatically by InternalChatMessage dataclass default_factory
                        msg = InternalChatMessage(
                            platform='whatnot',
                            user=user,
                            text=text,
                            user_id=str(user_id) if user_id else user, # Use ID if present
                            # Add other fields if extension provides them
                            raw_data=payload # Store original payload
                        )
                        # Publish the event for other services (like dashboard) to receive
                        event_bus.publish(ChatMessageReceived(message=msg))
                    else:
                         logger.warning(f"Invalid or incomplete payload structure from Whatnot Ext {client}: Missing user or text.")
                else:
                    logger.warning(f"Invalid payload format (not dict or wrong platform) from Whatnot Ext {client}: {payload}")

            except json.JSONDecodeError:
                logger.warning(f"Received non-JSON message from Whatnot Ext {client}: {data}")
            except Exception as e:
                # Catch errors during message processing within the loop
                logger.exception(f"Error processing message from Whatnot Ext {client}: {e}")
            # --- END CORRECTION ---

    except WebSocketDisconnect as e:
        # Log disconnect code and reason if available
        logger.info(f"Whatnot Extension client {client} disconnected (Code: {e.code}, Reason: {e.reason}).")
    except Exception as e:
        # Catch other errors like connection closed unexpectedly
        logger.error(f"Unexpected error in Whatnot Extension WebSocket handler for {client}: {e}", exc_info=True)
    finally:
         # Optional cleanup if needed when a connection closes
         logger.debug(f"Closing Whatnot Extension connection handler for {client}")

# Placeholder for Whatnot Bridge Service handler if needed later
# async def handle_whatnot_websocket(websocket: WebSocket):
#     # This might be managed by a dedicated service in whatnot_bridge.py instead
#     logger.warning("Whatnot Bridge WebSocket handling not fully implemented.")
#     await websocket.accept()
#     await websocket.send_text("Whatnot Bridge Placeholder Connected")
#     await websocket.close()
# --- File: app/apis/ws_endpoints.py --- END ---


========================= File: app/apis/auth_api.py =========================

# --- File: app/apis/auth_api.py --- START ---
import logging
import secrets # For generating secure state tokens
from urllib.parse import urlencode
# --- CORRECTED: Add missing imports from typing ---
from typing import Dict, Optional, Any
# --- End Correction ---
from fastapi import APIRouter, Depends, HTTPException, Request, Query
from fastapi.responses import RedirectResponse
import httpx # For making backend HTTP requests to token endpoints

# --- Configuration ---
from app.core.config import (
    TWITCH_APP_CLIENT_ID, TWITCH_APP_CLIENT_SECRET, APP_SECRET_KEY
    # Import others as needed: YOUTUBE_APP_CLIENT_ID, etc.
)

# --- Token Storage ---
# Import necessary functions from json_store
from app.core.json_store import save_tokens, clear_tokens, get_setting, update_setting, load_tokens

# --- Event Bus ---
from app.core.event_bus import event_bus
from app.events import PlatformStatusUpdate, ServiceControl # To trigger service restart after auth

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth", tags=["Authentication"])

# --- Constants ---
# Ensure this exactly matches what you registered on Twitch Dev Console
TWITCH_REDIRECT_URI = "http://localhost:8000/auth/twitch/callback"
TWITCH_AUTHORIZATION_BASE_URL = "https://id.twitch.tv/oauth2/authorize"
TWITCH_TOKEN_URL = "https://id.twitch.tv/oauth2/token"
TWITCH_VALIDATE_URL = "https://id.twitch.tv/oauth2/validate" # To get user info
TWITCH_REVOKE_URL = "https://id.twitch.tv/oauth2/revoke"
# Define required scopes (permissions)
# See: https://dev.twitch.tv/docs/authentication/scopes/
TWITCH_SCOPES = [
    "chat:read",        # Read chat messages
    "chat:edit",        # Send chat messages
    "channel:read:subscriptions", # Example: Check subscriptions (add more as needed)
    # "user:read:email", # Example: Get user email (optional) - Removed for simplicity unless needed
]

# Simple in-memory store for the state parameter (replace with something more robust if needed)
# Key: state_token, Value: platform (e.g., 'twitch') - Cleared after use
_oauth_state_store: Dict[str, str] = {}

# --- Helper Functions ---
def generate_state() -> str:
    """Generates a secure random state token."""
    return secrets.token_urlsafe(32)

def verify_state(received_state: str, platform: str) -> bool:
    """Verifies the received state token against the store and clears it."""
    stored_platform = _oauth_state_store.pop(received_state, None)
    if stored_platform == platform:
        return True
    logger.error(f"OAuth state mismatch! Expected platform '{platform}' for state '{received_state}', but found '{stored_platform}'. Possible CSRF attack.")
    return False

async def get_twitch_user_info(access_token: str) -> Optional[Dict[str, Any]]:
    """Gets user ID and login using a validated access token."""
    # Ensure Client ID is available, as it's required for validate endpoint header
    if not TWITCH_APP_CLIENT_ID:
        logger.error("Cannot validate Twitch token: TWITCH_APP_CLIENT_ID is not configured.")
        return None

    headers = {
        "Authorization": f"OAuth {access_token}",
        # Twitch Validate endpoint requires Client-ID in header now (unlike older methods)
        "Client-ID": TWITCH_APP_CLIENT_ID
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(TWITCH_VALIDATE_URL, headers=headers)
            response.raise_for_status() # Raise exception for 4xx/5xx status
            data = response.json()

            # Validate response structure and ensure token belongs to our app
            if (data.get("user_id") and data.get("login") and
                data.get("client_id") == TWITCH_APP_CLIENT_ID):
                logger.info(f"Token validated successfully for user {data['login']} ({data['user_id']})")
                # Return only the necessary info for storage/use
                return {
                    "user_id": data["user_id"],
                    "user_login": data["login"],
                    "scopes": data.get("scopes", []) # Include granted scopes
                 }
            else:
                logger.error(f"Twitch validation response missing data or client_id mismatch: {data}")
                return None
        except httpx.RequestError as e:
            logger.error(f"HTTP request error validating Twitch token: {e}")
            return None
        except httpx.HTTPStatusError as e:
            # Handle specific errors like 401 Unauthorized (invalid token)
            if e.response.status_code == 401:
                 logger.warning(f"Twitch token validation failed (401 Unauthorized): {e.response.text}")
            else:
                 logger.error(f"HTTP status error validating Twitch token: {e.response.status_code} - {e.response.text}")
            return None
        except Exception as e:
            logger.exception(f"Unexpected error validating Twitch token: {e}")
            return None

# --- Twitch Auth Endpoints ---

@router.get("/twitch/login")
async def twitch_login():
    """
    Initiates the Twitch OAuth flow by redirecting the user to Twitch.
    """
    if not TWITCH_APP_CLIENT_ID:
        logger.critical("Cannot initiate Twitch login: TWITCH_APP_CLIENT_ID is not configured in .env")
        raise HTTPException(status_code=500, detail="Twitch application credentials not configured on server.")

    state = generate_state()
    _oauth_state_store[state] = "twitch" # Store state with platform identifier
    logger.debug(f"Generated Twitch OAuth state: {state}")

    params = {
        "client_id": TWITCH_APP_CLIENT_ID,
        "redirect_uri": TWITCH_REDIRECT_URI,
        "response_type": "code", # Request authorization code
        "scope": " ".join(TWITCH_SCOPES), # Space-separated scopes
        "state": state,
        # "force_verify": "true", # Optional: Usually leave false for better UX
    }
    auth_url = f"{TWITCH_AUTHORIZATION_BASE_URL}?{urlencode(params)}"
    logger.info(f"Redirecting user to Twitch authorization URL...")
    return RedirectResponse(url=auth_url, status_code=307) # Use 307 Temporary Redirect

@router.get("/twitch/callback")
async def twitch_callback(code: Optional[str] = Query(None), state: Optional[str] = Query(None), scope: Optional[str] = Query(None), error: Optional[str] = Query(None), error_description: Optional[str] = Query(None)):
    """
    Handles the redirect back from Twitch after user authorization.
    Exchanges the code for tokens and stores them.
    """
    logger.info(f"Received Twitch callback. State: {state}, Code: {'***' if code else 'N/A'}, Error: {error}")

    # --- Verify State First ---
    if not state or not verify_state(state, "twitch"):
        raise HTTPException(status_code=400, detail="Invalid or missing OAuth state parameter. Potential CSRF attack.")

    if error:
        logger.error(f"Twitch OAuth error on callback: {error} - {error_description}")
        # Redirect back to dashboard with error message? Maybe store error in session?
        # For now, raise exception shown to user.
        raise HTTPException(status_code=400, detail=f"Twitch Auth Error: {error_description or error}")

    if not code:
         raise HTTPException(status_code=400, detail="Missing authorization code from Twitch.")

    if not TWITCH_APP_CLIENT_ID or not TWITCH_APP_CLIENT_SECRET:
        logger.critical("Cannot exchange code: Twitch App credentials missing on backend.")
        raise HTTPException(status_code=500, detail="Twitch application credentials not configured on server.")

    # --- Exchange code for tokens ---
    token_params = {
        "client_id": TWITCH_APP_CLIENT_ID,
        "client_secret": TWITCH_APP_CLIENT_SECRET,
        "code": code,
        "grant_type": "authorization_code",
        "redirect_uri": TWITCH_REDIRECT_URI,
    }

    async with httpx.AsyncClient() as client:
        try:
            logger.debug("Requesting access token from Twitch...")
            response = await client.post(TWITCH_TOKEN_URL, data=token_params)
            response.raise_for_status() # Check for HTTP errors
            token_data = response.json()
            logger.info("Successfully received tokens from Twitch.")
            # Expected keys: 'access_token', 'refresh_token', 'expires_in', 'scope', 'token_type'

            # --- Get User Info (using the new token) ---
            user_info = await get_twitch_user_info(token_data['access_token'])
            if user_info:
                 # Add user_id, user_login, and validated scopes to token data before saving
                 token_data['user_id'] = user_info['user_id']
                 token_data['user_login'] = user_info['user_login']
                 token_data['scope'] = user_info['scopes'] # Use scopes confirmed by validation
                 logger.info(f"Validated token for Twitch user: {user_info['user_login']} ({user_info['user_id']})")

                 # Update the bot's Nick setting to match the logged-in user
                 # This assumes the user logging in IS the bot account
                 if await update_setting("TWITCH_NICK", user_info['user_login']):
                     logger.info(f"Updated TWITCH_NICK setting to: {user_info['user_login']}")
                 else:
                     logger.error("Failed to update TWITCH_NICK setting.")

            else:
                 logger.error("Failed to validate token and get user info after successful token exchange.")
                 # Proceed with saving tokens, but log the validation failure. User might need to retry.
                 # You could raise an exception here to prevent saving unvalidated tokens if preferred.

            # --- Save Tokens ---
            if await save_tokens("twitch", token_data):
                logger.info("Twitch tokens saved successfully.")
                # Publish status update and trigger service restart via event
                event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connected', message=f"Authenticated as {token_data.get('user_login', 'Unknown')}"))
                event_bus.publish(ServiceControl(service_name="twitch", command="restart"))
            else:
                logger.error("Failed to save Twitch tokens to storage.")
                raise HTTPException(status_code=500, detail="Failed to save authentication tokens.")

        except httpx.RequestError as e:
            logger.error(f"HTTP request error exchanging Twitch code: {e}")
            raise HTTPException(status_code=503, detail=f"Error contacting Twitch token endpoint: {e}")
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP status error exchanging Twitch code: {e.response.status_code} - {e.response.text}")
            raise HTTPException(status_code=e.response.status_code, detail=f"Error from Twitch token endpoint: {e.response.text}")
        except Exception as e:
            logger.exception(f"Unexpected error during Twitch token exchange or saving: {e}")
            raise HTTPException(status_code=500, detail=f"Internal server error during authentication.")

    # Redirect back to the main dashboard page upon success
    return RedirectResponse(url="/?auth_success=twitch", status_code=303) # Use 303 See Other for POST-redirect-GET pattern

@router.post("/twitch/logout", status_code=200) # Use POST for logout action
async def twitch_logout():
    """ Clears Twitch tokens and attempts to revoke them. """
    logger.info("Processing Twitch logout request.")
    tokens = await load_tokens("twitch")
    access_token = tokens.get("access_token") if tokens else None

    # Always clear local tokens
    cleared_local = await clear_tokens("twitch")
    if not cleared_local:
        logger.error("Failed to clear local Twitch tokens from storage.")
        # Continue with revocation attempt anyway, but maybe return a different status?

    # Attempt to revoke token on Twitch side
    if access_token and TWITCH_APP_CLIENT_ID:
        revoke_params = {
            "client_id": TWITCH_APP_CLIENT_ID,
            "token": access_token
        }
        async with httpx.AsyncClient() as client:
            try:
                logger.debug("Attempting to revoke Twitch token...")
                response = await client.post(TWITCH_REVOKE_URL, data=revoke_params)
                if 200 <= response.status_code < 300:
                    logger.info("Successfully revoked Twitch token.")
                else:
                     # Log warning but don't necessarily fail the whole logout if revoke fails
                     logger.warning(f"Failed to revoke Twitch token. Status: {response.status_code}, Response: {response.text}")
            except Exception as e:
                 logger.error(f"Error during Twitch token revocation request: {e}")
    else:
        logger.info("Skipping Twitch token revocation (no access token or client ID found).")

    # Publish status update and trigger service stop via event
    event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnected', message="Logged out"))
    event_bus.publish(ServiceControl(service_name="twitch", command="stop"))

    # Return success even if revocation failed, as local tokens are cleared
    return {"message": "Twitch logout processed. Local tokens cleared."}


# --- Add Placeholders for YouTube and X ---

@router.get("/{platform}/login", status_code=501)
async def platform_login_nyi(platform: str):
    if platform in ["youtube", "x"]:
         raise HTTPException(status_code=501, detail=f"{platform.capitalize()} OAuth login not implemented yet.")
    else:
         raise HTTPException(status_code=404, detail="Unknown platform.")

@router.get("/{platform}/callback", status_code=501)
async def platform_callback_nyi(platform: str):
     if platform in ["youtube", "x"]:
          raise HTTPException(status_code=501, detail=f"{platform.capitalize()} OAuth callback not implemented yet.")
     else:
          raise HTTPException(status_code=404, detail="Unknown platform.")

@router.post("/{platform}/logout", status_code=501)
async def platform_logout_nyi(platform: str):
    if platform in ["youtube", "x"]:
         raise HTTPException(status_code=501, detail=f"{platform.capitalize()} OAuth logout not implemented yet.")
    else:
         raise HTTPException(status_code=404, detail="Unknown platform.")

# --- File: app/apis/auth_api.py --- END ---


========================= File: app/core/config.py =========================

# --- File: app/core/config.py --- START ---
import os
from dotenv import load_dotenv
from pathlib import Path
import logging
import warnings

# Determine project root based on this file's location
project_root = Path(__file__).parent.parent.parent
env_path = project_root / '.env'

# Load .env file from project root
loaded_env = load_dotenv(dotenv_path=env_path, verbose=True)
if loaded_env:
    print(f"Loaded .env config from: {env_path}") # Use print as logger not setup yet
else:
    print(f"INFO: .env file not found at {env_path}. Using defaults/env vars.") # Use print

# --- Load General App Settings ---
COMMAND_PREFIX = os.getenv("COMMAND_PREFIX", "!")
WS_HOST = os.getenv("WS_HOST", "localhost")
WS_PORT = int(os.getenv("WS_PORT", "8000"))
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
DATA_DIR = Path(os.getenv("DATA_DIR", project_root / "data")) # Get data dir path

# --- Load OAuth Application Credentials ---
# These are for YOUR application, not the end-user
TWITCH_APP_CLIENT_ID = os.getenv("TWITCH_APP_CLIENT_ID")
TWITCH_APP_CLIENT_SECRET = os.getenv("TWITCH_APP_CLIENT_SECRET")
# Add placeholders for others later
# YOUTUBE_APP_CLIENT_ID = os.getenv("YOUTUBE_APP_CLIENT_ID")
# YOUTUBE_APP_CLIENT_SECRET = os.getenv("YOUTUBE_APP_CLIENT_SECRET")
# X_APP_CLIENT_ID = os.getenv("X_APP_CLIENT_ID")
# X_APP_CLIENT_SECRET = os.getenv("X_APP_CLIENT_SECRET")

# --- Load Security Keys ---
APP_SECRET_KEY = os.getenv("APP_SECRET_KEY")

# --- Basic Logging Setup ---
log_level_int = getattr(logging, LOG_LEVEL, logging.INFO)
logging.basicConfig(
    level=log_level_int,
    format='%(asctime)s - %(name)s [%(levelname)s] - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
# Quiet down noisy libraries unless debugging them specifically
logging.getLogger("twitchio").setLevel(logging.WARNING)
logging.getLogger("websockets").setLevel(logging.WARNING)
logging.getLogger("google").setLevel(logging.WARNING)
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("watchfiles").setLevel(logging.WARNING) # Uvicorn reloader log

# Logger for this config module itself
logger = logging.getLogger(__name__)
logger.setLevel(log_level_int)

logger.info(f"Config Loaded: Prefix='{COMMAND_PREFIX}', WS={WS_HOST}:{WS_PORT}, LogLevel={LOG_LEVEL}, DataDir='{DATA_DIR}'")

# --- Configuration Validation ---
# Validate essential non-secret config
if not APP_SECRET_KEY:
    warnings.warn("CRITICAL SECURITY WARNING: APP_SECRET_KEY is not set in .env or environment variables. OAuth state validation will be insecure. Please generate a strong key.", RuntimeWarning)
    # In a real app, you might want to exit here if the secret key is missing.
    # For local dev with this single-user app, a warning might suffice initially,
    # but it's crucial for preventing CSRF.
    APP_SECRET_KEY = "insecure_default_key_replace_me" # Fallback for dev ONLY

# Validate Twitch App Credentials (only if planning to use Twitch OAuth)
if not TWITCH_APP_CLIENT_ID:
     logger.warning("Twitch OAuth configuration missing: TWITCH_APP_CLIENT_ID not set.")
if not TWITCH_APP_CLIENT_SECRET:
     logger.warning("Twitch OAuth configuration missing: TWITCH_APP_CLIENT_SECRET not set.")


# Ensure data directory exists
try:
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    logger.info(f"Data directory verified/created: {DATA_DIR.resolve()}")
except OSError as e:
    logger.error(f"CRITICAL: Could not create/access data directory '{DATA_DIR}': {e}")
    # Application might still run but storage will fail.

# NOTE: User API Tokens are NOT loaded here. They are loaded on demand
# by services from the JSON store after the OAuth flow.
# --- File: app/core/config.py --- END ---


========================= File: app/core/json_store.py =========================

# --- File: app/core/json_store.py --- START ---
import json
import logging
import aiofiles
import asyncio
from pathlib import Path
from typing import Dict, Any, Optional, Union
from collections import defaultdict
import time # Import time for expiry calculations

# Ensure config is imported correctly if needed (for DATA_DIR)
from app.core.config import DATA_DIR

logger = logging.getLogger(__name__)

# Use defaultdict for the locks for simplicity
_file_locks: Dict[Path, asyncio.Lock] = defaultdict(asyncio.Lock)

async def load_json_data(filename: str, default: Any = None) -> Optional[Any]:
    """
    Loads data asynchronously from a JSON file in the data directory.
    Handles file not found, empty files, and JSON decode errors gracefully.
    Uses asyncio.Lock per file to prevent read/write race conditions.
    """
    filepath = DATA_DIR / f"{filename}.json"
    lock = _file_locks[filepath] # Get or create lock for this file path
    # logger.debug(f"Acquiring lock for READ: {filepath}") # Too noisy for default DEBUG
    async with lock:
        # logger.debug(f"Lock acquired for READ: {filepath}")
        try:
            if not filepath.is_file():
                logger.warning(f"JSON file not found: {filepath}. Returning default.")
                return default
            # Use aiofiles for async file operations
            async with aiofiles.open(filepath, mode='r', encoding='utf-8') as f:
                content = await f.read()
            # Handle empty file case
            if not content:
                 logger.warning(f"JSON file is empty: {filepath}. Returning default.")
                 return default
            # Decode JSON
            data = json.loads(content)
            # logger.info(f"Successfully loaded data from {filepath}") # Log only on success if needed
            return data
        except json.JSONDecodeError:
            logger.error(f"Error decoding JSON from file: {filepath}. Returning default.", exc_info=True)
            return default
        except Exception as e:
            logger.error(f"Unexpected error loading JSON file {filepath}: {e}", exc_info=True)
            return default
        finally:
            pass # logger.debug(f"Released lock for READ: {filepath}")

async def save_json_data(filename: str, data: Any) -> bool:
    """
    Saves data asynchronously to a JSON file in the data directory.
    Uses a temporary file and atomic rename for safer writes.
    Uses asyncio.Lock per file to prevent write races.
    """
    filepath = DATA_DIR / f"{filename}.json"
    lock = _file_locks[filepath] # Get or create lock
    task_id_part = id(asyncio.current_task()) if asyncio.current_task() else 'notask'
    temp_filepath = filepath.with_suffix(f'.{task_id_part}.tmp')

    # logger.debug(f"Acquiring lock for WRITE: {filepath}")
    async with lock:
        # logger.debug(f"Lock acquired for WRITE: {filepath}")
        try:
            async with aiofiles.open(temp_filepath, mode='w', encoding='utf-8') as f:
                await f.write(json.dumps(data, indent=4, ensure_ascii=False))
            temp_filepath.rename(filepath)
            logger.info(f"Successfully saved data to {filepath}")
            return True
        except Exception as e:
            logger.error(f"Error saving JSON file {filepath}: {e}", exc_info=True)
            if temp_filepath.exists():
                try: temp_filepath.unlink(); logger.debug(f"Removed temporary file {temp_filepath} after error.")
                except OSError as unlink_e: logger.error(f"Error removing temporary file {temp_filepath}: {unlink_e}")
            return False
        finally:
             pass # logger.debug(f"Released lock for WRITE: {filepath}")

# --- Specific Settings and Data File Management ---
SETTINGS_FILE = "settings"
CHECKINS_FILE = "checkins"
COUNTERS_FILE = "counters"

# --- Token Management ---
# Structure within settings.json:
# {
#   "twitch_access_token": "...",
#   "twitch_refresh_token": "...",
#   "twitch_expires_at": 1678886400.123, # Timestamp (time.time() + expires_in)
#   "twitch_scopes": ["chat:read", "chat:edit"],
#   "twitch_user_id": "12345",
#   "twitch_user_login": "fos_gamers",
#   "youtube_access_token": "...",
#   ... other settings like COMMAND_PREFIX ...
# }

async def save_tokens(platform: str, token_data: Dict[str, Any]) -> bool:
    """
    Saves OAuth token data for a specific platform into settings.json.
    Expects token_data to contain 'access_token', 'refresh_token', 'expires_in', 'scope'.
    Also saves 'user_id' and 'user_login' if provided.
    """
    logger.info(f"Attempting to save tokens for platform: {platform}")
    settings = await load_settings() # Load current settings
    if settings is None: settings = {}

    if 'access_token' not in token_data:
        logger.error(f"Missing 'access_token' in token_data for {platform}. Cannot save.")
        return False

    settings[f"{platform}_access_token"] = token_data['access_token']
    # Refresh token might not always be provided (e.g., during refresh itself)
    if 'refresh_token' in token_data:
        settings[f"{platform}_refresh_token"] = token_data['refresh_token']
    if 'expires_in' in token_data:
        # Calculate expiry timestamp (seconds since epoch)
        expires_at = time.time() + int(token_data['expires_in']) - 300 # Subtract 5 mins buffer
        settings[f"{platform}_expires_at"] = expires_at
    if 'scope' in token_data:
        # Scope might be a list or space-separated string depending on platform/library
        scopes = token_data['scope']
        if isinstance(scopes, str):
            scopes = scopes.split() # Split space-separated string into list
        settings[f"{platform}_scopes"] = scopes

    # Store optional user info if available (useful for display/logging)
    if 'user_id' in token_data:
        settings[f"{platform}_user_id"] = str(token_data['user_id'])
    if 'user_login' in token_data:
        settings[f"{platform}_user_login"] = token_data['user_login']

    logger.warning(f"Saving OAuth tokens for {platform} to plain JSON file. Ensure file permissions are secure.")
    return await save_settings(settings) # Save the modified settings dict

async def load_tokens(platform: str) -> Optional[Dict[str, Any]]:
    """Loads OAuth token data for a specific platform from settings.json."""
    settings = await load_settings()
    if not settings: return None

    token_info = {
        "access_token": settings.get(f"{platform}_access_token"),
        "refresh_token": settings.get(f"{platform}_refresh_token"),
        "expires_at": settings.get(f"{platform}_expires_at"),
        "scopes": settings.get(f"{platform}_scopes", []),
        "user_id": settings.get(f"{platform}_user_id"),
        "user_login": settings.get(f"{platform}_user_login"),
    }

    # Only return if access token exists
    if token_info["access_token"]:
        # Convert expires_at to float if it's not None
        if token_info["expires_at"] is not None:
             try: token_info["expires_at"] = float(token_info["expires_at"])
             except (ValueError, TypeError): token_info["expires_at"] = None # Invalidate if conversion fails
        return token_info
    else:
        logger.debug(f"No stored access token found for platform: {platform}")
        return None

async def clear_tokens(platform: str) -> bool:
    """Removes OAuth token data for a specific platform from settings.json."""
    logger.info(f"Clearing tokens for platform: {platform}")
    settings = await load_settings()
    if settings is None: return True # Nothing to clear

    keys_to_remove = [
        f"{platform}_access_token", f"{platform}_refresh_token",
        f"{platform}_expires_at", f"{platform}_scopes",
        f"{platform}_user_id", f"{platform}_user_login"
    ]
    updated = False
    for key in keys_to_remove:
        if key in settings:
            del settings[key]
            updated = True

    if updated:
        return await save_settings(settings)
    else:
        return True # No changes needed

# --- Generic Settings Management (Keep for other settings like COMMAND_PREFIX) ---
async def load_settings() -> Dict[str, Any]:
    """Loads the main application settings."""
    settings = await load_json_data(SETTINGS_FILE, default={})
    return settings if isinstance(settings, dict) else {}

async def save_settings(settings_data: Dict[str, Any]) -> bool:
    """Saves the main application settings."""
    return await save_json_data(SETTINGS_FILE, settings_data)

async def get_setting(key: str, default: Any = None) -> Any:
     """Convenience function to get a single non-token setting."""
     # Avoid using this for tokens, use load_tokens instead
     settings = await load_settings()
     return settings.get(key, default)

async def update_setting(key: str, value: Any) -> bool:
    """Updates a single non-token setting."""
    settings = await load_settings()
    if settings is None: settings = {}
    if settings.get(key) != value:
        settings[key] = value
        return await save_settings(settings)
    return True # No change needed

# --- Other Data Management (Unchanged) ---
async def load_checkins() -> Dict[str, Any]:
    """Loads check-in data."""
    checkins = await load_json_data(CHECKINS_FILE, default={})
    return checkins if isinstance(checkins, dict) else {}

async def save_checkins(data: Dict[str, Any]) -> bool:
    """Saves check-in data."""
    return await save_json_data(CHECKINS_FILE, data)

async def load_counters() -> Dict[str, int]:
    """Loads counter data, ensuring values are integers."""
    counters = await load_json_data(COUNTERS_FILE, default={})
    valid_counters = {}
    if isinstance(counters, dict):
        for k, v in counters.items():
            try: valid_counters[k] = int(v)
            except (ValueError, TypeError): logger.warning(f"Invalid value '{v}' for counter '{k}' in {COUNTERS_FILE}.json. Ignoring.")
    return valid_counters

async def save_counters(data: Dict[str, int]) -> bool:
    """Saves counter data."""
    return await save_json_data(COUNTERS_FILE, data)
# --- File: app/core/json_store.py --- END ---


========================= File: app/core/__init__.py =========================



========================= File: app/core/event_bus.py =========================

import asyncio
import logging
import sys # Import sys for exception info depth
from collections import defaultdict
from typing import Type, Callable, Dict, List, TypeVar, Coroutine, Any
# Ensure events.py is correctly located relative to core
from app.events import Event

logger = logging.getLogger(__name__)
T = TypeVar('T', bound=Event) # Type variable for events

class AsyncEventBus:
    def __init__(self):
        # Stores listeners: {EventType: [handler1, handler2, ...]}
        self._listeners: Dict[Type[Event], List[Callable[[T], Coroutine[Any, Any, None]]]] = defaultdict(list)
        # Set a max size for the queue to prevent unbounded memory growth if processing lags
        self._queue: asyncio.Queue = asyncio.Queue(maxsize=1000) # Adjust size as needed
        self._worker_task: asyncio.Task | None = None
        self._running = False # Flag to control the processing loop

    def subscribe(self, event_type: Type[T], handler: Callable[[T], Coroutine[Any, Any, None]]):
        """Subscribe an async handler to an event type."""
        # Ensure handler is actually an async function
        if not asyncio.iscoroutinefunction(handler):
            raise TypeError(f"Handler {getattr(handler, '__name__', repr(handler))} must be an async function (coroutine)")
        self._listeners[event_type].append(handler)
        logger.debug(f"Handler '{getattr(handler, '__name__', repr(handler))}' subscribed to {event_type.__name__}")

    def publish(self, event: Event):
        """Publish an event to the queue for async processing."""
        if not self._running:
            logger.warning(f"Event bus not running, discarding event: {type(event).__name__}")
            return
        try:
            # Use put_nowait to avoid blocking the publisher if queue is full
            self._queue.put_nowait(event)
            logger.debug(f"Event {type(event).__name__} published to queue (qsize: {self._queue.qsize()}).")
        except asyncio.QueueFull:
            # Log loudly if the queue is full, as events will be dropped
            logger.error(f"Event bus queue is FULL (maxsize={self._queue.maxsize})! Discarding event: {type(event).__name__}. "
                         f"Consider increasing queue size or ensuring event handlers are processing quickly enough.")

    async def _process_events(self):
        """Worker coroutine that processes events from the queue."""
        logger.info("Event bus processor task started.")
        # --- CORRECTED INDENTATION ---
        while self._running: # Loop continues as long as the running flag is True
            try:
                # Wait for an event from the queue
                event = await self._queue.get()

                # Handle potential sentinel value used during shutdown
                if event is None:
                    logger.debug("Received None sentinel, continuing shutdown check.")
                    continue # Go back to check self._running

                event_type = type(event)
                logger.debug(f"Processing event {event_type.__name__} from queue (qsize: {self._queue.qsize()}).")

                # Find all handlers for this event type (including handlers for parent classes)
                handlers_to_call = []
                for registered_type, handlers in self._listeners.items():
                    if isinstance(event, registered_type):
                        handlers_to_call.extend(handlers)

                if not handlers_to_call:
                    logger.debug(f"No listeners found for event type {event_type.__name__}")
                    self._queue.task_done() # Mark item as done even if no listeners
                    continue # Process next item

                # Execute all handlers concurrently using asyncio.gather
                # Name tasks for better debugging
                tasks = [
                    asyncio.create_task(
                        handler(event),
                        name=f"event_handler_{getattr(handler, '__name__', f'unknown_{id(handler)}')}_{event_type.__name__}"
                    )
                    for handler in handlers_to_call
                ]
                results = await asyncio.gather(*tasks, return_exceptions=True)

                # Log any exceptions that occurred within the handlers
                for i, result in enumerate(results):
                    if isinstance(result, Exception):
                        handler_name = getattr(handlers_to_call[i], '__name__', repr(handlers_to_call[i]))
                        # Log traceback only if log level is DEBUG for clarity
                        log_traceback = logger.isEnabledFor(logging.DEBUG)
                        logger.error(f"Exception in handler '{handler_name}' for event {event_type.__name__}: {result}", exc_info=log_traceback)

                self._queue.task_done() # Signal that this event has been processed

            except asyncio.CancelledError:
                # This happens when self.stop() is called
                logger.info("Event bus processing task cancelled.")
                break # Exit the while loop
            except Exception as e:
                # Catch-all for unexpected errors in the processing loop itself
                logger.exception(f"Unexpected error in event processing loop: {e}")
                # Avoid spinning on persistent errors; wait before retrying
                await asyncio.sleep(1)
        # --- END INDENTATION CORRECTION ---
        logger.info("Event bus processor task stopped.")

    async def start(self):
        """Start the background event processing worker."""
        if self._running:
            logger.warning("Event bus already running.")
            return
        self._running = True
        # Create the task with a descriptive name
        self._worker_task = asyncio.create_task(self._process_events(), name="EventBusProcessor")
        logger.info("Event bus started.")

    async def stop(self):
        """Stop the background event processing worker gracefully."""
        if not self._running or not self._worker_task or self._worker_task.done():
            logger.info("Event bus already stopped or was never started.")
            return

        logger.info("Stopping event bus worker...")
        self._running = False # Signal the loop to stop processing new items

        # Add a sentinel to potentially unblock the worker if it's waiting on an empty queue
        try:
            self._queue.put_nowait(None)
        except asyncio.QueueFull:
             logger.warning("Event queue full during shutdown initiation.")
             # Shutdown will still proceed when worker is cancelled

        # Cancel the worker task
        if not self._worker_task.done():
             self._worker_task.cancel()

        # Wait for the task to finish (handles CancelledError internally)
        try:
            await self._worker_task
            logger.info("Event bus worker stopped successfully.")
        except asyncio.CancelledError:
            # This is expected when we cancel it
            logger.info("Event bus worker stop confirmed (was cancelled).")
        except Exception as e:
             # Log any other error during shutdown wait
             logger.exception(f"Error during event bus worker shutdown wait: {e}")
        finally:
             self._worker_task = None # Clear task reference

# Create a single global instance (can be replaced with DI later if needed)
event_bus = AsyncEventBus()


========================= File: app/services/x_service.py =========================

import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate
async def run_x_service(): event_bus.publish(PlatformStatusUpdate(platform='x', status='disabled', message='Not implemented')); logger.warning("X/Twitter service NOT IMPLEMENTED."); await asyncio.sleep(3600*24)
async def stop_x_service(): logger.info("X/Twitter service stop called (stub).")
def start_x_service_task(): logger.info("X/Twitter service start called (stub)."); return None


========================= File: app/services/streamer_command_handler.py =========================

import logging
import datetime
# Ensure config and event bus are imported correctly
from app.core.config import COMMAND_PREFIX
from app.core.event_bus import event_bus
# Ensure events are imported correctly
from app.events import StreamerInputReceived, ChatMessageReceived, BroadcastStreamerMessage, InternalChatMessage

logger = logging.getLogger(__name__)

async def handle_streamer_input(event: StreamerInputReceived):
    """Handles text input from the streamer dashboard."""
    text = event.text.strip()
    if not text:
        logger.debug("Ignoring empty streamer input.")
        return # Ignore empty input

    logger.info(f"Processing streamer input: '{text[:100]}...'") # Log truncated

    if text.startswith(COMMAND_PREFIX):
        # Treat as an admin command
        logger.info("Streamer input detected as command.")
        # Create a standard message object for the command processor
        streamer_msg = InternalChatMessage(
            platform='streamer_admin', # Special identifier
            user='STREAMER',           # Fixed admin username
            text=text,                 # The raw command string
            channel='admin_console',   # Arbitrary channel name/identifier
            timestamp=datetime.datetime.utcnow(),
            raw_data={'is_admin_command': True} # Add metadata flag
        )
        # Publish event for chat processor to handle
        # This allows admin commands to use the same logic/registry
        event_bus.publish(ChatMessageReceived(message=streamer_msg))
    else:
        # Treat as a broadcast message
        logger.info("Streamer input detected as broadcast.")
        # Publish event for platform connectors to handle
        event_bus.publish(BroadcastStreamerMessage(text=text))

def setup_streamer_command_handler():
    """Subscribes the handler to the event bus."""
    event_bus.subscribe(StreamerInputReceived, handle_streamer_input)
    logger.info("Streamer Command Handler subscribed to events.")


========================= File: app/services/chat_processor.py =========================

import logging
import random
import datetime
import time # For cooldowns
from collections import defaultdict
from typing import Dict, Callable, Awaitable, Optional, Any

# Ensure core imports are correct
from app.core.config import COMMAND_PREFIX
from app.core.event_bus import event_bus
from app.events import ChatMessageReceived, CommandDetected, BotResponseToSend, BotResponse, LogMessage
# Use the generic JSON store functions
from app.core.json_store import load_json_data, save_json_data

logger = logging.getLogger(__name__)

# --- Constants for JSON filenames ---
CHECKINS_FILE = "checkins" # -> data/checkins.json
COUNTERS_FILE = "counters" # -> data/counters.json

# --- Command Handler Type ---
# Command handlers no longer need DB session for JSON version
CommandHandler = Callable[[CommandDetected], Awaitable[None]]
command_registry: Dict[str, CommandHandler] = {}

# --- Cooldowns ---
# { 'command_name': { 'user_key': last_used_timestamp } } # user_key is "platform:username"
user_cooldowns: Dict[str, Dict[str, float]] = defaultdict(dict)
# { 'command_name': last_used_timestamp }
global_cooldowns: Dict[str, float] = {}
# Cooldown durations (in seconds)
COMMAND_COOLDOWNS = {
    "default_user": 5.0,
    "default_global": 1.5, # Slightly lower default global?
    "checkin": 300.0,      # 5 min cooldown for checkin per user
    "seen": 10.0,
    "socials": 30.0,       # Limit spam for info commands
    "commands": 20.0,
    "uptime": 10.0,
    # Add specific cooldowns per command if needed
}

# Store bot start time for uptime command
start_time = datetime.datetime.utcnow()

# --- Helper to send reply ---
def send_reply(source_event: CommandDetected, text: str):
    """Creates and publishes a BotResponseToSend event."""
    # Basic validation
    if not source_event or not source_event.source_message:
        logger.error("send_reply called without valid source_event.")
        return
    msg = source_event.source_message
    if not msg.platform or not msg.user:
        logger.error(f"send_reply failed: Missing platform or user in source: {msg}")
        return

    # Construct the response object
    response = BotResponse(
        target_platform=msg.platform,
        target_channel=msg.channel, # Will be None for certain sources like admin
        text=text,
        reply_to_user=msg.user # Platform services can decide how to use this
    )
    # Publish the event for platform connectors to handle
    event_bus.publish(BotResponseToSend(response=response))
    logger.debug(f"Published BotResponseToSend to {msg.platform} channel {msg.channel} for user {msg.user}")

# --- Helper Time Delta Formatting ---
def format_timedelta_human(delta: datetime.timedelta) -> str:
    """Formats a timedelta into a human-readable string like '3d 4h' or '5m 10s'."""
    total_seconds = int(delta.total_seconds())
    secs = total_seconds # Use 'secs' alias for clarity

    if secs < 1: return "just now"

    days, remainder = divmod(secs, 86400) # 24 * 3600
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60) # 'seconds' now holds the final seconds part

    parts = []
    if days > 0:
        parts.append(f"{days}d")
    if hours > 0:
        parts.append(f"{hours}h")
    # Only show minutes if the duration is less than a day
    if minutes > 0 and days == 0:
        parts.append(f"{minutes}m")
    # Only show seconds if the duration is less than an hour (and no days)
    if seconds > 0 and days == 0 and hours == 0:
        parts.append(f"{seconds}s")

    if not parts:
        return "moments ago" # Or "0s ago" if preferred

    # Return the two most significant parts for brevity
    return " ".join(parts[:2]) + " ago"


# --- Command Handlers (Using JSON Store via helper functions) ---

async def handle_ping(event: CommandDetected):
    """Replies with a random pong variation."""
    replies = ["Pong!", "Ack!", f"Yes, {event.source_message.user}?", "I'm here!", "Present!"]
    send_reply(event, random.choice(replies))

async def handle_socials(event: CommandDetected):
    """Replies with predefined social media links."""
    # TODO: Load this text from a configuration source (e.g., settings.json via json_store)
    social_text = "Find the streamer here: Twitter - @FoS_Gamers | YouTube - /c/FoSGamers" # Example
    send_reply(event, social_text)

async def handle_lurk(event: CommandDetected):
    """Sends a thank you message for lurking."""
    send_reply(event, f"Thanks for the lurk, {event.source_message.user}! Enjoy the stream!")

async def handle_hype(event: CommandDetected):
    """Sends a hype message."""
    send_reply(event, "  _  HYPE! LET'S GOOOOO!   _ ")

async def handle_checkin(event: CommandDetected):
    """Records a user's check-in time using JSON store."""
    user = event.source_message.user
    platform = event.source_message.platform
    # Create a unique key, ensuring user_id is preferred and stringified
    user_id = str(event.source_message.user_id or user)
    checkin_key = f"{platform}:{user_id}" # Use platform:user_id as key is more robust
    now_iso = datetime.datetime.utcnow().isoformat() + "Z" # Add Z for UTC explicit

    # Load existing checkins (default to empty dict)
    checkins_data = await load_json_data(CHECKINS_FILE, default={})
    if checkins_data is None: checkins_data = {} # Ensure dict

    entry = checkins_data.get(checkin_key, {})
    entry['username'] = user # Always update username in case it changed
    entry['last_seen'] = now_iso
    if 'first_seen' not in entry:
        entry['first_seen'] = now_iso
        logger.info(f"First check-in for {user} ({user_id}) on {platform}.")
    else:
         logger.info(f"Updating check-in for {user} ({user_id}) on {platform}.")


    checkins_data[checkin_key] = entry

    # Save back to JSON
    if await save_json_data(CHECKINS_FILE, checkins_data):
        send_reply(event, f"{user} checked in!")
    else:
        send_reply(event, "Sorry, there was an error saving your check-in.")
        logger.error(f"Failed to save checkin data for {checkin_key}")

async def handle_seen(event: CommandDetected):
    """Looks up when a user was last seen checked in."""
    if not event.args:
        send_reply(event, f"Usage: {COMMAND_PREFIX}seen <username>")
        return

    target_user_lower = event.args[0].lstrip('@').lower()
    platform = event.source_message.platform
    checkin_record: Optional[Dict] = None

    checkins_data = await load_json_data(CHECKINS_FILE, default={})
    if checkins_data is None: checkins_data = {}

    # Find user case-insensitively by username (more user friendly)
    found_record = None
    found_username = None
    for key, record in checkins_data.items():
        try:
             stored_platform, _ = key.split(':', 1) # Key is platform:user_id
             stored_username = record.get('username', '')
             if stored_platform == platform and stored_username.lower() == target_user_lower:
                  found_record = record
                  found_username = stored_username # Use the correctly cased name
                  break # Found the user on this platform
        except (ValueError, TypeError): # Catch potential errors splitting key or accessing record
             logger.warning(f"Skipping invalid checkin key/record format: {key} / {record}")
        except KeyError:
             logger.warning(f"Skipping checkin record with missing username: {key}")


    if found_record and found_username:
        now = datetime.datetime.utcnow()
        try:
            # Parse ISO format string back to datetime
            # Handle potential 'Z' timezone indicator
            last_seen_str = found_record['last_seen'].rstrip('Z')
            first_seen_str = found_record['first_seen'].rstrip('Z')
            # Add timezone info if missing (assume UTC)
            last_seen_dt = datetime.datetime.fromisoformat(last_seen_str).replace(tzinfo=datetime.timezone.utc)
            first_seen_dt = datetime.datetime.fromisoformat(first_seen_str).replace(tzinfo=datetime.timezone.utc)
            # Ensure 'now' is also offset-aware for correct subtraction
            now_aware = now.replace(tzinfo=datetime.timezone.utc)

            last_seen_delta = now_aware - last_seen_dt
            first_seen_delta = now_aware - first_seen_dt
            last_seen_fmt = format_timedelta_human(last_seen_delta)
            first_seen_fmt = format_timedelta_human(first_seen_delta)
            send_reply(event, f"Found {found_username} on {platform}. First seen: {first_seen_fmt}. Last seen: {last_seen_fmt}.")
        except (ValueError, KeyError, TypeError) as e:
             logger.error(f"Error parsing stored timestamp for {found_username}: {e}", exc_info=True)
             send_reply(event, f"Sorry, couldn't read the stored time data for {event.args[0]}.")
    else:
        send_reply(event, f"Haven't seen {event.args[0]} check in on {platform} yet.")

async def handle_uptime(event: CommandDetected):
     """Reports how long the bot process has been running."""
     uptime_delta = datetime.datetime.utcnow() - start_time
     uptime_str = format_timedelta_human(uptime_delta).replace(" ago", "")
     if uptime_str == "just now": uptime_str = "a few moments"
     send_reply(event, f"Bot process uptime: {uptime_str}")

async def handle_inc_counter(event: CommandDetected):
    """Increments a counter named after the command itself (e.g., !death)."""
    counter_name = event.command # Use the command name (e.g., 'death') as the key
    counters = await load_counters() # Loads counters, ensures dict
    if counters is None: counters = {} # Safety check

    current_value = counters.get(counter_name, 0)
    new_value = current_value + 1
    counters[counter_name] = new_value

    if await save_counters(counters):
        send_reply(event, f"{counter_name.capitalize()} count increased to {new_value}!")
        logger.info(f"Counter '{counter_name}' incremented to {new_value} (JSON).")
    else:
        send_reply(event, f"Error saving counter '{counter_name}'.")
        logger.error(f"Failed to save counters data after incrementing {counter_name}")

async def handle_show_count(event: CommandDetected):
     """Shows the value of a specific counter."""
     if not event.args:
        send_reply(event, f"Usage: {COMMAND_PREFIX}showcount <counter_name>")
        return
     counter_name = event.args[0].lower()
     counters = await load_counters()
     if counters is None: counters = {}

     value = counters.get(counter_name, 0) # Default to 0 if not found
     send_reply(event, f"The current count for '{counter_name}' is: {value}")

async def handle_commands(event: CommandDetected):
    """Lists available commands."""
    # TODO: Implement permission checks later
    cmds = sorted([f"{COMMAND_PREFIX}{cmd}" for cmd in command_registry.keys()])
    reply_text = "Available commands: " + ", ".join(cmds)
    # Simple send, might need splitting for long lists later
    MAX_LEN = 480 # Leave some buffer for platform prefixes/etc.
    if len(reply_text) > MAX_LEN:
         send_reply(event, reply_text[:MAX_LEN] + "...") # Truncate for now
    else:
         send_reply(event, reply_text)


# --- Register Commands ---
def register_command(name: str, handler: CommandHandler, user_cooldown: Optional[float]=None, global_cooldown: Optional[float]=None):
    """Registers a command handler with optional cooldowns."""
    command_registry[name.lower()] = handler
    # Store cooldowns effectively
    cd_key_user = f"{name.lower()}_user"
    cd_key_global = f"{name.lower()}_global"
    if user_cooldown is not None: COMMAND_COOLDOWNS[cd_key_user] = user_cooldown
    if global_cooldown is not None: COMMAND_COOLDOWNS[cd_key_global] = global_cooldown
    logger.debug(f"Command '{name}' registered. User CD: {COMMAND_COOLDOWNS.get(cd_key_user)}, Global CD: {COMMAND_COOLDOWNS.get(cd_key_global)}")

# Register Phase 1 commands
register_command("ping", handle_ping)
register_command("socials", handle_socials, user_cooldown=30)
register_command("lurk", handle_lurk)
register_command("hype", handle_hype, user_cooldown=10, global_cooldown=3)
register_command("checkin", handle_checkin, user_cooldown=COMMAND_COOLDOWNS.get("checkin", 300))
register_command("seen", handle_seen, user_cooldown=COMMAND_COOLDOWNS.get("seen", 10))
register_command("uptime", handle_uptime, global_cooldown=5)
register_command("commands", handle_commands, user_cooldown=20)
# Register counter commands - use command name as counter key
register_command("death", handle_inc_counter)
register_command("win", handle_inc_counter)
register_command("fail", handle_inc_counter) # Example
register_command("showcount", handle_show_count)
# TODO: Add !setcounter command with permissions


# --- Main Processing Logic ---
async def process_chat_message(event: ChatMessageReceived):
    """Processes incoming chat messages from the event bus to check for commands."""
    msg = event.message
    if not msg or not msg.text or not msg.user:
        logger.debug("Ignoring empty/invalid message event.")
        return

    # Check for command prefix
    if msg.text.startswith(COMMAND_PREFIX):
        parts = msg.text.split()
        command_name = parts[0][len(COMMAND_PREFIX):].lower()
        args = parts[1:]

        # Ignore commands from Whatnot in Phase 1 for stability
        if msg.platform == 'whatnot':
            logger.debug(f"Ignoring command '{command_name}' from Whatnot user {msg.user}")
            return # Ignore Whatnot commands for now

        handler = command_registry.get(command_name)
        if handler:
            cmd_event = CommandDetected(command=command_name, args=args, source_message=msg)
            now = time.monotonic() # Use monotonic clock for reliable time differences
            is_admin = msg.platform == 'streamer_admin'
            # Use a consistent user key for cooldowns, platform:username is decent
            user_key = f"{msg.platform}:{msg.user.lower()}" # Lowercase username for consistency

            # Check Global Cooldown
            global_cd_key = command_name + "_global"
            global_cd = COMMAND_COOLDOWNS.get(global_cd_key, COMMAND_COOLDOWNS["default_global"])
            last_global_use = global_cooldowns.get(command_name, 0)
            if not is_admin and now < last_global_use + global_cd:
                remaining = (last_global_use + global_cd) - now
                logger.info(f"Cmd '{command_name}' on global CD ({remaining:.1f}s left). User: {user_key}")
                # send_reply(cmd_event, f"Command {command_name} is cooling down ({remaining:.1f}s left).") # Optional: notify user
                return # Exit

            # Check User Cooldown
            user_cd_key = command_name + "_user"
            user_cd = COMMAND_COOLDOWNS.get(user_cd_key, COMMAND_COOLDOWNS["default_user"])
            last_user_use = user_cooldowns[command_name].get(user_key, 0)
            if not is_admin and now < last_user_use + user_cd:
                 remaining = (last_user_use + user_cd) - now
                 logger.info(f"Cmd '{command_name}' on user CD for {user_key} ({remaining:.1f}s left).")
                 # send_reply(cmd_event, f"You need to wait {remaining:.1f}s to use {command_name} again.") # Optional: notify user
                 return # Exit

            # --- Cooldowns passed ---
            logger.info(f"Executing command: '{command_name}' for {user_key}")

            # Update cooldown timestamps BEFORE executing
            global_cooldowns[command_name] = now
            user_cooldowns[command_name][user_key] = now

            # Execute the handler
            try:
                # Pass only the event, no DB session needed for JSON version
                await handler(cmd_event)
            except Exception as e:
                logger.exception(f"Error executing command handler for '{command_name}': {e}")
                try: # Try sending an error reply
                    send_reply(cmd_event, f"Oops! Error running '{command_name}'.")
                except Exception: pass # Ignore reply errors

        # --- Handle Unknown Command ---
        else:
             if msg.platform != 'streamer_admin': # Don't reply to streamer's typos
                 # Create event just for replying
                 cmd_event = CommandDetected(command=command_name, args=args, source_message=msg)
                 send_reply(cmd_event, f"Unknown command: '{command_name}'. Try {COMMAND_PREFIX}commands.")


# --- Service Setup ---
def setup_chat_processor():
    """Subscribes the main message processor to the event bus."""
    event_bus.subscribe(ChatMessageReceived, process_chat_message)
    logger.info("Chat Processor (JSON Storage) setup and subscribed to messages.")


========================= File: app/services/__init__.py =========================



========================= File: app/services/dashboard_service.py =========================

import logging
import json
import asyncio
from typing import List, Dict, Any, Optional # Added Optional
from fastapi import WebSocket, WebSocketDisconnect

from app.core.event_bus import event_bus
# Ensure correct import path for events
from app.events import ChatMessageReceived, StreamerInputReceived, PlatformStatusUpdate, LogMessage

logger = logging.getLogger(__name__)

class ConnectionManager:
    """Manages active WebSocket connections for the dashboard."""
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        logger.info("Dashboard Connection Manager initialized.")

    async def connect(self, websocket: WebSocket):
        """Accepts a new WebSocket connection and adds it to the list."""
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(f"Dashboard client connected: {websocket.client}")
        # Send initial status or welcome message
        try:
            await self.send_personal_message(json.dumps({"type":"status", "message":"Connected to backend!"}), websocket)
        except Exception:
             pass # Ignore if send fails immediately on connect

    def disconnect(self, websocket: WebSocket):
        """Removes a WebSocket connection from the list."""
        if websocket in self.active_connections:
            try:
                self.active_connections.remove(websocket)
                logger.info(f"Dashboard client disconnected: {websocket.client}")
            except ValueError:
                 # Already removed, ignore
                 pass

    async def send_personal_message(self, message: str, websocket: WebSocket):
        """Sends a message to a single specific WebSocket connection."""
        if websocket in self.active_connections:
            try:
                await websocket.send_text(message)
            except Exception as e:
                 # Common errors: WebSocketStateError if closed during send, ConnectionClosedOK
                 logger.warning(f"Failed to send personal message to client {websocket.client}: {e}")
                 # Disconnect on send error to clean up list
                 self.disconnect(websocket)

    async def broadcast(self, message: str):
        """Sends a message to all active WebSocket connections."""
        if not self.active_connections: return # Skip if no clients

        # Create a list of tasks to send messages concurrently
        # Iterate over a copy in case disconnect modifies the list during iteration
        tasks = [self.send_personal_message(message, connection) for connection in list(self.active_connections)]
        if tasks:
             # Wait for all send tasks to complete (or fail)
             # Using return_exceptions=True prevents one failed send from stopping others
             results = await asyncio.gather(*tasks, return_exceptions=True)
             # Log any errors that occurred during broadcast
             for result in results: # Iterate through results directly
                  if isinstance(result, Exception):
                       # Client info might be lost if disconnected, log generic error
                       logger.warning(f"Broadcast error during gather: {result}")


# Create a single instance of the manager
manager = ConnectionManager()

async def handle_dashboard_websocket(websocket: WebSocket):
    """Handles the lifecycle of a single dashboard WebSocket connection."""
    await manager.connect(websocket)
    try:
        while True:
            # Wait for a message from the client
            data = await websocket.receive_text()
            logger.debug(f"Received from dashboard client {websocket.client}: {data}")
            try:
                # Attempt to parse the message as JSON
                message_data = json.loads(data)
                msg_type = message_data.get("type")

                # Process based on message type
                if msg_type == "streamer_input":
                    text = message_data.get("text", "")
                    if text:
                        # Publish event for backend processing (delegating the work)
                        event_bus.publish(StreamerInputReceived(text=text))
                        # Optionally send confirmation back to *this* client
                        await manager.send_personal_message(json.dumps({"type": "status", "message": "Input received."}), websocket)
                    else:
                        logger.warning("Received empty streamer_input text.")
                        await manager.send_personal_message(json.dumps({"type": "error", "message": "Cannot send empty input."}), websocket)
                elif msg_type == "ping":
                    # Respond to keepalive pings from frontend
                    await manager.send_personal_message(json.dumps({"type":"pong"}), websocket)
                elif msg_type == "request_settings":
                     # Handle request from UI to get current settings
                     from app.core.json_store import load_settings # Import late to avoid potential cycles
                     settings = await load_settings()
                     # IMPORTANT: Mask secrets before sending to frontend
                     safe_settings = {}
                     for key, value in settings.items():
                          safe_settings[key] = "********" if ("TOKEN" in key or "SECRET" in key or "PASSWORD" in key) and value else value
                     await manager.send_personal_message(json.dumps({"type": "current_settings", "payload": safe_settings}), websocket)
                else:
                     logger.warning(f"Received unknown message type from dashboard: {msg_type}")
                     await manager.send_personal_message(json.dumps({"type": "error", "message": f"Unknown type: {msg_type}"}), websocket)

            except json.JSONDecodeError:
                logger.warning(f"Received non-JSON message from dashboard: {data}")
                await manager.send_personal_message(json.dumps({"type": "error", "message": "Invalid JSON format."}), websocket)
            except Exception as e:
                 logger.exception(f"Error processing message from dashboard client {websocket.client}: {e}")
                 # Send a generic error back to the client
                 try:
                      await manager.send_personal_message(json.dumps({"type": "error", "message": "Backend error processing your request."}), websocket)
                 except Exception:
                      pass # Avoid error loops if sending fails

    except WebSocketDisconnect:
        logger.info(f"Dashboard client {websocket.client} disconnected cleanly.")
    except Exception as e:
        # Handle other potential exceptions during receive_text or connection handling
        logger.error(f"Dashboard client {websocket.client} unexpected error: {e}", exc_info=True)
    finally:
        # Ensure disconnect cleanup happens regardless of how the loop exits
        manager.disconnect(websocket)


# --- Event Handlers to push info FROM the backend TO the dashboard ---
# These functions are subscribed to the event bus elsewhere (in main.py or setup)

async def push_chat_to_dashboard(event: ChatMessageReceived):
    """Formats and broadcasts chat messages to all connected dashboards."""
    if not isinstance(event, ChatMessageReceived): return # Type guard
    msg = event.message
    # Format the message clearly
    # formatted_msg = f"[{msg.platform.upper()}] {msg.user}: {msg.text}" # Frontend handles formatting now
    # Create a structured payload for the frontend JS
    payload = json.dumps({
        "type": "chat",
        "platform": msg.platform,
        "user": msg.user,
        "text": msg.text,
        "timestamp": msg.timestamp.isoformat() if msg.timestamp else None
    })
    await manager.broadcast(payload)

async def push_status_to_dashboard(event: PlatformStatusUpdate):
    """Broadcasts platform connection status updates to dashboards."""
    if not isinstance(event, PlatformStatusUpdate): return
    payload = json.dumps({
        "type": "platform_status",
        "platform": event.platform,
        "status": event.status, # e.g., 'connected', 'disconnected', 'error', 'disabled'
        "message": event.message or "" # Optional extra info
    })
    await manager.broadcast(payload)

async def push_log_to_dashboard(event: LogMessage):
    """Broadcasts important log messages (Warning/Error) to dashboards."""
    if not isinstance(event, LogMessage): return
    # Only push certain levels to avoid flooding UI
    if event.level in ["WARNING", "ERROR", "CRITICAL"]:
         payload = json.dumps({
             "type": "log",
             "level": event.level,
             "message": event.message,
             "module": event.module or "Unknown"
         })
         await manager.broadcast(payload)

# This setup function is called from main.py during startup
def setup_dashboard_service_listeners():
    """Subscribes the necessary handlers to the event bus."""
    event_bus.subscribe(ChatMessageReceived, push_chat_to_dashboard)
    event_bus.subscribe(PlatformStatusUpdate, push_status_to_dashboard)
    event_bus.subscribe(LogMessage, push_log_to_dashboard) # Display important logs
    logger.info("Dashboard Service event listeners subscribed.")


========================= File: app/services/youtube_service.py =========================

import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate
async def run_youtube_service(): event_bus.publish(PlatformStatusUpdate(platform='youtube', status='disabled', message='Not implemented')); logger.warning("YouTube service NOT IMPLEMENTED."); await asyncio.sleep(3600*24) # Sleep long time
async def stop_youtube_service(): logger.info("YouTube service stop called (stub).")
def start_youtube_service_task(): logger.info("YouTube service start called (stub)."); return None # Return None as no task created


========================= File: app/services/twitch_service.py =========================

# --- File: app/services/twitch_service.py --- START ---
import logging
import asyncio
import time
from twitchio.ext import commands # This import was failing initially
from twitchio import Client, Chatter, Channel, errors as twitchio_errors # Import errors
from collections import defaultdict
import datetime # Keep datetime import

# Use settings store instead of direct config import for secrets
from app.core.json_store import get_setting, load_settings
from app.core.event_bus import event_bus
from app.events import InternalChatMessage, ChatMessageReceived, BotResponseToSend, BotResponse, PlatformStatusUpdate, SettingsUpdated, ServiceControl, LogMessage

logger = logging.getLogger(__name__)

# Module level state for the service
_STATE = {
    "task": None,       # The asyncio Task running run_twitch_service
    "instance": None,   # The TwitchBot instance
    "running": False,   # Control flag for the main run loop
    "connected": False, # Actual connection status
    "settings": {}      # Cache for loaded credentials
}
# Define _run_task globally for start/stop functions
_run_task: asyncio.Task | None = None

class TwitchBot(commands.Bot):
    """Custom Twitch Bot class extending twitchio."""

    def __init__(self, token, nick, client_id, channels):
        self.initial_channels_list = [ch.strip().lower() for ch in channels if ch.strip()]
        if not self.initial_channels_list:
             logger.warning("TwitchBot initialized with no channels.")

        # Ensure token starts with oauth:
        if token and not token.startswith('oauth:'):
             token = f'oauth:{token}'

        super().__init__(
            token=token,
            client_id=client_id,
            nick=nick.lower(),
            prefix=None, # We are not using twitchio's command handling
            initial_channels=self.initial_channels_list
        )
        self._closing = False
        self._response_queue = asyncio.Queue(maxsize=100)
        self._sender_task: asyncio.Task | None = None
        logger.debug(f"TwitchBot instance created for nick '{self.nick}'.")

    async def event_ready(self):
        """Called once when the bot connects successfully."""
        global _STATE
        logger.info(f'Twitch Bot logged in as | {self.nick} ({self.user_id})')
        if self.connected_channels:
             logger.info(f'Connected to: {", ".join(ch.name for ch in self.connected_channels)}')
        else:
             logger.warning(f"Twitch Bot connected but failed to join channels: {self.initial_channels_list}.")
             # Check if initial_channels is the issue vs. channel names
             if not self.initial_channels_list:
                 logger.error("CRITICAL: No channels were provided to TwitchIO at init!")


        _STATE["connected"] = True
        self._closing = False
        event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connected'))

        if self._sender_task is None or self._sender_task.done():
             self._sender_task = asyncio.create_task(self._message_sender(), name=f"TwitchSender_{self.nick}")
             logger.info("Twitch message sender task started.")

        # Subscribe to outgoing responses ONLY when ready
        event_bus.subscribe(BotResponseToSend, self.queue_response) # Use instance method

    async def event_message(self, message):
        """Processes incoming chat messages."""
        if message.echo or self._closing or not message.author or not message.channel:
            return

        logger.debug(f"Twitch Raw: {message.raw_data}")
        logger.info(f"Twitch <{message.channel.name}> {message.author.name}: {message.content}")
        timestamp = message.timestamp.replace(tzinfo=None) if message.timestamp else datetime.datetime.utcnow()
        internal_msg = InternalChatMessage(
            platform='twitch', user=message.author.name, text=message.content, channel=message.channel.name,
            user_id=str(message.author.id), display_name=message.author.display_name, timestamp=timestamp,
            message_id=message.id, raw_data={'tags': message.tags or {}, 'is_mod': message.author.is_mod, 'is_subscriber': message.author.is_subscriber}
        )
        event_bus.publish(ChatMessageReceived(message=internal_msg))

    async def event_join(self, channel: Channel, user: Chatter):
        """Called when a user joins a channel the bot is in."""
        if user.name.lower() != self.nick: logger.debug(f"{user.name} joined #{channel.name}")

    async def event_part(self, channel: Channel, user: Chatter):
        """Called when a user leaves a channel the bot is in."""
        if user.name.lower() != self.nick: logger.debug(f"{user.name} left #{channel.name}")

    async def event_error(self, error: Exception, data: str = None):
        """Handles errors reported by the twitchio library."""
        global _STATE
        # Log less verbosely by default, provide more context
        error_name = type(error).__name__
        logger.error(f"Twitch Bot event_error received: {error_name} - {error}", exc_info=False)
        log_traceback = logger.isEnabledFor(logging.DEBUG)

        # Specific handling for authentication failures
        if isinstance(error, twitchio_errors.AuthenticationError) or 'Login authentication failed' in str(error) or 'invalid nick' in str(error).lower():
             logger.critical("Twitch login failed. Check TWITCH_TOKEN (needs 'oauth:' prefix) and TWITCH_NICK in settings.")
             event_bus.publish(PlatformStatusUpdate(platform='twitch', status='auth_error', message='Login failed - Check Credentials'))
             _STATE["running"] = False # Signal the run loop to stop retrying this config
        else:
             # Log full traceback for other unexpected errors if debugging
             if log_traceback: logger.exception(f"Full traceback for Twitch error:")
             event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"{error_name}: {error}"))

    async def event_close(self):
         """Called when the bot disconnects for any reason."""
         global _STATE
         logger.warning(f"Twitch Bot connection closed (Instance: {id(self)}).")
         _STATE["connected"] = False
         if self._sender_task and not self._sender_task.done(): self._sender_task.cancel()
         if not self._closing: # Only publish if not initiated by custom_shutdown
              event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnected'))
              # Reconnect is handled by the run_twitch_service loop

    def queue_response(self, event: BotResponseToSend): # Use instance method (self)
         """Puts valid Twitch responses onto the sending queue."""
         global _STATE # Still need global state for connected check
         if not _STATE.get("connected") or self._closing or event.response.target_platform != 'twitch': return
         logger.debug(f"Queueing Twitch response for channel {event.response.target_channel}")
         try: self._response_queue.put_nowait(event.response)
         except asyncio.QueueFull: logger.error("Twitch response queue FULL! Discarding message.")

    async def _message_sender(self):
         """Task that pulls messages from queue and sends with rate limiting."""
         global _STATE
         SEND_DELAY = 1.6; logger.info("Twitch message sender task running.")
         while _STATE.get("connected") and not self._closing:
              try:
                   response: BotResponse = await asyncio.wait_for(self._response_queue.get(), timeout=5.0)
                   target_channel_name = response.target_channel
                   if not target_channel_name: logger.warning("Skip Twitch: no target channel."); self._response_queue.task_done(); continue
                   channel = self.get_channel(target_channel_name)
                   if not channel: logger.error(f"Cannot send Twitch: Bot not in channel '{target_channel_name}'."); self._response_queue.task_done(); continue
                   text_to_send = response.text;
                   if response.reply_to_user: clean_user = response.reply_to_user.lstrip('@'); text_to_send = f"@{clean_user}, {text_to_send}"
                   try: logger.info(f"Sending Twitch to #{target_channel_name}: {text_to_send[:100]}..."); await channel.send(text_to_send); self._response_queue.task_done(); await asyncio.sleep(SEND_DELAY)
                   except ConnectionResetError: logger.error(f"ConnectionReset sending to #{target_channel_name}."); self._response_queue.task_done(); break # Exit sender loop
                   except twitchio_errors.TwitchIOException as tio_e: logger.error(f"TwitchIO Error sending: {tio_e}"); self._response_queue.task_done(); await asyncio.sleep(SEND_DELAY)
                   except Exception as send_e: logger.error(f"Failed send to #{target_channel_name}: {send_e}", exc_info=True); self._response_queue.task_done(); await asyncio.sleep(SEND_DELAY)
              except asyncio.TimeoutError: continue # No message in queue, check running state
              except asyncio.CancelledError: logger.info("Twitch message sender task cancelled."); break
              except Exception as e: logger.exception(f"Twitch sender loop error: {e}"); await asyncio.sleep(5)
         logger.warning("Twitch message sender task stopped.")

    async def custom_shutdown(self):
         """Initiates a graceful shutdown of this bot instance."""
         global _STATE
         if self._closing: return; logger.info(f"Initiating shutdown: TwitchBot {id(self)}..."); self._closing = True; _STATE["connected"] = False; event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disconnecting'))
         if self._sender_task and not self._sender_task.done():
              if not self._sender_task.cancelling(): logger.debug("Cancelling sender task..."); self._sender_task.cancel()
              try: await self._sender_task; logger.debug("Sender task cancelled.")
              except asyncio.CancelledError: logger.debug("Sender task confirmed cancelled.")
              except Exception as e: logger.error(f"Error awaiting cancelled sender: {e}")
              self._sender_task = None
         # Clear queue BEFORE closing connection
         while not self._response_queue.empty():
             try:
                 self._response_queue.get_nowait()
                 self._response_queue.task_done()
             except asyncio.QueueEmpty: break
         logger.debug("Response queue cleared.")
         logger.debug("Closing Twitch connection...");
         try:
             await self.close()
         except Exception as e: logger.error(f"Error during twitchio bot close: {e}")
         logger.info(f"Twitch bot instance {id(self)} shutdown complete.")

# --- Service Runner & Control ---
async def run_twitch_service():
    """Main entry point to run the Twitch service with reconnection and config loading."""
    global _STATE, _run_task # Use global _run_task reference
    logger.info("Twitch service runner started.")
    while True: # Outer loop allows reloading settings
        # Check for cancellation at the start of the loop
        if _run_task and _run_task.cancelled():
             logger.info("Twitch run loop detected cancellation.")
             break

        logger.debug("Loading Twitch settings...");
        settings_data = await load_settings();
        _STATE["settings"] = settings_data
        TWITCH_TOKEN = settings_data.get("TWITCH_TOKEN");
        TWITCH_NICK = settings_data.get("TWITCH_NICK");
        TWITCH_CLIENT_ID = settings_data.get("TWITCH_CLIENT_ID");
        TWITCH_CHANNELS_RAW = settings_data.get("TWITCH_CHANNELS", "");
        TWITCH_CHANNELS = [ch.strip().lower() for ch in TWITCH_CHANNELS_RAW.split(',') if ch.strip()]

        if not all([TWITCH_TOKEN, TWITCH_NICK, TWITCH_CLIENT_ID]) or not TWITCH_CHANNELS:
            logger.warning("Twitch credentials/channels missing. Service disabled. Waiting for settings update...");
            event_bus.publish(PlatformStatusUpdate(platform='twitch', status='disabled', message='Config missing'))
            await wait_for_settings_update({"TWITCH_TOKEN", "TWITCH_NICK", "TWITCH_CLIENT_ID", "TWITCH_CHANNELS"});
            continue # Restart outer loop

        _STATE["running"] = True; attempt = 0; MAX_ATTEMPTS=5; # Removed unused 'wait' variable
        bot_instance = None

        while _STATE.get("running") and attempt < MAX_ATTEMPTS:
            attempt += 1;
            try:
                logger.info(f"Starting Twitch bot (Attempt {attempt}/{MAX_ATTEMPTS})...");
                event_bus.publish(PlatformStatusUpdate(platform='twitch', status='connecting'))
                bot_instance = TwitchBot(token=TWITCH_TOKEN, nick=TWITCH_NICK, client_id=TWITCH_CLIENT_ID, channels=TWITCH_CHANNELS);
                _STATE["instance"] = bot_instance
                # Bot start() runs until disconnected or closed
                await bot_instance.start()
                logger.warning("Twitch bot start() returned naturally (connection closed/lost).")
            except asyncio.CancelledError:
                logger.info("Twitch run attempt cancelled.");
                _STATE["running"] = False;
                break # Exit inner loop immediately
            except Exception as e:
                logger.error(f"Twitch connection failed (Attempt {attempt}): {e}", exc_info=logger.isEnabledFor(logging.DEBUG)) # Less verbose default
                if isinstance(e, twitchio_errors.AuthenticationError) or 'Login authentication failed' in str(e):
                    event_bus.publish(PlatformStatusUpdate(platform='twitch', status='auth_error', message="Auth Failed"))
                    logger.critical("Twitch Auth Failed. Disabling service run until settings change or restart.");
                    _STATE["running"] = False;
                    break # Stop trying with bad credentials
                else:
                    event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message=f"Connect failed: {type(e).__name__}"))
            finally:
                 # Ensure cleanup happens even if start() fails or is cancelled
                 if bot_instance:
                      logger.debug(f"Cleaning up bot instance {id(bot_instance)} after attempt {attempt}...");
                      await bot_instance.custom_shutdown()
                      _STATE["instance"] = None # Clear instance ref
                      bot_instance = None # Clear local var

            # Check running flag and max attempts BEFORE sleeping
            if not _STATE.get("running"):
                logger.info("Twitch running flag is false, exiting retry loop.");
                break
            if attempt >= MAX_ATTEMPTS:
                logger.error("Max Twitch connection attempts reached.");
                break # Exit retry loop after max attempts

            # Retry logic
            wait_time = min(attempt * 10, 60);
            logger.info(f"Waiting {wait_time}s before Twitch retry (Attempt {attempt+1})...");
            try:
                await asyncio.sleep(wait_time);
            except asyncio.CancelledError:
                logger.info("Twitch retry sleep cancelled.");
                _STATE["running"] = False;
                break # Exit inner loop

        # After inner loop finishes (naturally or by break)
        if not _STATE.get("running"):
            logger.info("Twitch service run loop detected stop signal. Exiting outer loop.");
            break # Exit the main outer loop
        elif attempt >= MAX_ATTEMPTS:
            logger.error("Max Twitch attempts reached. Waiting for settings update/restart.");
            event_bus.publish(PlatformStatusUpdate(platform='twitch', status='error', message='Max attempts'));
            await wait_for_settings_update({"TWITCH_TOKEN", "TWITCH_NICK", "TWITCH_CLIENT_ID", "TWITCH_CHANNELS"})
            # Continue outer loop to reload settings

async def wait_for_settings_update(relevant_keys: set):
     """Waits for a SettingsUpdated event affecting relevant keys."""
     logger.info(f"Waiting for settings update affecting: {relevant_keys}...");
     future = asyncio.get_running_loop().create_future()
     listener_ref = None # Placeholder for the listener function itself

     async def settings_listener(event: SettingsUpdated):
          nonlocal future, listener_ref # Allow modification
          if any(key in relevant_keys for key in event.keys_updated):
               logger.info("Relevant settings updated, resuming service loop.");
               if not future.done(): future.set_result(True)
               # Attempt to unsubscribe (NOTE: Requires event bus modification or helper)
               # try: event_bus.unsubscribe(SettingsUpdated, listener_ref)
               # except ValueError: pass # Already unsubscribed or never subscribed properly
               # except AttributeError: logger.warning("EventBus does not support unsubscribe yet.")

     listener_ref = settings_listener # Store the function reference
     event_bus.subscribe(SettingsUpdated, listener_ref)
     try:
          await future # Wait until future is set by listener or cancelled
     except asyncio.CancelledError:
          logger.info("Wait for settings update cancelled.")
          # Attempt to unsubscribe on cancellation too
          # try: event_bus.unsubscribe(SettingsUpdated, listener_ref)
          # except ...
     # No finally unsubscribe here, might miss events if cancelled between check and await


async def stop_twitch_service():
     """Stops the Twitch service task gracefully."""
     global _STATE, _run_task;
     logger.info("Stop requested for Twitch service.");
     _STATE["running"] = False # Signal the run loop to stop

     bot = _STATE.get("instance")
     if bot:
          await bot.custom_shutdown() # Gracefully close connection, sender task etc.
          _STATE["instance"] = None

     current_task = _run_task;
     if current_task and not current_task.done():
         if not current_task.cancelling():
             logger.info("Cancelling Twitch run task...");
             current_task.cancel()
             try:
                 await current_task # Wait for cancellation to complete
                 logger.info("Twitch task cancellation confirmed.")
             except asyncio.CancelledError:
                 logger.info("Twitch task confirmed cancelled (exception caught).")
             except Exception as e:
                 logger.error(f"Error waiting for cancelled Twitch task: {e}")
         else:
             logger.info("Twitch task already cancelling.")
     else:
         logger.info("No active Twitch task found to cancel.")

     _run_task = None; # Clear task reference
     event_bus.publish(PlatformStatusUpdate(platform='twitch', status='stopped'))
     logger.info("Twitch service stopped.")


async def handle_settings_update(event: SettingsUpdated):
    """Restarts the Twitch service if relevant settings changed."""
    global _STATE, _run_task
    twitch_keys = {"TWITCH_TOKEN", "TWITCH_NICK", "TWITCH_CLIENT_ID", "TWITCH_CHANNELS"}
    if any(key in twitch_keys for key in event.keys_updated):
        logger.info("Relevant Twitch settings updated. Triggering restart...")
        # Publish a control event for main.py to handle restart consistently
        event_bus.publish(ServiceControl(service_name="twitch", command="restart"))


def start_twitch_service_task() -> asyncio.Task | None:
     """Creates and starts the background task for Twitch service."""
     global _run_task;
     if _run_task and not _run_task.done():
          logger.warning("Twitch service task already running or starting.")
          return _run_task

     logger.info("Creating background task for Twitch service.");
     # Subscribe to settings updates *before* starting the task
     event_bus.subscribe(SettingsUpdated, handle_settings_update);
     _run_task = asyncio.create_task(run_twitch_service(), name="TwitchServiceRunner");
     return _run_task

# --- File: app/services/twitch_service.py --- END ---


========================= File: app/services/whatnot_bridge.py =========================

import logging; logger=logging.getLogger(__name__); import asyncio; from app.core.event_bus import event_bus; from app.events import PlatformStatusUpdate
# This service would likely manage the pool of WS connections from the extension
# For now, it's just a placeholder task
async def run_whatnot_bridge(): event_bus.publish(PlatformStatusUpdate(platform='whatnot', status='disabled', message='Bridge not active')); logger.warning("Whatnot Bridge service NOT IMPLEMENTED."); await asyncio.sleep(3600*24)
async def stop_whatnot_bridge(): logger.info("Whatnot Bridge stop called (stub).")
def start_whatnot_bridge_task(): logger.info("Whatnot Bridge start called (stub)."); return None


========================= File: static/index.html =========================

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FoSBot Dashboard</title>
    <style>
        /* Basic Reset & Font */
        *, *::before, *::after { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0; display: flex; flex-direction: column; height: 100vh;
            background-color: #f0f2f5; font-size: 14px; color: #333;
        }
        button { cursor: pointer; padding: 8px 15px; border: none; border-radius: 4px; font-weight: 600; transition: background-color .2s ease; font-size: 13px; line-height: 1.5; }
        input[type=text], input[type=password], input[type=url] {
            padding: 9px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;
            width: calc(100% - 24px); margin-bottom: 10px; background-color: #fff;
            box-shadow: inset 0 1px 2px rgba(0,0,0,.075);
        }
        label { display: block; margin-bottom: 4px; font-weight: 600; font-size: .85em; color: #555; }
        a { color: #007bff; text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* Header */
        #header { background-color: #343a40; color: #f8f9fa; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,.15); position: sticky; top: 0; z-index: 100;}
        #header h1 { margin: 0; font-size: 1.5em; font-weight: 600; }
        #status-indicators { display: flex; flex-wrap: wrap; gap: 10px 15px; font-size: .8em; }
        #status-indicators span { display: flex; align-items: center; background-color: rgba(255,255,255,0.1); padding: 3px 8px; border-radius: 10px; }
        .status-light { width: 10px; height: 10px; border-radius: 50%; margin-right: 4px; border: 1px solid rgba(0,0,0,.2); flex-shrink: 0;}
        .status-text { color: #adb5bd; }
        .status-disconnected, .status-disabled, .status-stopped, .status-logged_out { background-color: #6c757d; } /* Grey */
        .status-connected { background-color: #28a745; box-shadow: 0 0 5px #28a745; } /* Green */
        .status-connecting { background-color: #ffc107; animation: pulseConnect 1.5s infinite ease-in-out; } /* Yellow */
        .status-error, .status-crashed, .status-auth_error { background-color: #dc3545; animation: pulseError 1s infinite ease-in-out; } /* Red */
        .status-disconnecting { background-color: #fd7e14; } /* Orange */

        /* Keyframes */
        @keyframes pulseConnect { 0%, 100% { opacity: .6; } 50% { opacity: 1; } }
        @keyframes pulseError { 0% { transform: scale(.9); box-shadow: 0 0 3px #dc3545;} 50% { transform: scale(1.1); box-shadow: 0 0 8px #dc3545;} 100% { transform: scale(.9); box-shadow: 0 0 3px #dc3545;} }

        /* Main Layout */
        #main-container { display: flex; flex: 1; overflow: hidden; flex-direction: column;}
        #tab-buttons { background-color: #e9ecef; padding: 5px 15px; border-bottom: 1px solid #dee2e6; flex-shrink: 0; }
        #tab-buttons button { background: none; border: none; padding: 10px 15px; cursor: pointer; font-size: 1em; color: #495057; border-bottom: 3px solid transparent; margin-right: 5px; font-weight: 500; }
        #tab-buttons button.active { border-bottom-color: #007bff; font-weight: 700; color: #0056b3; }
        #content-area { flex: 1; display: flex; overflow: hidden; }

        /* Tab Content Panes */
        .tab-content { display: none; height: 100%; width: 100%; overflow: hidden; }
        .tab-content.active { display: flex; flex-direction: row; }

        /* Chat Area */
        #chat-container { flex: 3; display: flex; flex-direction: column; border-right: 1px solid #dee2e6; }
        #chat-output { flex: 1; overflow-y: scroll; padding: 10px 15px; background-color: #fff; line-height: 1.6; }
        #chat-output div { margin-bottom: 6px; word-wrap: break-word; padding: 2px 0; }
        #chat-output .platform-tag { font-weight: 700; margin-right: 5px; display: inline-block; min-width: 35px; text-align: right; }
        .twitch { color: #9146ff; } .youtube { color: #ff0000; } .x { color: #1da1f2; } .whatnot { color: #ff6b00; } .streamer_admin { color: #fd7e14; font-weight: bold;} .system { color: #6c757d; font-style: italic; }
        .streamer-msg { background-color: #fff3cd; padding: 4px 8px; border-left: 3px solid #ffeeba; border-radius: 3px; margin: 2px -8px; }
        .timestamp { font-size: .75em; color: #6c757d; margin-left: 8px; float: right; opacity: .8; }

        /* Input Area */
        #input-area { display: flex; padding: 12px; border-top: 1px solid #dee2e6; background-color: #e9ecef; align-items: center; flex-shrink: 0;}
        #streamerInput { flex: 1; margin-right: 8px; }
        #sendButton { background-color: #28a745; color: #fff; }
        #sendButton:hover { background-color: #218838; }
        #clearButton { background-color: #ffc107; color: #212529; margin-left: 5px; }
        #clearButton:hover { background-color: #e0a800; }

        /* Settings Area */
        #settings-container { padding: 25px; overflow-y: auto; background-color: #fff; flex: 1; }
        .settings-section { margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid #e9ecef; }
        .settings-section:last-of-type { border-bottom: none; }
        .settings-section h3 { margin-top: 0; margin-bottom: 15px; color: #495057; font-size: 1.2em; font-weight: 600; }
        .settings-section button[type=submit] { background-color: #007bff; color: #fff; margin-top: 15px; min-width: 120px;}
        .settings-section button[type=submit]:hover { background-color: #0056b3; }
        .form-group { margin-bottom: 15px; }
        #settings-status { font-style: italic; margin-bottom: 15px; padding: 10px; border-radius: 4px; display: none; border: 1px solid transparent; }
        #settings-status.success { color: #0f5132; background-color: #d1e7dd; border-color: #badbcc; display: block;}
        #settings-status.error { color: #842029; background-color: #f8d7da; border-color: #f5c2c7; display: block;}
        .control-buttons-container > div { margin-bottom: 10px; }
        .control-button { margin: 0 5px 5px 0; padding: 6px 12px; font-size: 12px; }
        .control-button[data-command="start"] { background-color: #28a745; color: white; }
        .control-button[data-command="stop"] { background-color: #dc3545; color: white; }
        .control-button[data-command="restart"] { background-color: #ffc107; color: #212529; }
        /* OAuth Buttons */
        .oauth-login-button { background-color: #6441a5; color: white; padding: 10px 15px; font-size: 14px; } /* Twitch Purple */
        .oauth-login-button:hover { background-color: #4a2f7c; }
        .oauth-logout-button { background-color: #dc3545; color: white; padding: 6px 10px; font-size: 12px; margin-left: 10px; }
        .auth-status { margin-left: 15px; font-style: italic; color: #6c757d; }
        .auth-status strong { color: #28a745; }
        .auth-status.not-logged-in { color: #dc3545; }


        /* Sidebar */
        #sidebar { flex: 1; padding: 15px; background-color: #f8f9fa; border-left: 1px solid #dee2e6; overflow-y: auto; font-size: 12px; min-width: 280px; max-width: 350px;}
        #sidebar h3 { margin-top: 0; margin-bottom: 10px; color: #495057; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        #log-output { height: 250px; overflow-y: scroll; border: 1px solid #e0e0e0; padding: 8px; margin-top: 10px; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: #fff; border-radius: 3px; margin-bottom: 15px; line-height: 1.4;}
        .log-error { color: #dc3545; font-weight: bold; }
        .log-warning { color: #ffc107; }
        .log-info { color: #0dcaf0; }
        .log-debug { color: #6c757d; }

    </style>
</head>
<body>
    <div id="header">
        <h1>FoSBot Dashboard</h1>
        <div id="status-indicators">
            <span id="status-ws">WS: <span class="status-light status-disconnected"></span><span class="status-text">Offline</span></span>
            <span id="status-twitch">Twitch: <span class="status-light status-disabled"></span><span class="status-text">Off</span></span>
            <span id="status-youtube">YouTube: <span class="status-light status-disabled"></span><span class="status-text">Off</span></span>
            <span id="status-x">X: <span class="status-light status-disabled"></span><span class="status-text">Off</span></span>
            <span id="status-whatnot">Whatnot: <span class="status-light status-disabled"></span><span class="status-text">Ext</span></span>
        </div>
    </div>

    <div id="tab-buttons">
        <button class="tab-button active" data-tab="chat">Chat</button>
        <button class="tab-button" data-tab="settings">Settings</button>
    </div>

    <div id="main-content">
        <div id="content-area">
            <!-- Chat Tab -->
            <div id="chat-container" class="tab-content active" data-tab-content="chat">
                <div id="chat-output">
                    <div>Welcome! Attempting to connect to backend...</div>
                </div>
                <div id="input-area">
                    <input type="text" id="streamerInput" placeholder="Type message or command (e.g., !roll) to send...">
                    <button id="sendButton">Send</button>
                    <button id="clearButton">Clear Display</button>
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings-container" class="tab-content" data-tab-content="settings">
                <h2>Application Settings</h2>
                <p id="settings-status"></p>

                <!-- Twitch Section - OAuth -->
                <div class="settings-section">
                    <h3>Twitch Authentication</h3>
                    <div id="twitch-auth-area">
                        <!-- Content added by JS -->
                        <span class="auth-status">Loading...</span>
                    </div>
                    <div id="twitch-manual-settings" style="margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 15px; display: none;"> <!-- Hidden by default -->
                         <h4>Manual Overrides (Advanced/Debug)</h4>
                         <form id="twitch-settings-form-manual">
                             <div class="form-group"><label for="twitch-nick">Bot Username (TWITCH_NICK)</label><input type="text" id="twitch-nick" name="TWITCH_NICK"></div>
                             <div class="form-group"><label for="twitch-channels">Channel(s) to Join (TWITCH_CHANNELS, comma-sep)</label><input type="text" id="twitch-channels" name="TWITCH_CHANNELS"></div>
                             <div class="form-group"><label for="twitch-client-id-manual">Client ID (TWITCH_CLIENT_ID)</label><input type="text" id="twitch-client-id-manual" name="TWITCH_CLIENT_ID"></div>
                             <!-- Tokens no longer manually set here -->
                             <button type="submit">Save Manual Twitch Settings</button>
                             <small>Note: These usually come from .env or OAuth. Use with caution.</small>
                         </form>
                     </div>
                </div>

                <!-- YouTube Section - Placeholder for OAuth -->
                <div class="settings-section">
                    <h3>YouTube Authentication</h3>
                     <div id="youtube-auth-area">
                        <button class="oauth-login-button" style="background-color: #ff0000;" disabled>Login with YouTube (NYI)</button>
                        <span class="auth-status">Not Implemented</span>
                     </div>
                    <!-- Keep manual form for now if needed for API key/secrets file path -->
                     <form id="youtube-settings-form" style="margin-top: 15px;">
                        <div class="form-group"><label for="youtube-api-key">API Key (YOUTUBE_API_KEY)</label><input type="text" id="youtube-api-key" name="YOUTUBE_API_KEY"></div>
                        <div class="form-group"><label for="youtube-secrets-file">Client Secrets File Path (YOUTUBE_CLIENT_SECRETS_FILE)</label><input type="text" id="youtube-secrets-file" name="YOUTUBE_CLIENT_SECRETS_FILE" placeholder="/full/path/to/client_secret.json"></div>
                        <div class="form-group"><label for="youtube-chat-id">Live Chat ID (YOUTUBE_LIVE_CHAT_ID, optional)</label><input type="text" id="youtube-chat-id" name="YOUTUBE_LIVE_CHAT_ID" placeholder="Leave blank to auto-detect"></div>
                        <button type="submit">Save YouTube Manual Settings</button>
                     </form>
                </div>

                <!-- X/Twitter Section - Placeholder for OAuth -->
                <div class="settings-section">
                    <h3>X / Twitter Authentication</h3>
                     <div id="x-auth-area">
                        <button class="oauth-login-button" style="background-color: #1da1f2;" disabled>Login with X (NYI)</button>
                         <span class="auth-status">Not Implemented</span>
                    </div>
                    <!-- Keep manual form for now -->
                     <form id="x-settings-form" style="margin-top: 15px;">
                        <div class="form-group"><label for="x-bearer">Bearer Token (X_BEARER_TOKEN)</label><input type="text" id="x-bearer" name="X_BEARER_TOKEN"></div>
                        <div class="form-group"><label for="x-api-key">API Key (X_API_KEY)</label><input type="text" id="x-api-key" name="X_API_KEY"></div>
                        <div class="form-group"><label for="x-api-secret">API Secret (X_API_SECRET)</label><input type="password" id="x-api-secret" name="X_API_SECRET" placeholder="Enter NEW secret to update"></div>
                        <div class="form-group"><label for="x-access-token">Access Token (X_ACCESS_TOKEN)</label><input type="text" id="x-access-token" name="X_ACCESS_TOKEN"></div>
                        <div class="form-group"><label for="x-access-secret">Access Secret (X_ACCESS_SECRET)</label><input type="password" id="x-access-secret" name="X_ACCESS_SECRET" placeholder="Enter NEW secret to update"></div>
                        <div class="form-group"><label for="x-monitor">Hashtag/Mention to Monitor (X_HASHTAG_OR_MENTION)</label><input type="text" id="x-monitor" name="X_HASHTAG_OR_MENTION" placeholder="#YourTag or @YourBot"></div>
                        <button type="submit">Save X/Twitter Manual Settings</button>
                     </form>
                </div>

                 <!-- App Config Section -->
                 <div class="settings-section">
                     <h3>App Config</h3>
                     <form id="app-settings-form">
                         <div class="form-group">
                            <label for="app-command-prefix">Command Prefix (COMMAND_PREFIX)</label>
                            <input type="text" id="app-command-prefix" name="COMMAND_PREFIX" style="width: 50px;">
                        </div>
                         <button type="submit">Save App Settings</button>
                     </form>
                </div>

                <!-- Service Control Section -->
                <div class="settings-section">
                    <h3>Service Control</h3>
                    <p>Start/Stop/Restart platform connection services. Status shown in header.</p>
                    <div class="control-buttons-container">
                        <div>
                            Twitch:
                            <button class="control-button" data-service="twitch" data-command="start">Start</button>
                            <button class="control-button" data-service="twitch" data-command="stop">Stop</button>
                            <button class="control-button" data-service="twitch" data-command="restart">Restart</button>
                        </div>
                         <div>
                            YouTube:
                            <button class="control-button" data-service="youtube" data-command="start">Start</button>
                            <button class="control-button" data-service="youtube" data-command="stop">Stop</button>
                            <button class="control-button" data-service="youtube" data-command="restart">Restart</button>
                        </div>
                         <div>
                            X/Twitter:
                            <button class="control-button" data-service="x" data-command="start">Start</button>
                            <button class="control-button" data-service="x" data-command="stop">Stop</button>
                            <button class="control-button" data-service="x" data-command="restart">Restart</button>
                        </div>
                    </div>
                </div>

            </div> <!-- End Settings Tab -->
        </div> <!-- End Content Area -->

        <!-- Sidebar -->
        <div id="sidebar">
            <h3>Status & Logs</h3>
            <div id="general-status">App Status: Initializing...</div>
            <div id="log-output"></div>
            <!-- Future: User Lists, Game Info etc. -->
        </div>
    </div>

    <script src="main.js"></script>
</body>
</html>


========================= File: static/main.js =========================

// --- File: static/main.js --- START ---
// FoSBot Dashboard Frontend JS v0.6 (OAuth Flow)

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const chatOutput = document.getElementById('chat-output');
    const streamerInput = document.getElementById('streamerInput');
    const sendButton = document.getElementById('sendButton');
    const clearButton = document.getElementById('clearButton');
    const wsStatusElement = document.getElementById('status-ws').querySelector('.status-text');
    const wsLightElement = document.getElementById('status-ws').querySelector('.status-light');
    const platformStatusIndicators = {
        twitch: document.getElementById('status-twitch'),
        youtube: document.getElementById('status-youtube'),
        x: document.getElementById('status-x'),
        whatnot: document.getElementById('status-whatnot')
    };
    const generalStatus = document.getElementById('general-status');
    const logOutput = document.getElementById('log-output');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    const settingsStatus = document.getElementById('settings-status');
    // Settings Forms (Non-Auth)
    const manualSettingsForms = document.querySelectorAll('#settings-container form:not(#twitch-settings-form-manual)'); // Exclude manual twitch form initially
    const appSettingsForm = document.getElementById('app-settings-form'); // Keep separate ref if needed
    // Auth Areas
    const twitchAuthArea = document.getElementById('twitch-auth-area');
    // Service Control Buttons
    const controlButtons = document.querySelectorAll('.control-button');

    // --- WebSocket State ---
    let socket = null;
    let reconnectTimer = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 15;
    const RECONNECT_DELAY_BASE = 3000;

    // --- State ---
    let currentSettings = {}; // Store loaded settings

    // --- Helper Functions ---
    function updateStatusIndicator(statusId, statusClass, statusText = '') {
        const indicator = platformStatusIndicators[statusId];
        const defaultText = statusClass ? statusClass.charAt(0).toUpperCase() + statusClass.slice(1) : 'Unknown';
        const textToShow = statusText || defaultText;
        if (indicator) {
            const textEl = indicator.querySelector('.status-text');
            const lightEl = indicator.querySelector('.status-light');
            if(textEl && lightEl){
                lightEl.className = 'status-light'; // Reset
                lightEl.classList.add(`status-${statusClass}`);
                textEl.textContent = textToShow;
            }
        } else if (statusId === 'ws') {
            wsLightElement.className = 'status-light'; // Reset
            wsLightElement.classList.add(`status-${statusClass}`);
            wsStatusElement.textContent = textToShow;
        }
    }

    function formatTimestamp(isoTimestamp) { /* ... (keep unchanged) ... */ }
    function escapeHtml(unsafe) { /* ... (keep unchanged) ... */ }
    function linkify(text) { /* ... (keep unchanged) ... */ }
    function addChatMessage(platform, user, text, timestamp = null) { /* ... (keep unchanged) ... */ }
    function addLogMessage(level, message, moduleName = '') { /* ... (keep unchanged) ... */ }

    function showSettingsStatus(message, isError = false, duration = 5000) {
        if (!settingsStatus) return;
        settingsStatus.textContent = message;
        settingsStatus.className = isError ? 'error' : 'success';
        settingsStatus.style.display = 'block';
        clearTimeout(settingsStatus.timer);
        if (duration > 0) {
            settingsStatus.timer = setTimeout(() => {
                settingsStatus.textContent = '';
                settingsStatus.style.display = 'none';
                settingsStatus.className = '';
            }, duration);
        }
    }

    // --- OAuth UI Update ---
    function updateAuthUI(platform, authData) {
        const authArea = document.getElementById(`${platform}-auth-area`);
        if (!authArea) return;

        authArea.innerHTML = ''; // Clear previous content

        if (authData && authData.user_login) {
            // Logged In State
            const statusSpan = document.createElement('span');
            statusSpan.className = 'auth-status';
            statusSpan.innerHTML = `Logged in as: <strong>${escapeHtml(authData.user_login)}</strong>`;

            const logoutButton = document.createElement('button');
            logoutButton.className = 'oauth-logout-button';
            logoutButton.textContent = 'Logout';
            logoutButton.dataset.platform = platform; // Store platform for handler
            logoutButton.addEventListener('click', handleLogoutClick);

            authArea.appendChild(statusSpan);
            authArea.appendChild(logoutButton);
            updateStatusIndicator(platform, 'connected', `Logged in as ${authData.user_login}`); // Update header status too

        } else {
            // Logged Out State
            const loginButton = document.createElement('button');
            loginButton.className = 'oauth-login-button';
            loginButton.textContent = `Login with ${platform.charAt(0).toUpperCase() + platform.slice(1)}`;
            loginButton.dataset.platform = platform; // Store platform for handler
            loginButton.addEventListener('click', handleLoginClick);

            const statusSpan = document.createElement('span');
            statusSpan.className = 'auth-status not-logged-in';
            statusSpan.textContent = 'Not Logged In';

            authArea.appendChild(loginButton);
            authArea.appendChild(statusSpan);
            updateStatusIndicator(platform, 'logged_out', 'Logged Out'); // Update header status
        }
    }

    function handleLoginClick(event) {
        const platform = event.target.dataset.platform;
        if (!platform) return;
        addLogMessage('INFO', `Initiating login flow for ${platform}...`);
        // Redirect the browser to the backend login endpoint
        window.location.href = `/auth/${platform}/login`;
    }

    async function handleLogoutClick(event) {
        const platform = event.target.dataset.platform;
        if (!platform) return;

        if (!confirm(`Are you sure you want to logout from ${platform.toUpperCase()}? This will disconnect the service.`)) {
            return;
        }

        addLogMessage('INFO', `Initiating logout for ${platform}...`);
        showSettingsStatus(`Logging out from ${platform}...`, false, 0); // Indefinite status

        try {
            const response = await fetch(`/auth/${platform}/logout`, { method: 'POST' });
            const result = await response.json(); // Assume JSON response

            if (response.ok) {
                showSettingsStatus(result.message || `${platform.toUpperCase()} logout successful.`, false);
                addLogMessage('INFO', `${platform.toUpperCase()} logout: ${result.message}`);
                // Refresh settings/auth status after logout
                requestSettings();
            } else {
                 showSettingsStatus(`Logout Error: ${result.detail || response.statusText}`, true);
                 addLogMessage('ERROR', `Logout Error (${platform}): ${result.detail || response.statusText}`);
            }
        } catch (error) {
            console.error(`Logout Error (${platform}):`, error);
            showSettingsStatus(`Network error during logout: ${error.message}`, true);
            addLogMessage('ERROR', `Network error during ${platform} logout: ${error.message}`);
        }
    }


    // --- WebSocket Handling ---
    function handleWebSocketMessage(data) {
        switch (data.type) {
            case 'chat': addChatMessage(data.platform, data.user, data.text, data.timestamp); break;
            case 'platform_status':
                 // Don't override logged-in status from manual status updates unless it's disconnected/error
                 const isLoggedIn = currentSettings[`${data.platform}_user_login`];
                 if (!isLoggedIn || (isLoggedIn && ['disconnected', 'error', 'auth_error', 'stopped'].includes(data.status.toLowerCase()))) {
                     updateStatusIndicator(data.platform, data.status.toLowerCase(), data.message || data.status);
                 } else {
                     // If logged in, just maybe update the light color based on connection status?
                     updateStatusIndicator(data.platform, data.status.toLowerCase(), `Logged in as ${isLoggedIn}`);
                 }
                 addLogMessage('INFO', `Platform [${data.platform.toUpperCase()}]: ${data.status} ${data.message ? '- ' + data.message : ''}`);
                 break;
            case 'log': addLogMessage(data.level, data.message, data.module); break;
            case 'status': addLogMessage('INFO', `Backend: ${data.message}`); generalStatus.textContent = `App Status: ${data.message}`; break;
            case 'error': addLogMessage('ERROR', `Backend Err: ${data.message}`); generalStatus.textContent = `App Status: Error - ${data.message}`; break;
            case 'pong': console.log("Pong received."); break;
            case 'current_settings':
                 currentSettings = data.payload || {}; // Store settings globally
                 populateSettingsForm(currentSettings);
                 updateAuthUI('twitch', { user_login: currentSettings.twitch_user_login }); // Update Twitch Auth UI
                 // Update other auth UIs if/when implemented
                 // updateAuthUI('youtube', { user_login: currentSettings.youtube_user_login });
                 // updateAuthUI('x', { user_login: currentSettings.x_user_login });
                 break;
            default: console.warn("Unknown WS type:", data.type, data); addLogMessage('WARN', `Unknown WS message type: ${data.type}`);
        }
    }

    function connectWebSocket() { /* ... (keep unchanged from previous correct version) ... */ }

    // --- Input Handling ---
    function sendStreamerInput() { /* ... (keep unchanged) ... */ }
    sendButton.addEventListener('click', sendStreamerInput);
    streamerInput.addEventListener('keypress', (event) => { /* ... */ });
    clearButton.addEventListener('click', () => { /* ... */ });

    // --- Tab Switching ---
    tabButtons.forEach(button => { button.addEventListener('click', () => { /* ... (keep unchanged, requestSettings is still good) ... */ }); });

    // --- Settings Handling ---
    function requestSettings() { if (socket && socket.readyState === WebSocket.OPEN) { console.log("Requesting settings..."); addLogMessage('DEBUG', 'Requesting settings...'); socket.send(JSON.stringify({ type: "request_settings" })); } else { showSettingsStatus("Cannot load settings: WS closed.", true); updateAuthUI('twitch', null); /* Clear auth UI if WS down */ } }

    function populateSettingsForm(settings) {
        console.log("Populating settings:", settings);
        addLogMessage('DEBUG', 'Populating non-auth settings form fields.');

        // Populate non-auth forms (YouTube Manual, X Manual, App Config)
        manualSettingsForms.forEach(form => {
            for (const element of form.elements) {
                if (element.name && settings.hasOwnProperty(element.name)) {
                     // Only populate non-token fields here
                     if (element.type !== 'password' && !element.name.includes('_token') && !element.name.includes('_secret')) {
                        element.value = settings[element.name] || '';
                    } else if (element.type === 'password') {
                        // Standard password handling (masked if value exists)
                        element.placeholder = settings[element.name] ? '******** (Saved)' : 'Enter Secret/Token';
                        element.value = '';
                    }
                } else if (element.type === 'password' && element.name) {
                     element.placeholder = 'Enter Secret/Token'; // Default placeholder
                     element.value = '';
                }
            }
        });
        showSettingsStatus("Settings loaded.", false, 3000); // Short confirmation
    }

    async function saveSettings(formEl) {
        const formData = new FormData(formEl);
        const dataToSend = {};
        let hasChanges = false;

        // Check against currentSettings state to see if values *actually* changed
        formData.forEach((value, key) => {
            const inputEl = formEl.elements[key];
            if (!inputEl) return;
            const isSecret = (inputEl.type === 'password');
            const existingValue = currentSettings[key];

            // Determine if we should send the value:
            // 1. It's a non-secret field and its value is different from the currently stored setting.
            // 2. It IS a secret field, and the user has typed something into it (value is not empty).
            let shouldSend = false;
            if (!isSecret) {
                if (value !== (existingValue || '')) { // Compare with existing or empty string
                     shouldSend = true;
                 }
            } else { // Is a secret field
                if (value !== '') { // Only send if user typed something new
                     shouldSend = true;
                 }
            }

            if (shouldSend) {
                 dataToSend[key] = value;
                 hasChanges = true;
            }
        });

        if (!hasChanges) {
             showSettingsStatus("No actual changes detected to save.", false);
             return;
        }

        const formId = formEl.id.split('-')[0]; // e.g., 'youtube', 'x', 'app'
        console.log(`Saving ${formId} settings:`, Object.keys(dataToSend));
        showSettingsStatus(`Saving ${formId} settings...`, false, 0);

        try {
            const response = await fetch('/api/settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(dataToSend) });
            const result = await response.json();
            if (response.ok) {
                showSettingsStatus(result.message || "Settings saved!", false);
                // Request settings again to update UI and currentSettings state
                requestSettings();
            } else { showSettingsStatus(`Error: ${result.detail || response.statusText}`, true); }
        } catch (error) { console.error(`Save ${formId} Err:`, error); showSettingsStatus(`Network error: ${error.message}`, true); }
    }

    // Attach submit listener ONLY to non-auth forms
    manualSettingsForms.forEach(form => { form.addEventListener('submit', (e) => { e.preventDefault(); saveSettings(e.target); }); });

    // --- Service Control ---
    controlButtons.forEach(button => { button.addEventListener('click', async (e) => { /* ... (keep unchanged) ... */ }); });

    // --- Check for Auth Success Flag ---
    function checkAuthSuccess() {
        const urlParams = new URLSearchParams(window.location.search);
        const authSuccess = urlParams.get('auth_success');
        if (authSuccess) {
            showSettingsStatus(`${authSuccess.charAt(0).toUpperCase() + authSuccess.slice(1)} login successful!`, false, 7000);
            addLogMessage('INFO', `${authSuccess.toUpperCase()} OAuth successful.`);
            // Clean the URL (optional)
            window.history.replaceState({}, document.title, window.location.pathname); // Remove query params
            // Switch to settings tab automatically?
            const settingsTabButton = document.querySelector('button[data-tab="settings"]');
            if(settingsTabButton) settingsTabButton.click();
        }
    }

    // --- Initial Load ---
    addLogMessage('INFO', 'Dashboard UI Initialized.');
    checkAuthSuccess(); // Check immediately on load
    connectWebSocket(); // Start WebSocket connection

}); // End DOMContentLoaded
// --- File: static/main.js --- END ---


========================= File: whatnot_extension/popup.js =========================

const cfgBtn=document.getElementById('configureButton');const statEl=document.getElementById('status');const selDiv=document.getElementById('currentSelectors');const wsStatEl=document.getElementById('ws-status');
function displaySelectors(){chrome.storage.local.get(['whatnotSelectors'],(r)=>{selDiv.innerHTML='<strong>Current:</strong><br>';if(r.whatnotSelectors){const k=['chatContainer','messageItem','username','messageText','chatInput','sendButton'];k.forEach(key=>{const d=document.createElement('div');const v=r.whatnotSelectors[key];d.textContent=`${key}: ${v||'N/A'}`;d.title=v||'N/A';selDiv.appendChild(d);});}else{selDiv.innerHTML+='<i>None saved.</i>';}});}
function checkConnection(){wsStatEl.textContent='WS: Chk...';chrome.tabs.query({active:true,currentWindow:true},(tabs)=>{const wt=tabs.find(t=>t.url&&t.url.includes('whatnot.com'));if(wt&&wt.id){chrome.tabs.sendMessage(wt.id,{action:"query_status"},(r)=>{if(chrome.runtime.lastError){wsStatEl.textContent=`WS: Err`;console.error(chrome.runtime.lastError.message);}else if(r){wsStatEl.textContent=`WS: ${r.ws_status||'?'}`;if(r.selectors_ok===false)statEl.textContent="WARN: Selectors missing!";else if(r.selectors_ok===true)statEl.textContent="Selectors loaded.";}else{wsStatEl.textContent='WS: No Resp';}});}});}
cfgBtn.addEventListener('click',()=>{statEl.textContent='Sending...';chrome.tabs.query({active:true,currentWindow:true},(tabs)=>{const wt=tabs.find(t=>t.url&&t.url.includes('whatnot.com'));if(wt&&wt.id){chrome.tabs.sendMessage(wt.id,{action:"start_inspector"},(r)=>{if(chrome.runtime.lastError){statEl.textContent=`Err: ${chrome.runtime.lastError.message}. Refresh?`;console.error(chrome.runtime.lastError);}else if(r&&r.status==="started"){statEl.textContent='Inspector started.';window.close();}else if(r&&r.status==="already_active"){statEl.textContent='Inspector active.';window.close();}else{statEl.textContent='Failed: No response.';console.warn(r);}});}});}
document.addEventListener('DOMContentLoaded',()=>{displaySelectors();checkConnection();});


========================= File: whatnot_extension/background.js =========================

chrome.runtime.onInstalled.addListener(details => { console.log(`FoSBot WN Helper ${details.reason}.`); }); console.log("FoSBot BG Loaded.");


========================= File: whatnot_extension/popup.html =========================

<!DOCTYPE html><html><head><title>FoSBot Helper</title><meta charset="UTF-8"><style>body{width:250px;font-family:sans-serif;padding:10px;font-size:14px}button{margin-top:10px;padding:5px 10px;cursor:pointer}p{margin:5px 0;line-height:1.3}#status,#ws-status{font-style:italic;color:grey;min-height:1.2em;margin-top:5px}#currentSelectors{margin-top:15px;font-size:11px;color:#333;max-height:150px;overflow-y:auto;border-top:1px solid #ccc;padding-top:5px;background-color:#f9f9f9;padding:5px;border-radius:3px}#currentSelectors div{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:3px}strong{display:block;margin-bottom:4px}</style></head><body><h3>Whatnot Selectors</h3><p>Configure elements for chat interaction. Click, then follow overlay prompts.</p><button id="configureButton">Configure/Re-Configure</button><div id="status"></div><div id="ws-status">WS: Loading...</div><div id="currentSelectors">Loading...</div><script src="popup.js"></script></body></html>


========================= File: whatnot_extension/manifest.json =========================

{"manifest_version": 3,"name": "FoSBot Whatnot Helper","version": "0.3.0","description": "Reads Whatnot chat. Requires config via popup.","permissions": ["storage","activeTab","scripting"],"host_permissions": ["*://*.whatnot.com/*"],"background": {"service_worker": "background.js"},"content_scripts": [{"matches": ["*://*.whatnot.com/*"],"js": ["content.js"],"run_at": "document_idle","all_frames": false}],"action": {"default_popup": "popup.html","default_icon": {"16": "icons/icon16.png","48": "icons/icon48.png","128": "icons/icon128.png"}},"icons": {"16": "icons/icon16.png","48": "icons/icon48.png","128": "icons/icon128.png"}}


========================= File: whatnot_extension/content.js =========================

// FoSBot Whatnot Helper Content Script v0.4 (Webapp Config)
let selectors = {}; const STORAGE_KEY = 'whatnotSelectors'; let WS_URL = 'ws://localhost:8000/ws/whatnot'; let socket = null; let reconnectTimer = null; let reconnectAttempts = 0; const MAX_RECONNECT_ATTEMPTS = 15; const RECONNECT_DELAY_BASE = 3000; let observer = null; let isInspectorMode = false; let inspectorStep = 0;
const inspectorSteps = [ { key: 'chatContainer', prompt: 'Click MAIN chat message area' }, { key: 'messageItem', prompt: 'Click ANY single chat message row' }, { key: 'username', prompt: 'Click USERNAME in that message' }, { key: 'messageText', prompt: 'Click MESSAGE TEXT in that message' }, { key: 'chatInput', prompt: 'Click the text INPUT field' }, { key: 'sendButton', prompt: 'Click the SEND button/icon' } ];
let inspectorOverlay = null; let lastClickedElementForStep = {};
function initialize() { console.log("FoSBot WN Helper: Init"); loadSelectors().then(loaded => { connectWebSocket(); }); setupMessageListener(); }
function connectWebSocket() { clearTimeout(reconnectTimer); if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return; console.log(`WN Ext: Connecting WS: ${WS_URL}`); try { socket = new WebSocket(WS_URL); } catch (e) { console.error(`WN Ext: WS connect failed: ${e}`); scheduleReconnect(); return; }
    socket.onopen = () => { console.log('WN Ext: WS Connected'); reconnectAttempts = 0; startObserver(); };
    socket.onmessage = (event) => { console.debug('WN Ext: Msg from server:', event.data); try { const data = JSON.parse(event.data); if (data.action === 'postToWhatnot') { handlePostToWhatnot(data.message); } } catch (e) { console.error("WN Ext: Error parsing server msg", e); } };
    socket.onclose = (event) => { console.log(`WN Ext: WS closed (Code: ${event.code})`); stopObserver(); socket = null; scheduleReconnect(); };
    socket.onerror = (error) => { console.error('WN Ext: WS Error:', error); };
}
function scheduleReconnect() { if (isInspectorMode) return; reconnectAttempts++; if (reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) { const delay = Math.min(RECONNECT_DELAY_BASE * Math.pow(1.5, reconnectAttempts -1), 60000); console.log(`WN Ext: Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000}s...`); clearTimeout(reconnectTimer); reconnectTimer = setTimeout(connectWebSocket, delay); } else { console.error("WN Ext: Max WS reconnect attempts."); } }
function handlePostToWhatnot(message) { console.log(`WN Ext: Attempt post: "${message}"`); if (!validateSelectors(['chatInput', 'sendButton'])) { console.error("Cannot post: Selectors invalid."); return false; } const chatInput = document.querySelector(selectors.chatInput); const sendButton = document.querySelector(selectors.sendButton); if (!chatInput || !sendButton) { console.error(`Cannot find Input/Button: ${selectors.chatInput} / ${selectors.sendButton}`); return false; }
    try { chatInput.focus(); const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set; setter.call(chatInput, message); chatInput.dispatchEvent(new Event('input', { bubbles: true, composed: true })); chatInput.dispatchEvent(new Event('change', { bubbles: true, composed: true }));
        setTimeout(() => { if (!sendButton.disabled) sendButton.click(); else console.warn("WN Send disabled."); }, 150); return true;
    } catch (e) { console.error("Error posting to WN:", e); return false; }
}
async function loadSelectors() { try { const result = await chrome.storage.local.get([STORAGE_KEY]); if (result[STORAGE_KEY] && typeof result[STORAGE_KEY] === 'object') { const keys = Object.keys(selectors); if (keys.every(k => Object.keys(result[STORAGE_KEY]).includes(k))) { selectors = result[STORAGE_KEY]; console.log('WN Ext: Loaded selectors:', selectors); return validateSelectors(keys); } } console.warn('WN Ext: No valid selectors.'); return false; } catch (e) { console.error("WN Ext: Error loading selectors:", e); return false; } }
function validateSelectors(keysToCheck) { return keysToCheck.every(key => selectors[key] && typeof selectors[key] === 'string' && selectors[key].trim() !== ''); }
async function saveSelectors() { try { await chrome.storage.local.set({ [STORAGE_KEY]: selectors }); console.log('WN Ext: Selectors saved:', selectors); if (inspectorOverlay) updateInspectorStatus('Saved! Restarting observer...'); stopObserver(); startObserver(); } catch (e) { console.error("WN Ext: Error saving selectors:", e); if (inspectorOverlay) updateInspectorStatus('ERROR saving!'); } }
function startObserver() { stopObserver(); if (!socket || socket.readyState !== WebSocket.OPEN) return; if (!validateSelectors(['chatContainer', 'messageItem', 'username', 'messageText'])) { console.warn('Observer not started: Read selectors invalid.'); return; } const container = document.querySelector(selectors.chatContainer); if (!container) { console.error(`Observer failed: Cannot find container: ${selectors.chatContainer}`); return; } console.log(`WN Ext: Starting Observer on: ${selectors.chatContainer}`);
    observer = new MutationObserver((mutations) => { for (const m of mutations) { if (m.addedNodes.length) { m.addedNodes.forEach(node => { if (node.nodeType === 1) { if (node.matches(selectors.messageItem)) { parseAndSend(node); } else { node.querySelectorAll(selectors.messageItem).forEach(parseAndSend); } } }); } } });
    observer.observe(container, { childList: true, subtree: true }); console.log("WN Ext: Observer active.");
}
function parseAndSend(el) { const userEl = el.querySelector(selectors.username); const textEl = el.querySelector(selectors.messageText); const user = userEl?.textContent?.trim(); const text = textEl?.textContent?.trim(); if (user && text && text !== user && socket && socket.readyState === WebSocket.OPEN) { console.debug(`WN Ext: Sending: [${user}] ${text}`); socket.send(JSON.stringify({ platform: 'whatnot', user: user, text: text })); } }
function stopObserver() { if (observer) { observer.disconnect(); observer = null; console.log("WN Ext: Observer stopped."); } }
function startInspectorMode() { if (isInspectorMode) return; isInspectorMode = true; inspectorStep = 0; lastClickedElementForStep = {}; console.log("WN Ext: Starting Inspector"); createInspectorOverlay(); updateInspectorPrompt(); document.body.style.cursor = 'crosshair'; document.addEventListener('click', inspectorClickListener, { capture: true }); }
function stopInspectorMode(save = false) { if (!isInspectorMode) return; isInspectorMode = false; document.body.style.cursor = 'default'; document.removeEventListener('click', inspectorClickListener, { capture: true }); removeInspectorOverlay(); console.log("WN Ext: Inspector Stopped."); if (save) { saveSelectors(); } }
function createInspectorOverlay() { removeInspectorOverlay(); inspectorOverlay = document.createElement('div'); inspectorOverlay.style.cssText = `all: initial; position: fixed; top: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.85); color: white; padding: 15px; border: 3px solid gold; border-radius: 5px; z-index: 2147483647; font-family: sans-serif; font-size: 14px; line-height: 1.4; max-width: 350px; box-shadow: 0 0 15px rgba(0,0,0,0.5);`; inspectorOverlay.innerHTML = `<h4 style="all: revert; margin: 0 0 10px 0; padding-bottom: 5px; border-bottom: 1px solid gold;">Configure Selectors</h4><p id="inspectorPrompt" style="all: revert; margin: 5px 0; font-weight: bold;"></p><p id="inspectorStatus" style="all: revert; margin: 10px 0 0 0; font-style: italic; color: #ddd;"></p><button id="cancelInspector" style="all: revert; margin-top: 15px; padding: 5px 8px; background-color: #cc5555; color: white; border: 1px solid #aa4444; cursor: pointer; border-radius: 3px; font-size: 12px;">Cancel</button>`; document.body.appendChild(inspectorOverlay); inspectorOverlay.querySelector('#cancelInspector').addEventListener('click', (e) => { e.stopPropagation(); stopInspectorMode(false); }); }
function removeInspectorOverlay() { if (inspectorOverlay) { inspectorOverlay.remove(); inspectorOverlay = null; } }
function updateInspectorPrompt() { if (!inspectorOverlay) return; const promptEl = inspectorOverlay.querySelector('#inspectorPrompt'); const cancelBtn = inspectorOverlay.querySelector('#cancelInspector'); if (inspectorStep < inspectorSteps.length) { promptEl.textContent = `Step ${inspectorStep + 1}/${inspectorSteps.length}: ${inspectorSteps[inspectorStep].prompt}`; } else { promptEl.textContent = 'All steps done! Review selectors.'; updateInspectorStatus('Click Save to apply.'); const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save Selectors'; saveBtn.style.cssText = 'all: revert; margin-left: 10px; padding: 5px 8px; background-color: #4CAF50; color: white; border: 1px solid #388E3C; cursor: pointer; border-radius: 3px; font-size: 12px;'; saveBtn.onclick = (e) => { e.stopPropagation(); stopInspectorMode(true); }; cancelBtn.insertAdjacentElement('afterend', saveBtn); } }
function updateInspectorStatus(text) { if (!inspectorOverlay) return; inspectorOverlay.querySelector('#inspectorStatus').textContent = text; }
function generateRobustSelector(el) { if (!el || typeof el.getAttribute !== 'function') return null; try { if (el.id) { const idSel = `#${CSS.escape(el.id)}`; if (document.querySelectorAll(idSel).length === 1) return idSel; } const dataAttrs = Array.from(el.attributes).filter(a => a.name.startsWith('data-test') && a.value); for (const a of dataAttrs) { const s = `${el.tagName.toLowerCase()}[${a.name}="${CSS.escape(a.value)}"]`; if (document.querySelectorAll(s).length === 1) return s; } const role = el.getAttribute('role'); if (role) { const s = `${el.tagName.toLowerCase()}[role="${CSS.escape(role)}"]`; if (document.querySelectorAll(s).length === 1) return s; } if (el.classList.length > 0) { const classes = Array.from(el.classList).filter(c => !/^(?:js-|is-|has-|active|focus|hover|animating)/.test(c) && !/\d/.test(c) && c.length > 3); if (classes.length > 0) { return `${el.tagName.toLowerCase()}.${classes.map(c => CSS.escape(c)).join('.')}`; } } return el.tagName.toLowerCase(); } catch (e) { console.error("Error generating selector:", e, el); return null; } }
function generateRelativeSelector(target, base) { if (!base || !target || !base.contains(target)) { return generateRobustSelector(target); } try { if (target.id && base.querySelectorAll(`#${CSS.escape(target.id)}`).length === 1) return `#${CSS.escape(target.id)}`; const dataAttrs = Array.from(target.attributes).filter(a => a.name.startsWith('data-test') && a.value); for (const a of dataAttrs) { const s = `[${a.name}="${CSS.escape(a.value)}"]`; if (base.querySelectorAll(s).length === 1 && base.querySelector(s) === target) return s; } if (target.classList.length > 0) { const classes = Array.from(target.classList).filter(c => !/^(?:js-|is-|has-|active|focus|hover|animating)/.test(c) && !/\d/.test(c) && c.length > 3); if (classes.length > 0) { const s = `.${classes.map(c => CSS.escape(c)).join('.')}`; if (base.querySelectorAll(s).length === 1 && base.querySelector(s) === target) return s; } } return generateRobustSelector(target); } catch (e) { console.error("Error generating relative selector:", e); return generateRobustSelector(target); } }
function inspectorClickListener(event) { if (!isInspectorMode) return; event.preventDefault(); event.stopPropagation(); const targetElement = event.target; const currentStep = inspectorSteps[inspectorStep]; let selector; targetElement.style.outline = '3px dashed gold'; setTimeout(() => { targetElement.style.outline = ''; }, 750); if (currentStep.key === 'username' || currentStep.key === 'messageText') { const baseElement = lastClickedElementForStep['messageItem']; selector = generateRelativeSelector(targetElement, baseElement); } else { selector = generateRobustSelector(targetElement); lastClickedElementForStep[currentStep.key] = targetElement; } selectors[currentStep.key] = selector; updateInspectorStatus(`Selected ${currentStep.key}: ${selector}`); inspectorStep++; updateInspectorPrompt(); }
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { console.log("WN Ext: Received message:", request); if (request.action === "start_inspector") { if (isInspectorMode) { sendResponse({ status: "already_active" }); if(inspectorOverlay) inspectorOverlay.style.zIndex = '2147483647'; } else { startInspectorMode(); sendResponse({ status: "started" }); } return true; } else if (request.action === "query_status") { sendResponse({ ws_status: socket ? ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][socket.readyState] : "Not Init", selectors_ok: validateSelectors(Object.keys(selectors)) }); return false; } });
initialize(); // Start


========================= File: data/settings.json =========================

{}


========================= File: data/checkins.json =========================

{}


========================= File: data/counters.json =========================

{}


